def dumpsource(object, alias='', new=False, enclose=True):
    "'dump to source', where the code includes a pickled object.\n\n    If new=True and object is a class instance, then create a new\n    instance using the unpacked class source code. If enclose, then\n    create the object inside a function enclosure (thus minimizing\n    any global namespace pollution).\n    "
    from dill import dumps
    pik = repr(dumps(object))
    code = 'import dill\n'
    if enclose:
        stub = '__this_is_a_stub_variable__'
        pre = ('%s = ' % stub)
        new = False
    else:
        stub = alias
        pre = (('%s = ' % stub) if alias else alias)
    if ((not new) or (not _isinstance(object))):
        code += (pre + ('dill.loads(%s)\n' % pik))
    else:
        code += getsource(object.__class__, alias='', lstrip=True, force=True)
        mod = repr(object.__module__)
        if PY3:
            code += (pre + ('dill.loads(%s.replace(b%s,bytes(__name__,"UTF-8")))\n' % (pik, mod)))
        else:
            code += (pre + ('dill.loads(%s.replace(%s,__name__))\n' % (pik, mod)))
    if enclose:
        dummy = '__this_is_a_big_dummy_object__'
        dummy = _enclose(dummy, alias=alias)
        dummy = dummy.split('\n')
        code = (((dummy[0] + '\n') + indent(code)) + '\n'.join(dummy[(-3):]))
    return code
