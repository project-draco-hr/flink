def findsource(object):
    "Return the entire source file and starting line number for an object.\n    For interactively-defined objects, the 'file' is the interpreter's history.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of all the lines\n    in the file and the line number indexes a line in that list.  An IOError\n    is raised if the source code cannot be retrieved, while a TypeError is\n    raised for objects where the source code is unavailable (e.g. builtins)."
    module = getmodule(object)
    try:
        file = getfile(module)
    except TypeError:
        file = None
    if (module and (module.__name__ == '__main__') and (not file)):
        import readline
        lbuf = readline.get_current_history_length()
        lines = [(readline.get_history_item(i) + '\n') for i in range(1, lbuf)]
    else:
        try:
            if ((not isclass(object)) and isclass(type(object))):
                file = getfile(module)
                sourcefile = getsourcefile(module)
            else:
                file = getfile(object)
                sourcefile = getsourcefile(object)
        except (TypeError, AttributeError):
            file = getfile(object)
            sourcefile = getsourcefile(object)
        if ((not sourcefile) and ((file[:1] + file[(-1):]) != '<>')):
            raise IOError('source code not available')
        file = (sourcefile if sourcefile else file)
        module = getmodule(object, file)
        if module:
            lines = linecache.getlines(file, module.__dict__)
        else:
            lines = linecache.getlines(file)
    if (not lines):
        raise IOError('could not get source code')
    if ismodule(object):
        return (lines, 0)
    name = pat1 = obj = ''
    pat2 = '^(\\s*@)'
    if ismethod(object):
        name = object.__name__
        if (name == '<lambda>'):
            pat1 = '(.*(?<!\\w)lambda(:|\\s))'
        else:
            pat1 = '^(\\s*def\\s)'
        if PY3:
            object = object.__func__
        else:
            object = object.im_func
    if isfunction(object):
        name = object.__name__
        if (name == '<lambda>'):
            pat1 = '(.*(?<!\\w)lambda(:|\\s))'
            obj = object
        else:
            pat1 = '^(\\s*def\\s)'
        if PY3:
            object = object.__code__
        else:
            object = object.func_code
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if (not hasattr(object, 'co_firstlineno')):
            raise IOError('could not find function definition')
        stdin = (object.co_filename == '<stdin>')
        if stdin:
            lnum = (len(lines) - 1)
            if (not pat1):
                pat1 = '^(\\s*def\\s)|(.*(?<!\\w)lambda(:|\\s))|^(\\s*@)'
        else:
            lnum = (object.co_firstlineno - 1)
            pat1 = '^(\\s*def\\s)|(.*(?<!\\w)lambda(:|\\s))|^(\\s*@)'
        pat1 = re.compile(pat1)
        pat2 = re.compile(pat2)
        while (lnum > 0):
            line = lines[lnum]
            if pat1.match(line):
                if (not stdin):
                    break
                if (name == '<lambda>'):
                    if _matchlambda(obj, line):
                        break
                elif (name in line):
                    hats = 0
                    for _lnum in range((lnum - 1), (-1), (-1)):
                        if pat2.match(lines[_lnum]):
                            hats += 1
                        else:
                            break
                    lnum = (lnum - hats)
                    break
            lnum = (lnum - 1)
        return (lines, lnum)
    try:
        if ((not isclass(object)) and isclass(type(object))):
            object = object.__class__
    except AttributeError:
        pass
    if isclass(object):
        name = object.__name__
        pat = re.compile((('^(\\s*)class\\s*' + name) + '\\b'))
        candidates = []
        for i in range((len(lines) - 1), (-1), (-1)):
            match = pat.match(lines[i])
            if match:
                if (lines[i][0] == 'c'):
                    return (lines, i)
                candidates.append((match.group(1), i))
        if candidates:
            candidates.sort()
            return (lines, candidates[0][1])
        else:
            raise IOError('could not find class definition')
    raise IOError('could not find code object')
