def importable(obj, alias='', source=None, builtin=True):
    'get an importable string (i.e. source code or the import string)\n    for the given object, including any required objects from the enclosing\n    and global scope\n\n    This function will attempt to discover the name of the object, or the repr\n    of the object, or the source code for the object. To attempt to force\n    discovery of the source code, use source=True, to attempt to force the\n    use of an import, use source=False; otherwise an import will be sought\n    for objects not defined in __main__. The intent is to build a string\n    that can be imported from a python file.\n\n    obj is the object to inspect. If alias is provided, then rename the\n    object with the given alias. If builtin=True, then force an import for\n    builtins where possible.\n    '
    if (source is None):
        source = (True if isfrommain(obj) else False)
    elif (builtin and isbuiltin(obj)):
        source = False
    tried_source = tried_import = False
    while True:
        if (not source):
            try:
                if _isinstance(obj):
                    return _importable(obj, alias, source=False, builtin=builtin)
                src = _closuredimport(obj, alias=alias, builtin=builtin)
                if (len(src) == 0):
                    raise NotImplementedError('not implemented')
                if (len(src) > 1):
                    raise NotImplementedError('not implemented')
                return list(src.values())[0]
            except:
                if tried_source:
                    raise
                tried_import = True
        try:
            src = _closuredsource(obj, alias=alias)
            if (len(src) == 0):
                raise NotImplementedError('not implemented')

            def _code_stitcher(block):
                "stitch together the strings in tuple 'block'"
                if (block[0] and block[(-1)]):
                    block = '\n'.join(block)
                elif block[0]:
                    block = block[0]
                elif block[(-1)]:
                    block = block[(-1)]
                else:
                    block = ''
                return block
            _src = _code_stitcher(src.pop(None))
            _src = ([_src] if _src else [])
            for xxx in src.values():
                xxx = _code_stitcher(xxx)
                if xxx:
                    _src.append(xxx)
            if (not len(_src)):
                src = ''
            elif (len(_src) == 1):
                src = _src[0]
            else:
                src = '\n'.join(_src)
            from dill.detect import globalvars
            obj = globalvars(obj)
            obj = list((getsource(_obj, name, force=True) for (name, _obj) in obj.items()))
            obj = ('\n'.join(obj) if obj else '')
            if (not obj):
                return src
            if (not src):
                return obj
            return (obj + src)
        except:
            if tried_import:
                raise
            tried_source = True
            source = (not source)
    return
