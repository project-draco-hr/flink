{
  if (fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR) || fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR_SCALA)) {
    int keyPosition=0;
    for (    TypeInformation<?> type : types) {
      if (type instanceof AtomicType) {
        result.add(new FlatFieldDescriptor(offset + keyPosition,type));
      }
 else       if (type instanceof CompositeType) {
        CompositeType<?> cType=(CompositeType<?>)type;
        cType.getKey(String.valueOf(ExpressionKeys.SELECT_ALL_CHAR),offset + keyPosition,result);
        keyPosition+=cType.getTotalFields() - 1;
      }
 else {
        throw new RuntimeException("Unexpected key type: " + type);
      }
      keyPosition++;
    }
    return;
  }
  if (fieldExpression.length() < 2) {
    throw new IllegalArgumentException("The field expression '" + fieldExpression + "' is incorrect. The length must be at least 2");
  }
  if (fieldExpression.charAt(0) != 'f') {
    throw new IllegalArgumentException("The field expression '" + fieldExpression + "' is incorrect for a Tuple type. It has to start with an 'f'");
  }
  int dotPos=fieldExpression.indexOf('.');
  String nestedSplitFirst=fieldExpression;
  if (dotPos != -1) {
    Preconditions.checkArgument(dotPos != fieldExpression.length() - 1,"The field expression can never end with a dot.");
    nestedSplitFirst=fieldExpression.substring(0,dotPos);
  }
  String fieldNumStr=nestedSplitFirst.substring(1,nestedSplitFirst.length());
  if (!StringUtils.isNumeric(fieldNumStr)) {
    throw new IllegalArgumentException("The field expression '" + fieldExpression + "' is incorrect. Field number '"+ fieldNumStr+ " is not numeric");
  }
  int pos=-1;
  try {
    pos=Integer.valueOf(fieldNumStr);
  }
 catch (  NumberFormatException nfe) {
    throw new IllegalArgumentException("The field expression '" + fieldExpression + "' is incorrect. Field number '"+ fieldNumStr+ " is not numeric",nfe);
  }
  if (pos < 0) {
    throw new IllegalArgumentException("Negative position is not possible");
  }
  if (dotPos != -1) {
    String rem=fieldExpression.substring(dotPos + 1);
    if (!(types[pos] instanceof CompositeType<?>)) {
      throw new RuntimeException("Element at position " + pos + " is not a composite type. There are no nested types to select");
    }
    CompositeType<?> cType=(CompositeType<?>)types[pos];
    cType.getKey(rem,offset + pos,result);
    return;
  }
  if (pos >= types.length) {
    throw new IllegalArgumentException("The specified tuple position does not exist");
  }
  for (int i=0; i < pos; i++) {
    offset+=types[i].getTotalFields() - 1;
  }
  if (types[pos] instanceof CompositeType) {
    throw new IllegalArgumentException("The specified field '" + fieldExpression + "' is refering to a composite type.\n"+ "Either select all elements in this type with the '"+ ExpressionKeys.SELECT_ALL_CHAR+ "' operator or specify a field in the sub-type");
  }
  result.add(new FlatFieldDescriptor(offset + pos,types[pos]));
}
