{
  ExecutionConfig executionConfig=new ExecutionConfig();
  executionConfig.setAutoWatermarkInterval(watermarkInterval);
  StreamConfig cfg=new StreamConfig(new Configuration());
  cfg.setStateBackend(new MemoryStateBackend());
  cfg.setTimeCharacteristic(timeChar);
  Environment env=new DummyEnvironment("MockTwoInputTask",1,0);
  StreamTask<?,?> mockTask=mock(StreamTask.class);
  when(mockTask.getName()).thenReturn("Mock Task");
  when(mockTask.getCheckpointLock()).thenReturn(new Object());
  when(mockTask.getConfiguration()).thenReturn(cfg);
  when(mockTask.getEnvironment()).thenReturn(env);
  when(mockTask.getExecutionConfig()).thenReturn(executionConfig);
  when(mockTask.getAccumulatorMap()).thenReturn(Collections.<String,Accumulator<?,?>>emptyMap());
  doAnswer(new Answer<ScheduledFuture>(){
    @Override public ScheduledFuture answer(    InvocationOnMock invocation) throws Throwable {
      final long execTime=(Long)invocation.getArguments()[0];
      final Triggerable target=(Triggerable)invocation.getArguments()[1];
      if (timeProvider == null) {
        throw new RuntimeException("The time provider is null");
      }
      timeProvider.registerTimer(execTime,target);
      return null;
    }
  }
).when(mockTask).registerTimer(anyLong(),any(Triggerable.class));
  doAnswer(new Answer<Long>(){
    @Override public Long answer(    InvocationOnMock invocation) throws Throwable {
      if (timeProvider == null) {
        throw new RuntimeException("The time provider is null");
      }
      return timeProvider.getCurrentProcessingTime();
    }
  }
).when(mockTask).getCurrentProcessingTime();
  operator.setup(mockTask,cfg,(Output<StreamRecord<T>>)mock(Output.class));
}
