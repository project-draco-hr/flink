{
  final AbstractInvokable invokable=groupVertex.getEnvironment().getInvokable();
  @SuppressWarnings("unchecked") final AbstractInputTask<? extends InputSplit> inputTask=(AbstractInputTask<? extends InputSplit>)invokable;
  if (!LocatableInputSplit.class.isAssignableFrom(inputTask.getInputSplitType())) {
    LOG.error(groupVertex.getName() + " produces input splits of type " + inputTask.getInputSplitType()+ " and cannot be handled by this split assigner");
    return;
  }
  final InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    return;
  }
  if (inputSplits.length == 0) {
    return;
  }
  final LocatableInputSplitList splitStore=new LocatableInputSplitList();
  if (this.vertexMap.putIfAbsent(groupVertex,splitStore) != null) {
    LOG.error(groupVertex.getName() + " appears to be already registered with the locatable input split assigner, ignoring vertex...");
    return;
  }
synchronized (splitStore) {
    for (int i=0; i < inputSplits.length; ++i) {
      final InputSplit inputSplit=inputSplits[i];
      if (!(inputSplit instanceof LocatableInputSplit)) {
        LOG.error("Input split " + i + " of vertex "+ groupVertex.getName()+ " is of type "+ inputSplit.getClass()+ ", ignoring split...");
        continue;
      }
      splitStore.addSplit((LocatableInputSplit)inputSplit);
    }
  }
}
