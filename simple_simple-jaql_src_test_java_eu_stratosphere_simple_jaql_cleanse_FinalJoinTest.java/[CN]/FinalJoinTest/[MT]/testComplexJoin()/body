{
  final SopremoPlan actualPlan=this.parseScript("using cleansing;\n" + "$persons = read 'persons.json';\n" + "$funds = read 'funds.json';\n"+ "$legal_entity = read 'legal_entity.json';\n"+ "\n"+ "$result = join\n"+ "	$sponsor in $persons,\n"+ "	$relative in $persons,\n"+ "	$fund in $funds,\n"+ "	$recipient in $legal_entity,\n"+ "	$subsidiary in $legal_entity\n"+ "	where\n"+ "	($relative.id in $sponsor.relatives[*].id or\n"+ "	 $relative.id == $sponsor.id) and\n"+ "	 $fund.id in $sponsor.enacted_funds[*].id and\n"+ "	 $recipient.id in $fund.recipients and\n"+ "	($subsidiary.id in $recipient.subsidiaries[*].id\n"+ "	or $subsidiary.id == $recipient.id) and\n"+ "	 $subsidiary.id in $relative.worksFor\n"+ "	into {\n"+ "	$sponsor.*,\n"+ "	$relative.*\n"+ "};\n"+ "write $result to hdfs('result.json');");
  final SopremoPlan expectedPlan=new SopremoPlan();
  final Source persons=new Source("persons.json");
  final Source funds=new Source("funds.json");
  final Source legal_entity=new Source("legal_entity.json");
  final Join join=new Join().withInputs(persons,persons,funds,legal_entity,legal_entity).withJoinCondition(new AndExpression(new OrExpression(new ElementInSetExpression(createPath("1","id"),Quantor.EXISTS_IN,createPath("0","relatives","[*]","id")),new ComparativeExpression(createPath("1","id"),BinaryOperator.EQUAL,createPath("0","id"))),new ElementInSetExpression(createPath("2","id"),Quantor.EXISTS_IN,createPath("0","enacted_funds","[*]","id")),new ElementInSetExpression(createPath("3","id"),Quantor.EXISTS_IN,createPath("2","recipients")),new OrExpression(new ElementInSetExpression(createPath("4","id"),Quantor.EXISTS_IN,createPath("3","subsidiaries","[*]","id")),new ComparativeExpression(createPath("4","id"),BinaryOperator.EQUAL,createPath("3","id"))),new ElementInSetExpression(createPath("4","id"),Quantor.EXISTS_IN,createPath("1","worksFor")))).withResultProjection(new ObjectCreation(new ObjectCreation.CopyFields(JsonUtil.createPath("0")),new ObjectCreation.CopyFields(JsonUtil.createPath("1"))));
  final Sink result=new Sink("result.json").withInputs(join);
  expectedPlan.setSinks(result);
  assertEquals(expectedPlan,actualPlan);
}
