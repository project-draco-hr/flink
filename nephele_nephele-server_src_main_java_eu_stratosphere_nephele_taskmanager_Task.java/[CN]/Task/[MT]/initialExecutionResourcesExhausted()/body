{
  if (this.environment.getExecutingThread() != Thread.currentThread()) {
    throw new ConcurrentModificationException("initialExecutionResourcesExhausted must be called from the task that executes the user code");
  }
  final long timestamp=System.currentTimeMillis();
  final Map<ChannelID,Long> outputChannelUtilization=new HashMap<ChannelID,Long>();
  for (int i=0; i < this.environment.getNumberOfOutputGates(); ++i) {
    final RuntimeOutputGate<? extends Record> outputGate=this.environment.getOutputGate(i);
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
      outputChannelUtilization.put(outputChannel.getID(),Long.valueOf(outputChannel.getAmountOfDataTransmitted()));
    }
  }
  final ResourceUtilizationSnapshot rus=new ResourceUtilizationSnapshot(timestamp,outputChannelUtilization);
  final Iterator<ExecutionListener> it=this.registeredListeners.iterator();
  while (it.hasNext()) {
    it.next().initialExecutionResourcesExhausted(this.environment.getJobID(),this.vertexID,rus);
  }
  this.taskManager.initialExecutionResourcesExhausted(this.environment.getJobID(),this.vertexID,rus);
}
