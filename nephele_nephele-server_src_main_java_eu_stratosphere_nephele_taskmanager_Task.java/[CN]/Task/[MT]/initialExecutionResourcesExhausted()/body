{
  if (this.environment.getExecutingThread() != Thread.currentThread()) {
    throw new ConcurrentModificationException("initialExecutionResourcesExhausted must be called from the task that executes the user code");
  }
  final long timestamp=System.currentTimeMillis();
  ThreadMXBean threadBean=ManagementFactory.getThreadMXBean();
  long userCPU=(threadBean.getCurrentThreadUserTime() / NANO_TO_MILLISECONDS) * 100 / (timestamp - this.startTime);
  final Map<ChannelID,Long> outputChannelUtilization=new HashMap<ChannelID,Long>();
  for (int i=0; i < this.environment.getNumberOfOutputGates(); ++i) {
    final OutputGate<? extends Record> outputGate=this.environment.getOutputGate(i);
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
      outputChannelUtilization.put(outputChannel.getID(),Long.valueOf(outputChannel.getAmountOfDataTransmitted()));
    }
  }
  Boolean force=null;
  if (this.environment.getInvokable().getClass().isAnnotationPresent(Statefull.class) && !this.environment.getInvokable().getClass().isAnnotationPresent(Stateless.class)) {
    force=false;
  }
 else {
    ForceCheckpoint forced=this.environment.getInvokable().getClass().getAnnotation(ForceCheckpoint.class);
    if (forced != null) {
      force=forced.checkpoint();
    }
  }
  final ResourceUtilizationSnapshot rus=new ResourceUtilizationSnapshot(timestamp,outputChannelUtilization,userCPU,force);
  final Iterator<ExecutionListener> it=this.registeredListeners.iterator();
  while (it.hasNext()) {
    it.next().initialExecutionResourcesExhausted(this.environment.getJobID(),this.vertexID,rus);
  }
  this.taskManager.initialExecutionResourcesExhausted(this.environment.getJobID(),this.vertexID,rus);
}
