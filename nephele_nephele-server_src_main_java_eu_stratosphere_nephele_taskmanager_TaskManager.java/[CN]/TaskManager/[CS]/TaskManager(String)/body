{
  GlobalConfiguration.loadConfiguration(configDir);
  InetSocketAddress jobManagerAddress=null;
  if (GlobalConfiguration.getBoolean(ConfigConstants.TASK_MANAGER_USE_DISCOVERY_KEY,true)) {
    try {
      jobManagerAddress=DiscoveryService.getJobManagerAddress();
    }
 catch (    DiscoveryException e) {
      e.printStackTrace();
      System.exit(FAILURERETURNCODE);
    }
  }
 else {
    final String address=GlobalConfiguration.getString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_ADDRESS);
    final int port=GlobalConfiguration.getInteger(ConfigConstants.JOB_MANAGER_IPC_PORT_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_PORT);
    jobManagerAddress=new InetSocketAddress(address,port);
  }
  LOG.info("Determined address of job manager to be " + jobManagerAddress);
  final int ipcPort=GlobalConfiguration.getInteger(ConfigConstants.TASK_MANAGER_IPC_PORT_KEY,ConfigConstants.DEFAULT_TASK_MANAGER_IPC_PORT);
  final int dataPort=GlobalConfiguration.getInteger(ConfigConstants.TASK_MANAGER_DATA_PORT_KEY,ConfigConstants.DEFAULT_TASK_MANAGER_DATA_PORT);
  final InetAddress taskManagerAnnounceAddress=DiscoveryService.findLocalAddressOnSameNetwork(jobManagerAddress.getAddress());
  final InetSocketAddress taskManagerBindAddress=new InetSocketAddress(DiscoveryService.getServiceAddress(),ipcPort);
  this.localInstanceConnectionInfo=new InstanceConnectionInfo(taskManagerAnnounceAddress,ipcPort,dataPort);
  LOG.info("Announcing connection information " + this.localInstanceConnectionInfo + " to job manager");
  JobManagerProtocol jobManager=null;
  try {
    jobManager=(JobManagerProtocol)RPC.getProxy(JobManagerProtocol.class,jobManagerAddress,NetUtils.getSocketFactory());
  }
 catch (  IOException e) {
    LOG.error(StringUtils.stringifyException(e));
    System.exit(FAILURERETURNCODE);
  }
  this.jobManager=jobManager;
  ChannelLookupProtocol lookupService=null;
  try {
    lookupService=(ChannelLookupProtocol)RPC.getProxy(ChannelLookupProtocol.class,jobManagerAddress,NetUtils.getSocketFactory());
  }
 catch (  IOException e) {
    LOG.error(StringUtils.stringifyException(e));
    System.exit(FAILURERETURNCODE);
  }
  this.lookupService=lookupService;
  Server taskManagerServer=null;
  try {
    taskManagerServer=RPC.getServer(this,taskManagerBindAddress.getHostName(),taskManagerBindAddress.getPort(),handlerCount,false);
    taskManagerServer.start();
  }
 catch (  IOException e) {
    LOG.error(StringUtils.stringifyException(e));
    System.exit(FAILURERETURNCODE);
  }
  this.taskManagerServer=taskManagerServer;
  if (GlobalConfiguration.getBoolean(ProfilingUtils.ENABLE_PROFILING_KEY,false)) {
    final String profilerClassName=GlobalConfiguration.getString(ProfilingUtils.TASKMANAGER_CLASSNAME_KEY,null);
    if (profilerClassName == null) {
      LOG.error("Cannot find class name for the profiler");
      System.exit(FAILURERETURNCODE);
    }
    this.profiler=ProfilingUtils.loadTaskManagerProfiler(profilerClassName,jobManagerAddress.getAddress(),this.localInstanceConnectionInfo);
  }
 else {
    this.profiler=null;
    LOG.debug("Profiler disabled");
  }
  final String tmpDirPath=GlobalConfiguration.getString(ConfigConstants.TASK_MANAGER_TMP_DIR_KEY,ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH);
  ByteBufferedChannelManager byteBufferedChannelManager=null;
  try {
    byteBufferedChannelManager=new ByteBufferedChannelManager(this.lookupService,this.localInstanceConnectionInfo.getAddress(),this.localInstanceConnectionInfo.getDataPort(),tmpDirPath);
  }
 catch (  IOException ioe) {
    LOG.error(StringUtils.stringifyException(ioe));
    ioe.printStackTrace();
    System.exit(FAILURERETURNCODE);
  }
  this.byteBufferedChannelManager=byteBufferedChannelManager;
  this.directChannelManager=new DirectChannelManager();
  this.checkpointManager=new CheckpointManager(this.byteBufferedChannelManager,tmpDirPath);
  long memorySize=GlobalConfiguration.getInteger(ConfigConstants.MEMORY_MANAGER_AVAILABLE_MEMORY_SIZE_KEY,ConfigConstants.DEFAULT_MEMORY_MANAGER_AVAILABLE_MEMORY);
  if (memorySize < 1) {
    String mss=GlobalConfiguration.getString(ConfigConstants.MEMORY_MANAGER_AVAILABLE_MEMORY_FRACTION_KEY,String.valueOf(ConfigConstants.DEFAULT_MEMORY_MANAGER_AVAILABLE_MEMORY_FRACTION));
    float fract=ConfigConstants.DEFAULT_MEMORY_MANAGER_AVAILABLE_MEMORY_FRACTION;
    try {
      fract=Float.parseFloat(mss);
    }
 catch (    NumberFormatException nfex) {
      LOG.warn("Invalid parameter for " + ConfigConstants.MEMORY_MANAGER_AVAILABLE_MEMORY_FRACTION_KEY + " in the configuration. Using default value of "+ ConfigConstants.DEFAULT_MEMORY_MANAGER_AVAILABLE_MEMORY_FRACTION+ " for the memory fraction dedicated to the MemoryManager.");
    }
    LOG.info("Initializing MemoryManager with a fraction of " + fract + " of the total free memory.");
    this.memoryManager=DefaultMemoryManager.getWithHeapFraction(fract,ConfigConstants.DEFAULT_MEMORY_MANAGER_MIN_UNRESERVED_MEMORY);
  }
 else {
    LOG.info("Initializing memory manager with " + memorySize + " megabytes of memory");
    this.memoryManager=new DefaultMemoryManager(memorySize * 1024L * 1024L);
  }
  this.ioManager=new IOManager(tmpDirPath);
  Runtime.getRuntime().addShutdownHook(new TaskManagerCleanUp(this));
}
