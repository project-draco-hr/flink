{
  Deadline deadline=new FiniteDuration(2,TimeUnit.MINUTES).fromNow();
  Configuration flinkConfiguration=new Configuration();
  flinkConfiguration.setString(KEY_METRICS_SCOPE_NAMING_JM_JOB,"jobmanager.<job_name>");
  TestingCluster flink=new TestingCluster(flinkConfiguration);
  try {
    flink.start();
    JobVertex sourceJobVertex=new JobVertex("Source");
    sourceJobVertex.setInvokableClass(BlockingInvokable.class);
    JobGraph jobGraph=new JobGraph("TestingJob",sourceJobVertex);
    jobGraph.setSnapshotSettings(new JobSnapshottingSettings(Collections.<JobVertexID>emptyList(),Collections.<JobVertexID>emptyList(),Collections.<JobVertexID>emptyList(),500,500,50,5));
    flink.waitForActorsToBeAlive();
    flink.submitJobDetached(jobGraph);
    Future<Object> jobRunning=flink.getLeaderGateway(deadline.timeLeft()).ask(new TestingJobManagerMessages.NotifyWhenJobStatus(jobGraph.getJobID(),JobStatus.RUNNING),deadline.timeLeft());
    Await.ready(jobRunning,deadline.timeLeft());
    MBeanServer mBeanServer=ManagementFactory.getPlatformMBeanServer();
    ObjectName objectName1=new ObjectName("org.apache.flink.metrics:key0=jobmanager,key1=TestingJob,name=lastCheckpointSize");
    assertEquals(-1L,mBeanServer.getAttribute(objectName1,"Value"));
    Future<Object> jobFinished=flink.getLeaderGateway(deadline.timeLeft()).ask(new TestingJobManagerMessages.NotifyWhenJobRemoved(jobGraph.getJobID()),deadline.timeLeft());
    BlockingInvokable.unblock();
    Await.ready(jobFinished,deadline.timeLeft());
  }
  finally {
    flink.stop();
  }
}
