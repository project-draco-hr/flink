{
  final int outputIndex=sourceConfig.getNumOutputs();
  sourceConfig.addOutputShipStrategy(channel.getShipStrategy());
  if (outputIndex == 0) {
    sourceConfig.setOutputSerializer(channel.getSerializer());
  }
  if (channel.getShipStrategyComparator() != null) {
    sourceConfig.setOutputComparator(channel.getShipStrategyComparator(),outputIndex);
  }
  if (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {
    final DataDistribution dataDistribution=channel.getDataDistribution();
    if (dataDistribution != null) {
      sourceConfig.setOutputDataDistribution(dataDistribution,outputIndex);
    }
 else {
      throw new RuntimeException("Range partitioning requires data distribution");
    }
  }
  if (isBroadcast) {
    targetConfig.addBroadcastInputToGroup(inputNumber);
  }
 else {
    targetConfig.addInputToGroup(inputNumber);
  }
  FlinkEdge edge;
  ShipStrategyType shipStrategy=channel.getShipStrategy();
  TypeSerializer<?> serializer=channel.getSerializer().getSerializer();
  if ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {
    edge=new FlinkForwardEdge(sourceVertex,targetVertex,serializer);
    targetVertex.setParallelism(sourceVertex.getParallelism());
  }
 else   if (shipStrategy == ShipStrategyType.BROADCAST) {
    edge=new FlinkBroadcastEdge(sourceVertex,targetVertex,serializer);
  }
 else   if (shipStrategy == ShipStrategyType.PARTITION_HASH) {
    edge=new FlinkPartitionEdge(sourceVertex,targetVertex,serializer);
  }
 else {
    throw new CompilerException("Ship strategy between nodes " + sourceVertex.getVertex().getName() + " and "+ targetVertex.getVertex().getName()+ " currently not supported");
  }
  sourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(),outputIndex);
  targetVertex.addInput(sourceVertex,inputNumber);
  edges.add(edge);
}
