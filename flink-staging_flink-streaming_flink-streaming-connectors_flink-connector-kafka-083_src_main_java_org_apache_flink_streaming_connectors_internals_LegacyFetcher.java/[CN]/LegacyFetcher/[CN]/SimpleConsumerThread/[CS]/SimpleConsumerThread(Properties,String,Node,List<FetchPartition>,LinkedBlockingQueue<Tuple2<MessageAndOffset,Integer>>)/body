{
  Preconditions.checkNotNull(leader,"Leader can not be null");
  Preconditions.checkNotNull(config,"The config properties can not be null");
  int soTimeout=Integer.valueOf(config.getProperty("socket.timeout.ms","30000"));
  int bufferSize=Integer.valueOf(config.getProperty("socket.receive.buffer.bytes","65536"));
  this.fetchSize=Integer.valueOf(config.getProperty("fetch.message.max.bytes","1048576"));
  this.maxWait=Integer.valueOf(config.getProperty("fetch.wait.max.ms","100"));
  this.minBytes=Integer.valueOf(config.getProperty("fetch.min.bytes","1"));
  this.topic=topic;
  this.partitions=partitions;
  this.messageQueue=messageQueue;
  this.clientId="flink-kafka-consumer-legacy-" + leader.idString();
  consumer=new SimpleConsumer(leader.host(),leader.port(),bufferSize,soTimeout,clientId);
  List<FetchPartition> getOffsetPartitions=new ArrayList<FetchPartition>();
  for (  FetchPartition fp : partitions) {
    if (fp.nextOffsetToRead == FlinkKafkaConsumerBase.OFFSET_NOT_SET) {
      getOffsetPartitions.add(fp);
    }
  }
  if (getOffsetPartitions.size() > 0) {
    long timeType=0;
    if (config.getProperty("auto.offset.reset","latest").equals("latest")) {
      timeType=OffsetRequest.LatestTime();
    }
 else {
      timeType=OffsetRequest.EarliestTime();
    }
    getLastOffset(consumer,topic,getOffsetPartitions,timeType);
    LOG.info("No offsets found for topic " + topic + ", fetched the following start offsets {}",getOffsetPartitions);
  }
}
