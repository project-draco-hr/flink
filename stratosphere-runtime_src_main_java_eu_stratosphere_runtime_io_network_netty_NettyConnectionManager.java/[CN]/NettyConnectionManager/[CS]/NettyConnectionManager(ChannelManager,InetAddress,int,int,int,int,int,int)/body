{
  this.outConnections=new ConcurrentHashMap<RemoteReceiver,Object>();
  this.channelManager=channelManager;
  int defaultNumThreads=Math.max(Runtime.getRuntime().availableProcessors() / 4,1);
  numInThreads=(numInThreads == -1) ? defaultNumThreads : numInThreads;
  numOutThreads=(numOutThreads == -1) ? defaultNumThreads : numOutThreads;
  LOG.info(String.format("Starting with %d incoming and %d outgoing connection threads.",numInThreads,numOutThreads));
  lowWaterMark=(lowWaterMark == -1) ? bufferSize / 2 : lowWaterMark;
  highWaterMark=(highWaterMark == -1) ? bufferSize : highWaterMark;
  LOG.info(String.format("Setting low water mark to %d and high water mark to %d bytes.",lowWaterMark,highWaterMark));
  this.in=new ServerBootstrap();
  this.in.group(new NioEventLoopGroup(numInThreads)).channel(NioServerSocketChannel.class).localAddress(bindAddress,bindPort).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel channel) throws Exception {
      channel.pipeline().addLast(new InboundEnvelopeDecoder(NettyConnectionManager.this.channelManager)).addLast(new InboundEnvelopeDispatcherHandler(NettyConnectionManager.this.channelManager));
    }
  }
).option(ChannelOption.RCVBUF_ALLOCATOR,new FixedRecvByteBufAllocator(bufferSize)).option(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT);
  this.out=new Bootstrap();
  this.out.group(new NioEventLoopGroup(numOutThreads)).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel channel) throws Exception {
      channel.pipeline().addLast(new OutboundEnvelopeEncoder());
    }
  }
).option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK,lowWaterMark).option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK,highWaterMark).option(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT).option(ChannelOption.TCP_NODELAY,false).option(ChannelOption.SO_KEEPALIVE,true);
  try {
    this.in.bind().sync();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException("Could not bind server socket for incoming connections.");
  }
  if (LOG.isDebugEnabled()) {
    new Thread(new Runnable(){
      @Override public void run(){
        Date date=new Date();
        while (true) {
          try {
            Thread.sleep(DEBUG_PRINT_QUEUED_ENVELOPES_EVERY_MS);
            date.setTime(System.currentTimeMillis());
            System.out.println(date);
            System.out.println(getNonZeroNumQueuedEnvelopes());
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
).start();
  }
}
