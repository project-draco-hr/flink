{
  final JobSubmissionResult submissionResult=submitJob();
  if (submissionResult.returnCode() == JobResult.ERROR()) {
    LOG.error("ERROR: " + submissionResult.description());
    throw new JobExecutionException(submissionResult.description(),false);
  }
  long sleep=0;
  final int interval=AkkaUtils.<Integer>ask(jobManager,JobManagerMessages.RequestPollingInterval$.MODULE$);
  sleep=interval * 1000;
  try {
    Thread.sleep(sleep / 2);
  }
 catch (  InterruptedException e) {
    logErrorAndRethrow(StringUtils.stringifyException(e));
  }
  long startTimestamp=-1;
  while (true) {
    if (Thread.interrupted()) {
      logErrorAndRethrow("Job client has been interrupted");
    }
    JobResult.JobProgressResult jobProgressResult=null;
    jobProgressResult=getJobProgress();
    if (jobProgressResult == null) {
      logErrorAndRethrow("Returned job progress is unexpectedly null!");
    }
    if (jobProgressResult.returnCode() == JobResult.ERROR()) {
      logErrorAndRethrow("Could not retrieve job progress: " + jobProgressResult.description());
    }
    final Iterator<AbstractEvent> it=jobProgressResult.asJavaList().iterator();
    while (it.hasNext()) {
      final AbstractEvent event=it.next();
      if (this.lastProcessedEventSequenceNumber >= event.getSequenceNumber()) {
        continue;
      }
      LOG.info(event.toString());
      if (this.console != null) {
        this.console.println(event.toString());
      }
      this.lastProcessedEventSequenceNumber=event.getSequenceNumber();
      if (event instanceof JobEvent) {
        final JobEvent jobEvent=(JobEvent)event;
        final JobStatus jobStatus=jobEvent.getCurrentJobStatus();
        if (jobStatus == JobStatus.RUNNING) {
          startTimestamp=jobEvent.getTimestamp();
        }
        if (jobStatus == JobStatus.FINISHED) {
          final long jobDuration=jobEvent.getTimestamp() - startTimestamp;
          Map<String,Object> accumulators=null;
          accumulators=AccumulatorHelper.toResultMap(getAccumulators().getAccumulators(this.userCodeClassLoader));
          return new JobExecutionResult(jobDuration,accumulators);
        }
 else         if (jobStatus == JobStatus.CANCELED || jobStatus == JobStatus.FAILED) {
          LOG.info(jobEvent.getOptionalMessage());
          if (jobStatus == JobStatus.CANCELED) {
            throw new JobExecutionException(jobEvent.getOptionalMessage(),true);
          }
 else {
            throw new JobExecutionException(jobEvent.getOptionalMessage(),false);
          }
        }
      }
    }
    try {
      Thread.sleep(sleep);
    }
 catch (    InterruptedException e) {
      logErrorAndRethrow(StringUtils.stringifyException(e));
    }
  }
}
