{
synchronized (this.jobSubmitClient) {
    final JobSubmissionResult submissionResult=submitJob();
    if (submissionResult.getReturnCode() == AbstractJobResult.ReturnCode.ERROR) {
      LOG.error("ERROR: " + submissionResult.getDescription());
      throw new JobExecutionException(submissionResult.getDescription(),false);
    }
    Runtime.getRuntime().addShutdownHook(this.jobCleanUp);
  }
  long sleep=0;
  try {
    final IntegerRecord interval=this.jobSubmitClient.getRecommendedPollingInterval();
    sleep=interval.getValue() * 1000;
  }
 catch (  IOException ioe) {
    Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
    throw ioe;
  }
  try {
    Thread.sleep(sleep / 2);
  }
 catch (  InterruptedException e) {
    Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
    logErrorAndRethrow(StringUtils.stringifyException(e));
  }
  long startTimestamp=-1;
  while (true) {
    if (Thread.interrupted()) {
      logErrorAndRethrow("Job client has been interrupted");
    }
    JobProgressResult jobProgressResult=null;
    try {
      jobProgressResult=getJobProgress();
    }
 catch (    IOException ioe) {
      Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
      throw ioe;
    }
    if (jobProgressResult == null) {
      logErrorAndRethrow("Returned job progress is unexpectedly null!");
    }
    if (jobProgressResult.getReturnCode() == AbstractJobResult.ReturnCode.ERROR) {
      logErrorAndRethrow("Could not retrieve job progress: " + jobProgressResult.getDescription());
    }
    final Iterator<AbstractEvent> it=jobProgressResult.getEvents();
    while (it.hasNext()) {
      final AbstractEvent event=it.next();
      if (this.lastProcessedEventSequenceNumber >= event.getSequenceNumber()) {
        continue;
      }
      LOG.info(event.toString());
      if (this.console != null) {
        this.console.println(event.toString());
      }
      this.lastProcessedEventSequenceNumber=event.getSequenceNumber();
      if (event instanceof JobEvent) {
        final JobEvent jobEvent=(JobEvent)event;
        final JobStatus jobStatus=jobEvent.getCurrentJobStatus();
        if (jobStatus == JobStatus.RUNNING) {
          startTimestamp=jobEvent.getTimestamp();
        }
        if (jobStatus == JobStatus.FINISHED) {
          Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
          final long jobDuration=jobEvent.getTimestamp() - startTimestamp;
          Map<String,Object> accumulators=null;
          try {
            accumulators=AccumulatorHelper.toResultMap(getAccumulators().getAccumulators(this.userCodeClassLoader));
          }
 catch (          IOException ioe) {
            Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
            throw ioe;
          }
          return new JobExecutionResult(jobDuration,accumulators);
        }
 else         if (jobStatus == JobStatus.CANCELED || jobStatus == JobStatus.FAILED) {
          Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
          LOG.info(jobEvent.getOptionalMessage());
          if (jobStatus == JobStatus.CANCELED) {
            throw new JobExecutionException(jobEvent.getOptionalMessage(),true);
          }
 else {
            throw new JobExecutionException(jobEvent.getOptionalMessage(),false);
          }
        }
      }
    }
    try {
      Thread.sleep(sleep);
    }
 catch (    InterruptedException e) {
      logErrorAndRethrow(StringUtils.stringifyException(e));
    }
  }
}
