{
  final JobGraph jobGraph=new JobGraph("Iteration Tail with Chaining");
  final TypeSerializerFactory<Record> serializer=RecordSerializerFactory.get();
  @SuppressWarnings("unchecked") final TypeComparatorFactory<Record> comparator=new RecordComparatorFactory(new int[]{0},new Class[]{IntValue.class});
  final int ITERATION_ID=1;
  InputFormatVertex input=JobGraphUtils.createInput(new PointInFormat(),inputPath,"Input",jobGraph,numSubTasks);
  TaskConfig inputConfig=new TaskConfig(input.getConfiguration());
{
    inputConfig.setOutputSerializer(serializer);
    inputConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
  }
  AbstractJobVertex head=JobGraphUtils.createTask(IterationHeadPactTask.class,"Iteration Head",jobGraph,numSubTasks);
  TaskConfig headConfig=new TaskConfig(head.getConfiguration());
{
    headConfig.setIterationId(ITERATION_ID);
    headConfig.addInputToGroup(0);
    headConfig.setInputSerializer(serializer,0);
    headConfig.setInputLocalStrategy(0,LocalStrategy.NONE);
    headConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0);
    headConfig.setOutputSerializer(serializer);
    headConfig.addOutputShipStrategy(ShipStrategyType.PARTITION_HASH);
    headConfig.setOutputComparator(comparator,0);
    TaskConfig headFinalOutConfig=new TaskConfig(new Configuration());
    headFinalOutConfig.setOutputSerializer(serializer);
    headFinalOutConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
    headConfig.setIterationHeadFinalOutputConfig(headFinalOutConfig);
    headConfig.setIterationHeadIndexOfSyncOutput(2);
    headConfig.setDriver(CollectorMapDriver.class);
    headConfig.setDriverStrategy(DriverStrategy.COLLECTOR_MAP);
    headConfig.setStubWrapper(new UserCodeClassWrapper<DummyMapper>(DummyMapper.class));
    headConfig.setRelativeBackChannelMemory(1.0);
  }
  AbstractJobVertex tail=JobGraphUtils.createTask(IterationTailPactTask.class,"Chained Iteration Tail",jobGraph,numSubTasks);
  TaskConfig tailConfig=new TaskConfig(tail.getConfiguration());
{
    tailConfig.setIterationId(ITERATION_ID);
    tailConfig.addInputToGroup(0);
    tailConfig.setInputSerializer(serializer,0);
    tailConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
    tailConfig.setOutputSerializer(serializer);
    tailConfig.setDriver(GroupReduceDriver.class);
    tailConfig.setDriverStrategy(DriverStrategy.SORTED_GROUP_REDUCE);
    tailConfig.setDriverComparator(comparator,0);
    tailConfig.setStubWrapper(new UserCodeClassWrapper<DummyReducer>(DummyReducer.class));
    TaskConfig chainedMapperConfig=new TaskConfig(new Configuration());
    chainedMapperConfig.setDriverStrategy(DriverStrategy.COLLECTOR_MAP);
    chainedMapperConfig.setStubWrapper(new UserCodeClassWrapper<IncrementCoordinatesMapper>(IncrementCoordinatesMapper.class));
    chainedMapperConfig.setInputLocalStrategy(0,LocalStrategy.NONE);
    chainedMapperConfig.setInputSerializer(serializer,0);
    chainedMapperConfig.setOutputSerializer(serializer);
    chainedMapperConfig.setIsWorksetUpdate();
    tailConfig.addChainedTask(ChainedCollectorMapDriver.class,chainedMapperConfig,"Chained ID Mapper");
  }
  OutputFormatVertex output=JobGraphUtils.createFileOutput(jobGraph,"Output",numSubTasks);
  TaskConfig outputConfig=new TaskConfig(output.getConfiguration());
{
    outputConfig.addInputToGroup(0);
    outputConfig.setInputSerializer(serializer,0);
    outputConfig.setStubWrapper(new UserCodeClassWrapper<PointOutFormat>(PointOutFormat.class));
    outputConfig.setStubParameter(FileOutputFormat.FILE_PARAMETER_KEY,outputPath);
  }
  AbstractJobVertex sync=JobGraphUtils.createSync(jobGraph,numSubTasks);
  TaskConfig syncConfig=new TaskConfig(sync.getConfiguration());
  syncConfig.setNumberOfIterations(maxIterations);
  syncConfig.setIterationId(ITERATION_ID);
  JobGraphUtils.connect(input,head,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(head,tail,DistributionPattern.ALL_TO_ALL);
  tailConfig.setGateIterativeWithNumberOfEventsUntilInterrupt(0,numSubTasks);
  JobGraphUtils.connect(head,output,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(head,sync,DistributionPattern.POINTWISE);
  SlotSharingGroup sharingGroup=new SlotSharingGroup();
  input.setSlotSharingGroup(sharingGroup);
  head.setSlotSharingGroup(sharingGroup);
  tail.setSlotSharingGroup(sharingGroup);
  output.setSlotSharingGroup(sharingGroup);
  sync.setSlotSharingGroup(sharingGroup);
  tail.setStrictlyCoLocatedWith(head);
  return jobGraph;
}
