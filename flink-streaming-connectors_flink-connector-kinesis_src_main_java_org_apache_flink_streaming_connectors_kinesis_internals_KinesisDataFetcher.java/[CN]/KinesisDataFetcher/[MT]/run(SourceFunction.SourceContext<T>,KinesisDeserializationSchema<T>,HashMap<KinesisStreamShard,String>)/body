{
  if (assignedShardsWithStartingSequenceNum == null || assignedShardsWithStartingSequenceNum.size() == 0) {
    throw new IllegalArgumentException("No shards set to read for this fetcher");
  }
  this.mainThread=Thread.currentThread();
  LOG.info("Reading from shards " + assignedShardsWithStartingSequenceNum);
  ArrayList<ShardConsumerThread<?>> consumerThreads=new ArrayList<>(assignedShardsWithStartingSequenceNum.size());
  for (  Map.Entry<KinesisStreamShard,String> assignedShard : assignedShardsWithStartingSequenceNum.entrySet()) {
    ShardConsumerThread<T> thread=new ShardConsumerThread<>(this,configProps,assignedShard.getKey(),assignedShard.getValue(),sourceContext,deserializationSchema,lastSequenceNums);
    thread.setName(String.format("ShardConsumer - %s - %s/%s",taskName,assignedShard.getKey().getStreamName(),assignedShard.getKey().getShardId()));
    thread.setDaemon(true);
    consumerThreads.add(thread);
  }
  if (!running) {
    return;
  }
  for (  ShardConsumerThread<?> shardConsumer : consumerThreads) {
    LOG.info("Starting thread {}",shardConsumer.getName());
    shardConsumer.start();
  }
  try {
    boolean consumersStillRunning=true;
    while (running && error.get() == null && consumersStillRunning) {
      try {
        for (        ShardConsumerThread<?> consumerThread : consumerThreads) {
          consumerThread.join();
        }
        consumersStillRunning=false;
        for (        ShardConsumerThread<?> consumerThread : consumerThreads) {
          consumersStillRunning=consumersStillRunning | consumerThread.isAlive();
        }
      }
 catch (      InterruptedException e) {
      }
    }
    Throwable error=this.error.get();
    if (error != null) {
      throw new Exception(error.getMessage(),error);
    }
  }
  finally {
    for (    ShardConsumerThread<?> consumerThread : consumerThreads) {
      if (consumerThread.isAlive()) {
        consumerThread.cancel();
      }
    }
  }
}
