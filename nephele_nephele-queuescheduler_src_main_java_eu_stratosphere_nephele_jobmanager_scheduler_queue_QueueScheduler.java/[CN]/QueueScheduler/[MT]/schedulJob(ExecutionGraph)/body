{
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  final Iterator<ExecutionStage> stageIt=executionGraph.iterator();
  while (stageIt.hasNext()) {
    final InstanceRequestMap instanceRequestMap=new InstanceRequestMap();
    final ExecutionStage stage=stageIt.next();
    stage.collectRequiredInstanceTypes(instanceRequestMap,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMinimumIterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException("Unable to schedule job: No instance of type " + entry.getKey() + " available");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException("Unable to schedule job: " + entry.getValue().intValue() + " instances of type "+ entry.getKey()+ " required, but only "+ descr.getMaximumNumberOfAvailableInstances()+ " are available");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    vertex.registerExecutionStateListener(new QueueExecutionStateListener(this,vertex));
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    final String exceptionMessage=StringUtils.stringifyException(e);
    LOG.error(exceptionMessage);
    this.jobQueue.remove(executionGraph);
    throw new SchedulingException(exceptionMessage);
  }
}
