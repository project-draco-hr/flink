{
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error("Execution vertex " + vertex + " has state "+ vertex.getExecutionState()+ ", expected "+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
    final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
    try {
      requestInstances(executionStage);
    }
 catch (    InstanceException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}
