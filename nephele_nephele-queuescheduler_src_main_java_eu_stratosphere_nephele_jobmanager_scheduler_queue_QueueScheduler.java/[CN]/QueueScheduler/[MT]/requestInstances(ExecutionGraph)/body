{
  final Map<InstanceType,Integer> requiredInstances=new HashMap<InstanceType,Integer>();
  executionGraph.collectInstanceTypesRequiredForCurrentStage(requiredInstances,ExecutionState.SCHEDULED);
  if (requiredInstances.isEmpty()) {
    return;
  }
  final Iterator<InstanceType> it=requiredInstances.keySet().iterator();
  while (it.hasNext()) {
    final InstanceType type=it.next();
    for (int i=0; i < requiredInstances.get(type).intValue(); i++) {
      LOG.info("Trying to allocate instance of type " + type.getIdentifier());
      this.instanceManager.requestInstance(executionGraph.getJobID(),executionGraph.getJobConfiguration(),type);
    }
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,executionGraph.getIndexOfCurrentExecutionStage(),true,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.setExecutionState(ExecutionState.ASSIGNING);
    }
  }
}
