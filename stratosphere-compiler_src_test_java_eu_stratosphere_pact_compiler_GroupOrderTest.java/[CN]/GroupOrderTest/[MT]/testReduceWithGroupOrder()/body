{
  FileDataSource source=new FileDataSource(new DummyInputFormat(),IN_FILE,"Source");
  ReduceOperator reduce=ReduceOperator.builder(new IdentityReduce()).keyField(IntValue.class,2).name("Reduce").input(source).build();
  Ordering groupOrder=new Ordering(5,StringValue.class,Order.DESCENDING);
  reduce.setGroupOrder(groupOrder);
  FileDataSink sink=new FileDataSink(new DummyOutputFormat(),OUT_FILE,reduce,"Sink");
  Plan plan=new Plan(sink,"Test Temp Task");
  plan.setDefaultParallelism(DEFAULT_PARALLELISM);
  OptimizedPlan oPlan;
  try {
    oPlan=compileNoStats(plan);
  }
 catch (  CompilerException ce) {
    ce.printStackTrace();
    fail("The pact compiler is unable to compile this plan correctly.");
    return;
  }
  OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(oPlan);
  SinkPlanNode sinkNode=resolver.getNode("Sink");
  SingleInputPlanNode reducer=resolver.getNode("Reduce");
  Assert.assertEquals(ShipStrategyType.FORWARD,sinkNode.getInput().getShipStrategy());
  Assert.assertEquals(ShipStrategyType.PARTITION_HASH,reducer.getInput().getShipStrategy());
  Channel c=reducer.getInput();
  Assert.assertEquals(LocalStrategy.SORT,c.getLocalStrategy());
  FieldList ship=new FieldList(2);
  FieldList local=new FieldList(2);
  local.add(5);
  Assert.assertEquals(ship,c.getShipStrategyKeys());
  Assert.assertEquals(local,c.getLocalStrategyKeys());
  Assert.assertTrue(c.getLocalStrategySortOrder()[0] == reducer.getSortOrders()[0]);
  Assert.assertTrue(c.getLocalStrategySortOrder()[1] == groupOrder.getFieldSortDirections()[0]);
}
