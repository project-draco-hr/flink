{
  if (!alreadyVisited.add(vertex)) {
    return;
  }
  if (vertex.compareAndUpdateExecutionState(ExecutionState.ASSIGNED,ExecutionState.READY)) {
    final AbstractInstance instance=vertex.getAllocatedResource().getInstance();
    if (instance instanceof DummyInstance) {
      LOG.error("Inconsistency: Vertex " + vertex + " is about to be deployed on a DummyInstance");
    }
    List<ExecutionVertex> verticesForInstance=verticesToBeDeployed.get(instance);
    if (verticesForInstance == null) {
      verticesForInstance=new ArrayList<ExecutionVertex>();
      verticesToBeDeployed.put(instance,verticesForInstance);
    }
    verticesForInstance.add(vertex);
  }
  final int numberOfOutputGates=vertex.getNumberOfOutputGates();
  for (int i=0; i < numberOfOutputGates; ++i) {
    final ExecutionGate outputGate=vertex.getOutputGate(i);
    boolean deployTarget;
switch (outputGate.getChannelType()) {
case NETWORK:
      deployTarget=false;
    break;
case INMEMORY:
  deployTarget=true;
break;
default :
throw new IllegalStateException("Unknown channel type");
}
if (deployTarget) {
final int numberOfOutputChannels=outputGate.getNumberOfEdges();
for (int j=0; j < numberOfOutputChannels; ++j) {
final ExecutionEdge outputChannel=outputGate.getEdge(j);
final ExecutionVertex connectedVertex=outputChannel.getInputGate().getVertex();
findVerticesToBeDeployed(connectedVertex,verticesToBeDeployed,alreadyVisited);
}
}
}
}
