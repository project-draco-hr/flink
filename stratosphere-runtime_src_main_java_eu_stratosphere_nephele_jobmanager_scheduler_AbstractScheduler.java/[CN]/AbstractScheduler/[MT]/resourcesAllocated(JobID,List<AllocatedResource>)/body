{
  if (allocatedResources == null) {
    LOG.error("Resource to lock is null!");
    return;
  }
  for (  final AllocatedResource allocatedResource : allocatedResources) {
    if (allocatedResource.getInstance() instanceof DummyInstance) {
      LOG.debug("Available instance is of type DummyInstance!");
      return;
    }
  }
  final ExecutionGraph eg=getExecutionGraphByID(jobID);
  if (eg == null) {
    try {
      for (      final AllocatedResource allocatedResource : allocatedResources) {
        getInstanceManager().releaseAllocatedResource(jobID,null,allocatedResource);
      }
    }
 catch (    InstanceException e) {
      LOG.error(e);
    }
    return;
  }
  final Runnable command=new Runnable(){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
      final ExecutionStage stage=eg.getCurrentExecutionStage();
synchronized (stage) {
        for (        final AllocatedResource allocatedResource : allocatedResources) {
          AllocatedResource resourceToBeReplaced=null;
          final Iterator<ExecutionGroupVertex> groupIterator=new ExecutionGroupVertexIterator(eg,true,stage.getStageNumber());
          while (groupIterator.hasNext()) {
            final ExecutionGroupVertex groupVertex=groupIterator.next();
            for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); ++i) {
              final ExecutionVertex vertex=groupVertex.getGroupMember(i);
              if (vertex.getExecutionState() == ExecutionState.SCHEDULED && vertex.getAllocatedResource() != null) {
                if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
                  resourceToBeReplaced=vertex.getAllocatedResource();
                  break;
                }
              }
            }
            if (resourceToBeReplaced != null) {
              break;
            }
          }
          if (resourceToBeReplaced == null) {
            LOG.error("Instance " + allocatedResource.getInstance() + " is not required for job"+ eg.getJobID());
            try {
              getInstanceManager().releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
            }
 catch (            InstanceException e) {
              LOG.error(e);
            }
            return;
          }
          final Iterator<ExecutionVertex> it=resourceToBeReplaced.assignedVertices();
          while (it.hasNext()) {
            final ExecutionVertex vertex=it.next();
            vertex.setAllocatedResource(allocatedResource);
            vertex.updateExecutionState(ExecutionState.ASSIGNED);
          }
        }
      }
      deployAssignedInputVertices(eg);
    }
  }
;
  eg.executeCommand(command);
}
