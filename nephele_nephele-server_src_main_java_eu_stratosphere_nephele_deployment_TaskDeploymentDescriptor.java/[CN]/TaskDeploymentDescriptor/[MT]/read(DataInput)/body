{
  this.jobID.read(in);
  this.vertexID.read(in);
  this.taskName=StringRecord.readString(in);
  this.indexInSubtaskGroup=in.readInt();
  this.currentNumberOfSubtasks=in.readInt();
  this.jobConfiguration.read(in);
  this.taskConfiguration.read(in);
  this.initialCheckpointState=EnumUtils.readEnum(in,CheckpointState.class);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException("invokableClassName is null");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException("Class " + invokableClassName + " not found in one of the supplied jar files: "+ StringUtils.stringifyException(cnfe));
  }
  this.outputGates.read(in);
  this.inputGates.read(in);
}
