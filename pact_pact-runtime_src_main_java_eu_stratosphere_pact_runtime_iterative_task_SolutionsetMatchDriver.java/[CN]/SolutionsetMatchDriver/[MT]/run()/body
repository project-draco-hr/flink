{
  final GenericMatcher<IT1,IT2,OT> matchStub=taskContext.getStub();
  final UpdateSolutionsetOutputCollector<OT> collector=this.collector;
  final MutableObjectIterator<IT1> probeSide=taskContext.getInput(0);
  final MutableObjectIterator<IT2> buildSide=taskContext.getInput(1);
  final MutableHashTable<IT2,IT1> hashJoin=Preconditions.checkNotNull(this.hashJoin);
  if (firstIteration) {
    hashJoin.open(buildSide,EmptyMutableObjectIterator.<IT1>get());
  }
  final IT1 probeSideRecord=taskContext.<IT1>getInputSerializer(0).createInstance();
  final IT2 buildSideRecord=taskContext.<IT2>getInputSerializer(1).createInstance();
  long possibleUpdates=0;
  while (running && probeSide.next(probeSideRecord)) {
    MutableHashTable.HashBucketIterator<IT2,IT1> bucket=hashJoin.getMatchesFor(probeSideRecord);
    bucket.next(buildSideRecord);
    collector.setHashBucket(bucket);
    matchStub.match(probeSideRecord,buildSideRecord,collector);
    possibleUpdates++;
  }
  long numUpdatedElements=collector.getNumUpdatedElementsAndReset();
  int workerIndex=taskContext.getOwningNepheleTask().getIndexInSubtaskGroup();
  if (log.isInfoEnabled()) {
    log.info("[" + numUpdatedElements + "] elements updated in the solutionset partition of worker "+ "["+ workerIndex+ "], possible updates ["+ possibleUpdates+ "]");
  }
  IterationContext.instance().setCount(workerIndex,numUpdatedElements);
}
