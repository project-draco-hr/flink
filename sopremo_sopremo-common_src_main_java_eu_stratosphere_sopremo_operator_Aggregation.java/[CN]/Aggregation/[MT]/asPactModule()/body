{
  if (this.getInputOperators().size() > 2)   throw new UnsupportedOperationException();
  PactModule module=new PactModule(this.getInputOperators().size(),1);
  List<Contract> keyExtractors=new ArrayList<Contract>();
  for (  Path grouping : groupings)   keyExtractors.add(addKeyExtraction(module,grouping));
switch (groupings.size()) {
case 0:
    keyExtractors.add(addKeyExtraction(module,new Path(new Input(0),new Constant(1L))));
case 1:
  ReduceContract<PactJsonObject.Key,PactJsonObject,PactNull,PactJsonObject> aggregationReduce=new ReduceContract<PactJsonObject.Key,PactJsonObject,PactNull,PactJsonObject>(OneSourceAggregationStub.class);
module.getOutput(0).setInput(aggregationReduce);
aggregationReduce.setInput(keyExtractors.get(0));
setEvaluableExpression(aggregationReduce.getStubParameters(),"transformation",this.getEvaluableExpression());
break;
default :
CoGroupContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,PactNull,PactJsonObject> aggregationCoGroup=new CoGroupContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,PactNull,PactJsonObject>(TwoSourceAggregationStub.class);
module.getOutput(0).setInput(aggregationCoGroup);
aggregationCoGroup.setFirstInput(keyExtractors.get(0));
aggregationCoGroup.setSecondInput(keyExtractors.get(1));
setEvaluableExpression(aggregationCoGroup.getStubParameters(),"transformation",this.getEvaluableExpression());
break;
}
return module;
}
