{
  if (this.getInputOperators().size() > 2)   throw new UnsupportedOperationException();
  PactModule module=new PactModule(this.getInputOperators().size(),1);
  List<Contract> keyExtractors=new ArrayList<Contract>();
  for (  Path grouping : groupings)   keyExtractors.add(PactUtil.addKeyExtraction(module,grouping,context));
switch (groupings.size()) {
case 0:
    keyExtractors.add(PactUtil.addKeyExtraction(module,new Path(new Input(0),new Constant(1L)),context));
case 1:
  ReduceContract<PactJsonObject.Key,PactJsonObject,Key,PactJsonObject> aggregationReduce=new ReduceContract<PactJsonObject.Key,PactJsonObject,Key,PactJsonObject>(OneSourceAggregationStub.class);
module.getOutput(0).setInput(aggregationReduce);
aggregationReduce.setInput(keyExtractors.get(0));
PactUtil.setTransformationAndContext(aggregationReduce.getStubParameters(),this.getEvaluableExpression(),context);
break;
default :
CoGroupContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,Key,PactJsonObject> aggregationCoGroup=new CoGroupContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,Key,PactJsonObject>(TwoSourceAggregationStub.class);
module.getOutput(0).setInput(aggregationCoGroup);
aggregationCoGroup.setFirstInput(keyExtractors.get(0));
aggregationCoGroup.setSecondInput(keyExtractors.get(1));
PactUtil.setTransformationAndContext(aggregationCoGroup.getStubParameters(),this.getEvaluableExpression(),context);
break;
}
return module;
}
