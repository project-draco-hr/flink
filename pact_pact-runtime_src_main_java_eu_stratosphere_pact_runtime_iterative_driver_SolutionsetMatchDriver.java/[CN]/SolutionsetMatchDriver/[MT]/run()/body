{
  final GenericMatcher<IT1,IT2,OT> matchStub=taskContext.getStub();
  final UpdateSolutionsetOutputCollector<OT> collector=this.collector;
  final MutableObjectIterator<IT1> probeSide=taskContext.getInput(PROBESIDE_INDEX);
  final MutableObjectIterator<IT2> buildSide=taskContext.getInput(BUILDSIDE_INDEX);
  final MutableHashTable<IT2,IT1> hashJoin=Preconditions.checkNotNull(this.hashJoin);
  if (firstIteration) {
    hashJoin.open(buildSide,EmptyMutableObjectIterator.<IT1>get());
  }
  final IT1 probeSideRecord=taskContext.<IT1>getInputSerializer(PROBESIDE_INDEX).createInstance();
  final IT2 buildSideRecord=taskContext.<IT2>getInputSerializer(BUILDSIDE_INDEX).createInstance();
  Aggregator<PactLong> updatedElements=new SolutionsetEmptyConvergenceCriterion().createAggregator();
  long possibleUpdates=0;
  while (running && probeSide.next(probeSideRecord)) {
    MutableHashTable.HashBucketIterator<IT2,IT1> bucket=hashJoin.getMatchesFor(probeSideRecord);
    boolean matched=bucket.next(buildSideRecord);
    if (!matched) {
      throw new IllegalStateException("Unknown record supplied to solutionset");
    }
    collector.setHashBucket(bucket);
    matchStub.match(probeSideRecord,buildSideRecord,collector);
    possibleUpdates++;
  }
  long numUpdatedElements=collector.getNumUpdatedElementsAndReset();
  int workerIndex=taskContext.getOwningNepheleTask().getIndexInSubtaskGroup();
  if (log.isInfoEnabled()) {
    log.info("[" + numUpdatedElements + "] elements updated in the solutionset partition of worker "+ "["+ workerIndex+ "], possible updates ["+ possibleUpdates+ "]");
  }
  updatedElements.aggregate(new PactLong(numUpdatedElements));
  IterationContext.instance().setAggregate(workerIndex,updatedElements.getAggregate());
  updatedElements.reset();
}
