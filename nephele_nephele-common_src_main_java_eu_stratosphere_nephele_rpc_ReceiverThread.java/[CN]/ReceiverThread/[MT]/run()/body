{
  final Kryo kryo=RPCService.createKryoObject();
  byte[] buf=new byte[RPCMessage.MAXIMUM_MSG_SIZE + RPCMessage.METADATA_SIZE];
  DatagramPacket dp=new DatagramPacket(buf,buf.length);
  while (!this.shutdownRequested) {
    try {
      this.socket.receive(dp);
    }
 catch (    SocketException se) {
      if (this.shutdownRequested) {
        return;
      }
      Log.error("Shutting down receiver thread due to error: ",se);
      return;
    }
catch (    IOException ioe) {
      Log.error("Shutting down receiver thread due to error: ",ioe);
      return;
    }
    final InetSocketAddress remoteSocketAddress=(InetSocketAddress)dp.getSocketAddress();
    final int length=dp.getLength() - RPCMessage.METADATA_SIZE;
    final byte[] dbbuf=dp.getData();
    final short numberOfPackets=byteArrayToShort(dbbuf,length + 2);
    Input input=null;
    if (numberOfPackets == 1) {
      final SinglePacketInputStream spis=new SinglePacketInputStream(dbbuf,length);
      input=new Input(spis);
    }
 else {
      final MultiPacketInputStream mpis=this.rpcService.getIncompleteInputStream(remoteSocketAddress,0,numberOfPackets);
      mpis.addPacket(byteArrayToShort(dbbuf,length),dp);
      if (!mpis.isComplete()) {
        buf=new byte[RPCMessage.MAXIMUM_MSG_SIZE + RPCMessage.METADATA_SIZE];
        dp=new DatagramPacket(buf,buf.length);
        continue;
      }
      this.rpcService.removeIncompleteInputStream(remoteSocketAddress,0);
      input=new Input(mpis);
    }
    final RPCEnvelope envelope=kryo.readObject(input,RPCEnvelope.class);
    final RPCMessage msg=envelope.getRPCMessage();
    if (msg instanceof RPCRequest) {
      while (true) {
        try {
          this.rpcService.processIncomingRPCRequest(remoteSocketAddress,(RPCRequest)msg);
          break;
        }
 catch (        InterruptedException e) {
          if (this.shutdownRequested) {
            return;
          }
 else {
            continue;
          }
        }
      }
    }
 else     if (msg instanceof RPCResponse) {
      this.rpcService.processIncomingRPCResponse(remoteSocketAddress,(RPCResponse)msg);
    }
 else {
      this.rpcService.processIncomingRPCCleanup(remoteSocketAddress,(RPCCleanup)msg);
    }
  }
}
