{
  final Kryo kryo=RPCService.createKryoObject();
  final byte[] buf=new byte[RPCMessage.MAXIMUM_MSG_SIZE];
  final DatagramPacket dp=new DatagramPacket(buf,buf.length);
  while (!this.shutdownRequested) {
    try {
      this.socket.receive(dp);
    }
 catch (    SocketException se) {
      if (this.shutdownRequested) {
        return;
      }
      Log.error("Shutting down receiver thread due to error: ",se);
      return;
    }
catch (    IOException ioe) {
      Log.error("Shutting down receiver thread due to error: ",ioe);
      return;
    }
    final InetSocketAddress remoteSocketAddress=(InetSocketAddress)dp.getSocketAddress();
    final MemoryBackedInputStream mbis=new MemoryBackedInputStream(dp.getData(),dp.getOffset(),dp.getLength());
    final Input input=new Input(mbis);
    final RPCEnvelope envelope=kryo.readObject(input,RPCEnvelope.class);
    final RPCMessage msg=envelope.getRPCMessage();
    if (msg instanceof RPCRequest) {
      while (true) {
        try {
          this.rpcService.processIncomingRPCRequest(remoteSocketAddress,(RPCRequest)msg);
          break;
        }
 catch (        InterruptedException e) {
          if (this.shutdownRequested) {
            return;
          }
 else {
            continue;
          }
        }
      }
    }
 else     if (msg instanceof RPCResponse) {
      this.rpcService.processIncomingRPCResponse(remoteSocketAddress,(RPCResponse)msg);
    }
 else {
      this.rpcService.processIncomingRPCCleanup(remoteSocketAddress,(RPCCleanup)msg);
    }
  }
}
