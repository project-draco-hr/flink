{
  if (this.path == null) {
    throw new IllegalConfigurationException("Cannot generate input splits, path is not set");
  }
  final int numSubtasks=getNumberOfSubtasks();
  final List<FileInputSplit> inputSplits=new ArrayList<FileInputSplit>();
  List<FileStatus> files=new ArrayList<FileStatus>();
  long totalLength=0;
  try {
    final FileSystem fs=this.path.getFileSystem();
    final FileStatus pathFile=fs.getFileStatus(this.path);
    if (pathFile.isDir()) {
      final FileStatus[] dir=fs.listStatus(this.path);
      for (int i=0; i < dir.length; i++) {
        if (!dir[i].isDir()) {
          files.add(dir[i]);
          totalLength+=dir[i].getLen();
        }
      }
    }
 else {
      files.add(pathFile);
      totalLength+=pathFile.getLen();
    }
    final long minSplitSize=1;
    final long maxSplitSize=(numSubtasks < 1) ? Long.MAX_VALUE : (totalLength / numSubtasks + (totalLength % numSubtasks == 0 ? 0 : 1));
    for (    FileStatus file : files) {
      final long len=file.getLen();
      final long blockSize=file.getBlockSize();
      final long splitSize=Math.max(minSplitSize,Math.min(maxSplitSize,blockSize));
      final long halfSplit=splitSize >>> 1;
      final long maxBytesForLastSplit=(long)(splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
      if (len > 0) {
        final BlockLocation[] blocks=fs.getFileBlockLocations(file,0,len);
        Arrays.sort(blocks);
        long bytesUnassigned=len;
        long position=0;
        int blockIndex=0;
        while (bytesUnassigned > maxBytesForLastSplit) {
          blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
          FileInputSplit fis=new FileInputSplit(file.getPath(),position,splitSize,blocks[blockIndex].getHosts());
          inputSplits.add(fis);
          position+=splitSize;
          bytesUnassigned-=splitSize;
        }
        if (bytesUnassigned > 0) {
          blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
          final FileInputSplit fis=new FileInputSplit(file.getPath(),position,bytesUnassigned,blocks[blockIndex].getHosts());
          inputSplits.add(fis);
        }
      }
 else {
        final BlockLocation[] blocks=fs.getFileBlockLocations(file,0,0);
        final FileInputSplit fis=new FileInputSplit(file.getPath(),0,0,blocks[0].getHosts());
        inputSplits.add(fis);
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalConfigurationException("Cannot generate input splits from path '" + this.path.toString() + "': "+ StringUtils.stringifyException(ioe));
  }
  return inputSplits.toArray(new InputSplit[inputSplits.size()]);
}
