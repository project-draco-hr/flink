{
  if (args == null || args.length != 4) {
    LOG.warn("number of arguments do not match!");
    this.ordersInputPath="";
    this.lineItemInputPath="";
    this.outputPath="";
  }
 else {
    setArgs(args);
  }
  FileDataSource orders=new FileDataSource(new IntTupleDataInFormat(),this.ordersInputPath,"Orders");
  orders.setDegreeOfParallelism(this.degreeOfParallelism);
  FileDataSource lineItems=new FileDataSource(new IntTupleDataInFormat(),this.lineItemInputPath,"LineItems");
  lineItems.setDegreeOfParallelism(this.degreeOfParallelism);
  FileDataSink result=new FileDataSink(new StringTupleDataOutFormat(),this.outputPath,"Output");
  result.setDegreeOfParallelism(degreeOfParallelism);
  MapOperator lineFilter=MapOperator.builder(LiFilter.class).name("LineItemFilter").build();
  lineFilter.setDegreeOfParallelism(degreeOfParallelism);
  MapOperator ordersFilter=MapOperator.builder(OFilter.class).name("OrdersFilter").build();
  ordersFilter.setDegreeOfParallelism(degreeOfParallelism);
  JoinOperator join=JoinOperator.builder(JoinLiO.class,IntValue.class,0,0).name("OrdersLineitemsJoin").build();
  join.setDegreeOfParallelism(degreeOfParallelism);
  ReduceOperator aggregation=ReduceOperator.builder(CountAgg.class,StringValue.class,0).name("AggregateGroupBy").build();
  aggregation.setDegreeOfParallelism(this.degreeOfParallelism);
  lineFilter.setInput(lineItems);
  ordersFilter.setInput(orders);
  join.setFirstInput(ordersFilter);
  join.setSecondInput(lineFilter);
  aggregation.setInput(join);
  result.setInput(aggregation);
  return new Plan(result,"TPC-H 4");
}
