{
  if (LOG.isDebugEnabled())   LOG.debug(getLogString("Starting data sink operator"));
  try {
switch (this.config.getInputLocalStrategy(0)) {
case NONE:
      localStrategy=null;
    input=reader;
  break;
case SORT:
try {
  TypeComparatorFactory<IT> compFact=this.config.getInputComparator(0,this.userCodeClassLoader);
  if (compFact == null) {
    throw new Exception("Missing comparator factory for local strategy on input " + 0);
  }
  UnilateralSortMerger<IT> sorter=new UnilateralSortMerger<IT>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),this.reader,this,this.inputTypeSerializerFactory,compFact.createComparator(),this.config.getMemoryInput(0),this.config.getFilehandlesInput(0),this.config.getSpillingThresholdInput(0));
  this.localStrategy=sorter;
  this.input=sorter.getIterator();
}
 catch (Exception e) {
  throw new RuntimeException("Initializing the input processing failed" + e.getMessage() == null ? "." : ": " + e.getMessage(),e);
}
break;
default :
throw new RuntimeException("Invalid local strategy for DataSinkTask");
}
final TypeSerializer<IT> serializer=this.inputTypeSerializerFactory.getSerializer();
final MutableObjectIterator<IT> input=this.input;
final OutputFormat<IT> format=this.format;
IT record=serializer.createInstance();
if (this.taskCanceled) {
return;
}
if (LOG.isDebugEnabled()) {
LOG.debug(getLogString("Starting to produce output"));
}
format.open(this.getEnvironment().getIndexInSubtaskGroup(),this.getEnvironment().getCurrentNumberOfSubtasks());
while (!this.taskCanceled && ((record=input.next(record)) != null)) {
format.writeRecord(record);
}
if (!this.taskCanceled) {
this.format.close();
this.format=null;
}
}
 catch (Exception ex) {
if (!this.taskCanceled) {
if (LOG.isErrorEnabled()) LOG.error(getLogString("Error in Pact user code: " + ex.getMessage()),ex);
throw ex;
}
}
 finally {
if (this.format != null) {
try {
this.format.close();
}
 catch (Throwable t) {
if (LOG.isWarnEnabled()) LOG.warn(getLogString("Error closing the ouput format."),t);
}
}
if (localStrategy != null) {
try {
this.localStrategy.close();
}
 catch (Throwable t) {
LOG.error("Error closing local strategy",t);
}
}
}
if (!this.taskCanceled) {
if (LOG.isDebugEnabled()) {
LOG.debug(getLogString("Finished data sink operator"));
}
}
 else {
if (LOG.isDebugEnabled()) LOG.debug(getLogString("Data sink operator cancelled"));
}
}
