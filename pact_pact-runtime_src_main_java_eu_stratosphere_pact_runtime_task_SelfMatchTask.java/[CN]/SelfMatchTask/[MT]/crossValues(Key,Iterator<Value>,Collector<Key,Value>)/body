{
  final Value[] valBuffer=new Value[VALUE_BUFFER_SIZE];
  this.keyCopier.setCopy(key);
  Key copyKey;
  Value outerVal;
  Value innerVal;
  int bufferValCnt;
  for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
    if (values.hasNext()) {
      valBuffer[bufferValCnt]=values.next();
    }
 else {
      break;
    }
  }
  for (int i=0; i < bufferValCnt; i++) {
    this.outerValCopier.setCopy(valBuffer[i]);
    for (int j=0; j < bufferValCnt; j++) {
      this.innerValCopier.setCopy(valBuffer[j]);
      copyKey=keySerialization.newInstance();
      this.keyCopier.getCopy(copyKey);
      outerVal=valSerialization.newInstance();
      this.outerValCopier.getCopy(outerVal);
      innerVal=valSerialization.newInstance();
      this.innerValCopier.getCopy(innerVal);
      stub.match(copyKey,outerVal,innerVal,out);
    }
  }
  if (values.hasNext()) {
    Reader<Value> valReader=new Reader<Value>(){
      int bufferIdx=0;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (taskCanceled)         return false;
        if (bufferIdx < VALUE_BUFFER_SIZE)         return true;
        return values.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (bufferIdx < VALUE_BUFFER_SIZE) {
          return valBuffer[bufferIdx++];
        }
 else {
          Value nextVal=values.next();
          Key copyKey;
          Value outerVal;
          Value innerVal;
          outerValCopier.setCopy(nextVal);
          for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
            innerValCopier.setCopy(valBuffer[i]);
            copyKey=keySerialization.newInstance();
            keyCopier.getCopy(copyKey);
            outerVal=valSerialization.newInstance();
            outerValCopier.getCopy(outerVal);
            innerVal=valSerialization.newInstance();
            innerValCopier.getCopy(innerVal);
            stub.match(copyKey,outerVal,innerVal,out);
          }
          return nextVal;
        }
      }
    }
;
    SpillingResettableIterator<Value> innerValResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(stub.getFirstInValueType());
      innerValResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),valReader,(long)(this.availableMemory * (MEMORY_SHARE_RATIO / 2)),v1Deserializer,this);
      innerValResettableIterator.open();
      long readCnt=VALUE_BUFFER_SIZE;
      long cnt=0;
      while (!this.taskCanceled && cnt < readCnt && innerValResettableIterator.hasNext()) {
        innerValResettableIterator.next();
        cnt++;
      }
      while (!this.taskCanceled && innerValResettableIterator.hasNext()) {
        for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
          if (!innerValResettableIterator.hasNext()) {
            break;
          }
          valBuffer[bufferValCnt]=innerValResettableIterator.next();
        }
        readCnt+=bufferValCnt;
        innerValResettableIterator.reset();
        while (!this.taskCanceled && innerValResettableIterator.hasNext()) {
          outerValCopier.setCopy(innerValResettableIterator.next());
          for (int i=0; i < bufferValCnt; i++) {
            innerValCopier.setCopy(valBuffer[i]);
            copyKey=keySerialization.newInstance();
            keyCopier.getCopy(copyKey);
            outerVal=valSerialization.newInstance();
            outerValCopier.getCopy(outerVal);
            innerVal=valSerialization.newInstance();
            innerValCopier.getCopy(innerVal);
            stub.match(copyKey,outerVal,innerVal,out);
          }
        }
        innerValResettableIterator.reset();
        cnt=0;
        while (!this.taskCanceled && cnt < readCnt && innerValResettableIterator.hasNext()) {
          innerValResettableIterator.next();
          cnt++;
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (innerValResettableIterator != null) {
        innerValResettableIterator.close();
      }
    }
  }
}
