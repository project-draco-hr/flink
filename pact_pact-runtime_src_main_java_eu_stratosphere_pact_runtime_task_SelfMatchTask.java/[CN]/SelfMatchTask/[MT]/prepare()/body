{
  availableMemory=this.config.getMemorySize();
  final int maxFileHandles=this.config.getNumFilehandles();
  final float spillThreshold=this.config.getSortSpillingTreshold();
  final LocalStrategy ls=this.config.getLocalStrategy();
  long strategyMinMem=0;
  String crossModeS=this.config.getStubParameter(SELFMATCH_CROSS_MODE_KEY,null);
  if (crossModeS == null) {
    this.crossMode=CrossMode.FULL_CROSS;
  }
 else   if (crossModeS.equals(CrossMode.FULL_CROSS.toString())) {
    this.crossMode=CrossMode.FULL_CROSS;
  }
 else   if (crossModeS.equals(CrossMode.TRIANGLE_CROSS_INCL_DIAG.toString())) {
    this.crossMode=CrossMode.TRIANGLE_CROSS_INCL_DIAG;
  }
 else   if (crossModeS.equals(CrossMode.TRIANGLE_CROSS_EXCL_DIAG.toString())) {
    this.crossMode=CrossMode.TRIANGLE_CROSS_EXCL_DIAG;
  }
 else {
    throw new IllegalArgumentException("Invalid Cross Mode: " + crossModeS);
  }
switch (ls) {
case SORT_SELF_NESTEDLOOP:
    strategyMinMem=MIN_REQUIRED_MEMORY * 2;
  break;
case SELF_NESTEDLOOP:
strategyMinMem=MIN_REQUIRED_MEMORY;
break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException("The SelfMatch task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ strategyMinMem+ " bytes.");
}
final MemoryManager memoryManager=getEnvironment().getMemoryManager();
final IOManager ioManager=getEnvironment().getIOManager();
final MutableObjectIterator<IT> in=getInput(0);
this.serializer=getInputSerializer(0);
this.comparator=getInputComparator(0);
switch (ls) {
case SELF_NESTEDLOOP:
this.closeableInput=new SimpleCloseableInputProvider<IT>(in);
break;
case SORT_SELF_NESTEDLOOP:
this.closeableInput=new UnilateralSortMerger<IT>(memoryManager,ioManager,in,this,this.serializer,this.comparator.duplicate(),availableMemory,maxFileHandles,spillThreshold);
break;
default :
throw new RuntimeException("Invalid local strategy provided for SelfMatchTask: " + config.getLocalStrategy());
}
}
