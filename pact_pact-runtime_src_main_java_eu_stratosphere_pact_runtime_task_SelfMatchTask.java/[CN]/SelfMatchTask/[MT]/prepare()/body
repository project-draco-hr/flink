{
  availableMemory=this.config.getMemorySize();
  final int maxFileHandles=this.config.getNumFilehandles();
  final float spillThreshold=this.config.getSortSpillingTreshold();
  final LocalStrategy ls=this.config.getLocalStrategy();
  long strategyMinMem=0;
  String crossModeS=this.config.getStubParameter(SELFMATCH_CROSS_MODE_KEY,null);
  if (crossModeS == null) {
    this.crossMode=CrossMode.FULL_CROSS;
  }
 else   if (crossModeS.equals(CrossMode.FULL_CROSS.toString())) {
    this.crossMode=CrossMode.FULL_CROSS;
  }
 else   if (crossModeS.equals(CrossMode.TRIANGLE_CROSS_INCL_DIAG.toString())) {
    this.crossMode=CrossMode.TRIANGLE_CROSS_INCL_DIAG;
  }
 else   if (crossModeS.equals(CrossMode.TRIANGLE_CROSS_EXCL_DIAG.toString())) {
    this.crossMode=CrossMode.TRIANGLE_CROSS_EXCL_DIAG;
  }
 else {
    throw new IllegalArgumentException("Invalid Cross Mode: " + crossModeS);
  }
switch (ls) {
case SORT_SELF_NESTEDLOOP:
    strategyMinMem=MIN_REQUIRED_MEMORY * 2;
  break;
case SELF_NESTEDLOOP:
strategyMinMem=MIN_REQUIRED_MEMORY;
break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException("The SelfMatch task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ strategyMinMem+ " bytes.");
}
memoryManager=getEnvironment().getMemoryManager();
ioManager=getEnvironment().getIOManager();
keyPositions=this.config.getLocalStrategyKeyPositions(0);
keyClasses=this.config.getLocalStrategyKeyClasses(this.userCodeClassLoader);
if (keyPositions == null || keyClasses == null) {
throw new Exception("The key positions and types are not specified for the SelfMatchTask.");
}
if (keyPositions.length != keyClasses.length) {
throw new Exception("The number of key positions and types does not match in the configuration");
}
final Comparator<Key>[] comparators=new Comparator[keyPositions.length];
final KeyComparator kk=new KeyComparator();
for (int i=0; i < comparators.length; i++) {
comparators[i]=kk;
}
switch (ls) {
case SELF_NESTEDLOOP:
closeableInput=new SimpleCloseableInputProvider<PactRecord>(inputs[0]);
break;
case SORT_SELF_NESTEDLOOP:
closeableInput=new UnilateralSortMerger(memoryManager,ioManager,(long)(availableMemory * (1.0 - MEMORY_SHARE_RATIO)),maxFileHandles,comparators,keyPositions,keyClasses,inputs[0],this,spillThreshold);
break;
default :
throw new RuntimeException("Invalid local strategy provided for SelfMatchTask: " + config.getLocalStrategy());
}
}
