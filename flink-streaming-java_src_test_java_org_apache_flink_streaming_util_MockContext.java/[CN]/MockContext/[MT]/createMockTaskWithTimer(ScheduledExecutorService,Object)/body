{
  StreamTask<?,?> task=mock(StreamTask.class);
  when(task.getAccumulatorMap()).thenReturn(new HashMap<String,Accumulator<?,?>>());
  when(task.getName()).thenReturn("Test task name");
  when(task.getExecutionConfig()).thenReturn(new ExecutionConfig());
  when(task.getEnvironment()).thenReturn(new MockEnvironment("MockTask",3 * 1024 * 1024,new MockInputSplitProvider(),1024));
  when(task.getCheckpointLock()).thenReturn(lock);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocationOnMock) throws Throwable {
      final Long timestamp=(Long)invocationOnMock.getArguments()[0];
      final Triggerable target=(Triggerable)invocationOnMock.getArguments()[1];
      timerService.schedule(new Callable<Object>(){
        @Override public Object call() throws Exception {
synchronized (lock) {
            target.trigger(timestamp);
          }
          return null;
        }
      }
,timestamp - System.currentTimeMillis(),TimeUnit.MILLISECONDS);
      return null;
    }
  }
).when(task).registerTimer(anyLong(),any(Triggerable.class));
  @SuppressWarnings("unchecked") OngoingStubbing<StateBackend<?>> stubbing=(OngoingStubbing<StateBackend<?>>)(OngoingStubbing<?>)when(task.getStateBackend());
  stubbing.thenReturn(MemoryStateBackend.defaultInstance());
  return task;
}
