{
  StreamTask<?,?> task=mock(StreamTask.class);
  when(task.getAccumulatorMap()).thenReturn(new HashMap<String,Accumulator<?,?>>());
  when(task.getName()).thenReturn("Test task name");
  when(task.getExecutionConfig()).thenReturn(new ExecutionConfig());
  when(task.getEnvironment()).thenReturn(new MockEnvironment("MockTask",3 * 1024 * 1024,new MockInputSplitProvider(),1024));
  when(task.getCheckpointLock()).thenReturn(lock);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocationOnMock) throws Throwable {
      final Long timestamp=(Long)invocationOnMock.getArguments()[0];
      final Triggerable target=(Triggerable)invocationOnMock.getArguments()[1];
      timerService.schedule(new Callable<Object>(){
        @Override public Object call() throws Exception {
synchronized (lock) {
            target.trigger(timestamp);
          }
          return null;
        }
      }
,timestamp - System.currentTimeMillis(),TimeUnit.MILLISECONDS);
      return null;
    }
  }
).when(task).registerTimer(anyLong(),any(Triggerable.class));
  try {
    doAnswer(new Answer<AbstractStateBackend>(){
      @Override public AbstractStateBackend answer(      InvocationOnMock invocationOnMock) throws Throwable {
        final String operatorIdentifier=(String)invocationOnMock.getArguments()[0];
        final TypeSerializer<?> keySerializer=(TypeSerializer<?>)invocationOnMock.getArguments()[1];
        MemoryStateBackend backend=MemoryStateBackend.create();
        backend.initializeForJob(new DummyEnvironment("dummty",1,0),operatorIdentifier,keySerializer);
        return backend;
      }
    }
).when(task).createStateBackend(any(String.class),any(TypeSerializer.class));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return task;
}
