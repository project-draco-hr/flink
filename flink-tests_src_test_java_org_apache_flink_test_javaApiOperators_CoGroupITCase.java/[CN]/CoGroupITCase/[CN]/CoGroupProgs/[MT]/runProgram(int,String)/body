{
switch (progId) {
case 1:
{
      final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds=CollectionDataSets.get5TupleDataSet(env);
      DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds2=CollectionDataSets.get5TupleDataSet(env);
      DataSet<Tuple2<Integer,Integer>> coGroupDs=ds.coGroup(ds2).where(0).equalTo(0).with(new Tuple5CoGroup());
      coGroupDs.writeAsCsv(resultPath);
      env.execute();
      return "1,0\n" + "2,6\n" + "3,24\n"+ "4,60\n"+ "5,120\n";
    }
case 2:
{
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    DataSet<CustomType> ds=CollectionDataSets.getCustomTypeDataSet(env);
    DataSet<CustomType> ds2=CollectionDataSets.getCustomTypeDataSet(env);
    DataSet<CustomType> coGroupDs=ds.coGroup(ds2).where(new KeySelector<CustomType,Integer>(){
      private static final long serialVersionUID=1L;
      @Override public Integer getKey(      CustomType in){
        return in.myInt;
      }
    }
).equalTo(new KeySelector<CustomType,Integer>(){
      private static final long serialVersionUID=1L;
      @Override public Integer getKey(      CustomType in){
        return in.myInt;
      }
    }
).with(new CustomTypeCoGroup());
    coGroupDs.writeAsText(resultPath);
    env.execute();
    return "1,0,test\n" + "2,6,test\n" + "3,24,test\n"+ "4,60,test\n"+ "5,120,test\n"+ "6,210,test\n";
  }
case 3:
{
  final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  DataSet<Tuple3<Integer,Long,String>> ds=CollectionDataSets.get3TupleDataSet(env);
  DataSet<Tuple3<Integer,Long,String>> ds2=CollectionDataSets.get3TupleDataSet(env);
  DataSet<Tuple3<Integer,Long,String>> coGroupDs=ds.coGroup(ds2).where(0).equalTo(0).with(new Tuple3ReturnLeft());
  coGroupDs.writeAsCsv(resultPath);
  env.execute();
  return "1,1,Hi\n" + "2,2,Hello\n" + "3,2,Hello world\n"+ "4,3,Hello world, how are you?\n"+ "5,3,I am fine.\n";
}
case 4:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds=CollectionDataSets.get5TupleDataSet(env);
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds2=CollectionDataSets.get5TupleDataSet(env);
DataSet<Tuple5<Integer,Long,Integer,String,Long>> coGroupDs=ds.coGroup(ds2).where(0).equalTo(0).with(new Tuple5ReturnRight());
coGroupDs.writeAsCsv(resultPath);
env.execute();
return "1,1,0,Hallo,1\n" + "2,2,1,Hallo Welt,2\n" + "2,3,2,Hallo Welt wie,1\n"+ "3,4,3,Hallo Welt wie gehts?,2\n"+ "3,5,4,ABC,2\n"+ "3,6,5,BCD,3\n";
}
case 5:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<Integer> intDs=CollectionDataSets.getIntegerDataSet(env);
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds=CollectionDataSets.get5TupleDataSet(env);
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds2=CollectionDataSets.get5TupleDataSet(env);
DataSet<Tuple3<Integer,Integer,Integer>> coGroupDs=ds.coGroup(ds2).where(0).equalTo(0).with(new Tuple5CoGroupBC()).withBroadcastSet(intDs,"ints");
coGroupDs.writeAsCsv(resultPath);
env.execute();
return "1,0,55\n" + "2,6,55\n" + "3,24,55\n"+ "4,60,55\n"+ "5,120,55\n";
}
case 6:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds=CollectionDataSets.get5TupleDataSet(env);
DataSet<CustomType> ds2=CollectionDataSets.getCustomTypeDataSet(env);
DataSet<Tuple3<Integer,Long,String>> coGroupDs=ds.coGroup(ds2).where(2).equalTo(new KeySelector<CustomType,Integer>(){
private static final long serialVersionUID=1L;
@Override public Integer getKey(CustomType in){
return in.myInt;
}
}
).with(new MixedCoGroup());
coGroupDs.writeAsCsv(resultPath);
env.execute();
return "0,1,test\n" + "1,2,test\n" + "2,5,test\n"+ "3,15,test\n"+ "4,33,test\n"+ "5,63,test\n"+ "6,109,test\n"+ "7,4,test\n"+ "8,4,test\n"+ "9,4,test\n"+ "10,5,test\n"+ "11,5,test\n"+ "12,5,test\n"+ "13,5,test\n"+ "14,5,test\n";
}
case 7:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds=CollectionDataSets.get5TupleDataSet(env);
DataSet<CustomType> ds2=CollectionDataSets.getCustomTypeDataSet(env);
DataSet<CustomType> coGroupDs=ds2.coGroup(ds).where(new KeySelector<CustomType,Integer>(){
private static final long serialVersionUID=1L;
@Override public Integer getKey(CustomType in){
return in.myInt;
}
}
).equalTo(2).with(new MixedCoGroup2());
coGroupDs.writeAsText(resultPath);
env.execute();
return "0,1,test\n" + "1,2,test\n" + "2,5,test\n"+ "3,15,test\n"+ "4,33,test\n"+ "5,63,test\n"+ "6,109,test\n"+ "7,4,test\n"+ "8,4,test\n"+ "9,4,test\n"+ "10,5,test\n"+ "11,5,test\n"+ "12,5,test\n"+ "13,5,test\n"+ "14,5,test\n";
}
case 8:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds1=CollectionDataSets.get5TupleDataSet(env);
DataSet<Tuple3<Integer,Long,String>> ds2=CollectionDataSets.get3TupleDataSet(env);
DataSet<Tuple3<Integer,Long,String>> coGrouped=ds1.coGroup(ds2).where(0,4).equalTo(0,1).with(new Tuple5Tuple3CoGroup());
coGrouped.writeAsCsv(resultPath);
env.execute();
return "1,1,Hallo\n" + "2,2,Hallo Welt\n" + "3,2,Hallo Welt wie gehts?\n"+ "3,2,ABC\n"+ "5,3,HIJ\n"+ "5,3,IJK\n";
}
case 9:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<Tuple5<Integer,Long,Integer,String,Long>> ds1=CollectionDataSets.get5TupleDataSet(env);
DataSet<Tuple3<Integer,Long,String>> ds2=CollectionDataSets.get3TupleDataSet(env);
DataSet<Tuple3<Integer,Long,String>> coGrouped=ds1.coGroup(ds2).where(new KeySelector<Tuple5<Integer,Long,Integer,String,Long>,Tuple2<Integer,Long>>(){
private static final long serialVersionUID=1L;
@Override public Tuple2<Integer,Long> getKey(Tuple5<Integer,Long,Integer,String,Long> t){
return new Tuple2<Integer,Long>(t.f0,t.f4);
}
}
).equalTo(new KeySelector<Tuple3<Integer,Long,String>,Tuple2<Integer,Long>>(){
private static final long serialVersionUID=1L;
@Override public Tuple2<Integer,Long> getKey(Tuple3<Integer,Long,String> t){
return new Tuple2<Integer,Long>(t.f0,t.f1);
}
}
).with(new Tuple5Tuple3CoGroup());
coGrouped.writeAsCsv(resultPath);
env.execute();
return "1,1,Hallo\n" + "2,2,Hallo Welt\n" + "3,2,Hallo Welt wie gehts?\n"+ "3,2,ABC\n"+ "5,3,HIJ\n"+ "5,3,IJK\n";
}
case 10:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<CustomType> ds=CollectionDataSets.getCustomTypeDataSet(env);
DataSet<CustomType> ds2=CollectionDataSets.getCustomTypeDataSet(env);
DataSet<CustomType> coGroupDs=ds.coGroup(ds2).where("myInt").equalTo("myInt").with(new CustomTypeCoGroup());
coGroupDs.writeAsText(resultPath);
env.execute();
return "1,0,test\n" + "2,6,test\n" + "3,24,test\n"+ "4,60,test\n"+ "5,120,test\n"+ "6,210,test\n";
}
case 11:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<POJO> ds=CollectionDataSets.getSmallPojoDataSet(env);
DataSet<Tuple7<Integer,String,Integer,Integer,Long,String,Long>> ds2=CollectionDataSets.getSmallTuplebasedDataSet(env);
DataSet<CustomType> coGroupDs=ds.coGroup(ds2).where("nestedPojo.longNumber").equalTo(6).with(new CoGroupFunction<POJO,Tuple7<Integer,String,Integer,Integer,Long,String,Long>,CustomType>(){
private static final long serialVersionUID=1L;
@Override public void coGroup(Iterable<POJO> first,Iterable<Tuple7<Integer,String,Integer,Integer,Long,String,Long>> second,Collector<CustomType> out) throws Exception {
for (POJO p : first) {
for (Tuple7<Integer,String,Integer,Integer,Long,String,Long> t : second) {
Assert.assertTrue(p.nestedPojo.longNumber == t.f6);
out.collect(new CustomType(-1,p.nestedPojo.longNumber,"Flink"));
}
}
}
}
);
coGroupDs.writeAsText(resultPath);
env.execute();
return "-1,20000,Flink\n" + "-1,10000,Flink\n" + "-1,30000,Flink\n";
}
case 12:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<POJO> ds=CollectionDataSets.getSmallPojoDataSet(env);
DataSet<Tuple7<Integer,String,Integer,Integer,Long,String,Long>> ds2=CollectionDataSets.getSmallTuplebasedDataSet(env);
DataSet<CustomType> coGroupDs=ds.coGroup(ds2).where(new KeySelector<POJO,Tuple1<Long>>(){
private static final long serialVersionUID=1L;
@Override public Tuple1<Long> getKey(POJO value) throws Exception {
return new Tuple1<Long>(value.nestedPojo.longNumber);
}
}
).equalTo(6).with(new CoGroupFunction<POJO,Tuple7<Integer,String,Integer,Integer,Long,String,Long>,CustomType>(){
private static final long serialVersionUID=1L;
@Override public void coGroup(Iterable<POJO> first,Iterable<Tuple7<Integer,String,Integer,Integer,Long,String,Long>> second,Collector<CustomType> out) throws Exception {
for (POJO p : first) {
for (Tuple7<Integer,String,Integer,Integer,Long,String,Long> t : second) {
Assert.assertTrue(p.nestedPojo.longNumber == t.f6);
out.collect(new CustomType(-1,p.nestedPojo.longNumber,"Flink"));
}
}
}
}
);
coGroupDs.writeAsText(resultPath);
env.execute();
return "-1,20000,Flink\n" + "-1,10000,Flink\n" + "-1,30000,Flink\n";
}
case 13:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
DataSet<POJO> ds=CollectionDataSets.getSmallPojoDataSet(env);
DataSet<Tuple7<Integer,String,Integer,Integer,Long,String,Long>> ds2=CollectionDataSets.getSmallTuplebasedDataSet(env);
DataSet<CustomType> coGroupDs=ds.coGroup(ds2).where(new KeySelector<POJO,Long>(){
private static final long serialVersionUID=1L;
@Override public Long getKey(POJO value) throws Exception {
return value.nestedPojo.longNumber;
}
}
).equalTo(6).with(new CoGroupFunction<POJO,Tuple7<Integer,String,Integer,Integer,Long,String,Long>,CustomType>(){
private static final long serialVersionUID=1L;
@Override public void coGroup(Iterable<POJO> first,Iterable<Tuple7<Integer,String,Integer,Integer,Long,String,Long>> second,Collector<CustomType> out) throws Exception {
for (POJO p : first) {
for (Tuple7<Integer,String,Integer,Integer,Long,String,Long> t : second) {
Assert.assertTrue(p.nestedPojo.longNumber == t.f6);
out.collect(new CustomType(-1,p.nestedPojo.longNumber,"Flink"));
}
}
}
}
);
coGroupDs.writeAsText(resultPath);
env.execute();
return "-1,20000,Flink\n" + "-1,10000,Flink\n" + "-1,30000,Flink\n";
}
default :
throw new IllegalArgumentException("Invalid program id");
}
}
