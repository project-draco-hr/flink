{
  byte[] operatorBytes=taskConfiguration.getBytes("operator",null);
  String operatorName=taskConfiguration.getString("operatorName","");
  try {
    ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(operatorBytes));
    Object function=in.readObject();
    if (operatorName.equals("flatMap")) {
      setSerializer(function,FlatMapFunction.class);
    }
 else     if (operatorName.equals("map")) {
      setSerializer(function,MapFunction.class);
    }
 else     if (operatorName.equals("batchReduce")) {
      setSerializer(function,GroupReduceFunction.class);
    }
 else     if (operatorName.equals("filter")) {
      setSerializer(function,FilterFunction.class);
    }
 else     if (operatorName.equals("sink")) {
      inTupleTypeInfo=(TupleTypeInfo)TypeExtractor.createTypeInfo(SinkFunction.class,function.getClass(),0,null,null);
      inTupleSerializer=inTupleTypeInfo.createSerializer();
      inDeserializationDelegate=new DeserializationDelegate<Tuple>(inTupleSerializer);
    }
 else     if (operatorName.equals("source")) {
      outTupleTypeInfo=(TupleTypeInfo)TypeExtractor.createTypeInfo(UserSourceInvokable.class,function.getClass(),0,null,null);
      outTupleSerializer=outTupleTypeInfo.createSerializer();
      outSerializationDelegate=new SerializationDelegate<Tuple>(outTupleSerializer);
    }
 else {
      throw new Exception("Wrong operator name!");
    }
  }
 catch (  Exception e) {
    throw new StreamComponentException("Nonsupported object passed as operator");
  }
}
