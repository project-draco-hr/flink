{
  if (taskBase instanceof StreamSource) {
    byte[] bytes=taskConfiguration.getBytes("operator",null);
    ObjectInputStream in;
    try {
      in=new ObjectInputStream(new ByteArrayInputStream(bytes));
      UserSourceInvokable<Tuple> f=(UserSourceInvokable<Tuple>)in.readObject();
      outTupleTypeInfo=(TupleTypeInfo)TypeExtractor.createTypeInfo(UserSourceInvokable.class,f.getClass(),0,null,null);
      outTupleSerializer=outTupleTypeInfo.createSerializer();
      outSerializationDelegate=new SerializationDelegate<Tuple>(outTupleSerializer);
      collector=new StreamCollector<Tuple>(1,1,outSerializationDelegate);
    }
 catch (    Exception e) {
    }
  }
  int numberOfOutputs=taskConfiguration.getInteger("numberOfOutputs",0);
  for (int i=0; i < numberOfOutputs; i++) {
    setPartitioner(taskConfiguration,i,partitioners);
  }
  for (  ChannelSelector<StreamRecord> outputPartitioner : partitioners) {
    if (taskBase instanceof StreamTask) {
      outputs.add(new RecordWriter<StreamRecord>((StreamTask)taskBase,outputPartitioner));
    }
 else     if (taskBase instanceof StreamSource) {
      outputs.add(new RecordWriter<StreamRecord>((StreamSource)taskBase,outputPartitioner));
    }
 else {
      throw new StreamComponentException("Nonsupported object passed to setConfigOutputs");
    }
  }
  collector.setOutputs(outputs);
}
