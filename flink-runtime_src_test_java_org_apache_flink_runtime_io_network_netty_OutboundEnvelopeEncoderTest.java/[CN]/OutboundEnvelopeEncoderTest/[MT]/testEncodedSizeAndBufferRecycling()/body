{
  final ByteBuffer events=ByteBuffer.allocate(MAX_EVENTS_SIZE);
  final MemorySegment segment=new MemorySegment(new byte[MAX_BUFFER_SIZE]);
  final Buffer buffer=mock(Buffer.class);
  when(buffer.getMemorySegment()).thenReturn(segment);
  final EmbeddedChannel channel=new EmbeddedChannel(new OutboundEnvelopeEncoder());
  int numBuffers=0;
  for (int i=0; i < NUM_RANDOM_ENVELOPES; i++) {
    Envelope env=new Envelope(i,new JobID(),new ChannelID());
    int expectedEncodedMsgSize=OutboundEnvelopeEncoder.HEADER_SIZE;
    if (random.nextBoolean()) {
      int eventsSize=random.nextInt(MAX_EVENTS_SIZE + 1);
      expectedEncodedMsgSize+=eventsSize;
      events.clear();
      events.limit(eventsSize);
      env.setEventsSerialized(events);
    }
    if (random.nextBoolean()) {
      numBuffers++;
      int bufferSize=random.nextInt(MAX_BUFFER_SIZE + 1);
      when(buffer.size()).thenReturn(bufferSize);
      env.setBuffer(buffer);
      expectedEncodedMsgSize+=bufferSize;
    }
    Assert.assertTrue(channel.writeOutbound(env));
    ByteBuf encodedMsg=(ByteBuf)channel.readOutbound();
    Assert.assertEquals(expectedEncodedMsgSize,encodedMsg.readableBytes());
    encodedMsg.release();
  }
  verify(buffer,times(numBuffers)).recycleBuffer();
}
