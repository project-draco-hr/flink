{
  final int numberOfRequiredSlots=this.groupMembers.size();
  final int resourcesToBeReplaced=Math.min(availableResources.size(),numberOfRequiredSlots);
  final Map<AllocatedResource,AllocatedResource> replacementMap=new HashMap<AllocatedResource,AllocatedResource>();
  if (resourcesToBeReplaced > 0) {
    final Iterator<ExecutionVertex> vertexIt=this.groupMembers.iterator();
    final Iterator<AllocatedResource> resourceIt=availableResources.iterator();
    while (replacementMap.size() < resourcesToBeReplaced) {
      if (!vertexIt.hasNext()) {
        break;
      }
      if (!resourceIt.hasNext()) {
        break;
      }
      final ExecutionVertex vertex=vertexIt.next();
      final AllocatedResource originalResource=vertex.getAllocatedResource();
      if (!replacementMap.containsKey(originalResource)) {
        final AllocatedResource replacementResource=resourceIt.next();
        replacementMap.put(originalResource,replacementResource);
      }
    }
  }
  final Iterator<ExecutionVertex> vertexIt=this.groupMembers.iterator();
  while (vertexIt.hasNext()) {
    final ExecutionVertex vertex=vertexIt.next();
    final AllocatedResource originalResource=vertex.getAllocatedResource();
    final AllocatedResource replacementResource=replacementMap.get(originalResource);
    if (replacementResource != null) {
      vertex.setAllocatedResource(replacementResource);
    }
 else {
      availableResources.add(originalResource);
    }
  }
  final Iterator<ExecutionGroupVertex> groupVertexIt=this.verticesSharingInstances.iterator();
  while (groupVertexIt.hasNext()) {
    groupVertexIt.next().repairInstanceSharing(availableResources);
  }
}
