{
  if (inputGateIndex == 1) {
    if (!hasCachedInput()) {
      if (log.isInfoEnabled()) {
        log.info(formatLogString("wrapping input [" + inputGateIndex + "] with a caching iterator"));
      }
      cachedInput=new CachingMutableObjectIterator<X>((MutableObjectIterator<X>)super.getInput(inputGateIndex));
    }
 else {
      if (log.isInfoEnabled()) {
        log.info(formatLogString("returning cached iterator for input [" + inputGateIndex + "]"));
      }
    }
    return cachedInput;
  }
  if (!getTaskConfig().isIterativeInputGate(inputGateIndex)) {
    return super.getInput(inputGateIndex);
  }
  int numberOfEventsUntilInterrupt=getTaskConfig().getNumberOfEventsUntilInterruptInIterativeGate(inputGateIndex);
  String owner=getEnvironment().getTaskName() + " (" + (getEnvironment().getIndexInSubtaskGroup() + 1)+ '/'+ getEnvironment().getCurrentNumberOfSubtasks()+ ")";
  InterruptingMutableObjectIterator<X> interruptingIterator=new InterruptingMutableObjectIterator<X>((MutableObjectIterator<X>)super.getInput(inputGateIndex),numberOfEventsUntilInterrupt,owner);
  getReader(inputGateIndex).subscribeToEvent(interruptingIterator,EndOfSuperstepEvent.class);
  if (log.isInfoEnabled()) {
    log.info(formatLogString("wrapping input [" + inputGateIndex + "] with an interrupting iterator that waits "+ "for ["+ numberOfEventsUntilInterrupt+ "] event(s)"));
  }
  return interruptingIterator;
}
