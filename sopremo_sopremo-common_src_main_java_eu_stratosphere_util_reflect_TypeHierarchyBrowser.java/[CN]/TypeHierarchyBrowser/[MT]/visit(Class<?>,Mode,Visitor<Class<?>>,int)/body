{
  if (maxDepth <= 0)   return;
  List<Class<?>> currentTypes=new LinkedList<Class<?>>(), nextTypes=new LinkedList<Class<?>>();
  currentTypes.add(startType);
  for (int depth=1; depth <= maxDepth && !currentTypes.isEmpty(); depth++) {
    final boolean shouldDescend=depth + 1 <= maxDepth;
    for (    Class<?> type : currentTypes) {
      Iterable<? extends Class<?>> superTypes=mode.getSuperTypes(type);
      for (      Class<?> superType : superTypes) {
        if (mode.shouldInvokeCallback(superType)) {
          if (!callback.visited(superType,depth))           return;
        }
        if (shouldDescend)         nextTypes.add(superType);
      }
    }
    currentTypes.clear();
    List<Class<?>> swap=currentTypes;
    currentTypes=mode.prepare(nextTypes);
    nextTypes=swap;
  }
}
