{
  List<Integer> inputs=new ArrayList<Integer>();
  inputs.add(1);
  inputs.add(1);
  inputs.add(5);
  inputs.add(5);
  inputs.add(5);
  inputs.add(1);
  inputs.add(1);
  inputs.add(5);
  inputs.add(1);
  inputs.add(5);
  List<Integer> expectedDistributedEviction=new ArrayList<Integer>();
  expectedDistributedEviction.add(15);
  expectedDistributedEviction.add(3);
  expectedDistributedEviction.add(3);
  expectedDistributedEviction.add(15);
  List<Integer> expectedCentralEviction=new ArrayList<Integer>();
  expectedCentralEviction.add(2);
  expectedCentralEviction.add(5);
  expectedCentralEviction.add(15);
  expectedCentralEviction.add(2);
  expectedCentralEviction.add(5);
  expectedCentralEviction.add(2);
  expectedCentralEviction.add(5);
  expectedCentralEviction.add(1);
  expectedCentralEviction.add(5);
  LinkedList<CloneableTriggerPolicy<Integer>> triggers=new LinkedList<CloneableTriggerPolicy<Integer>>();
  triggers.add(new CountTriggerPolicy<Integer>(2,-1));
  LinkedList<CloneableEvictionPolicy<Integer>> evictions=new LinkedList<CloneableEvictionPolicy<Integer>>();
  evictions.add(new CountEvictionPolicy<Integer>(2,2,-1));
  LinkedList<TriggerPolicy<Integer>> centralTriggers=new LinkedList<TriggerPolicy<Integer>>();
  ReduceFunction<Integer> reduceFunction=new ReduceFunction<Integer>(){
    private static final long serialVersionUID=1L;
    @Override public Integer reduce(    Integer value1,    Integer value2) throws Exception {
      return value1 + value2;
    }
  }
;
  KeySelector<Integer,Integer> keySelector=new KeySelector<Integer,Integer>(){
    private static final long serialVersionUID=1L;
    @Override public Integer getKey(    Integer value){
      return value;
    }
  }
;
  GroupedStreamDiscretizer<Integer,Integer> invokable=new GroupedStreamDiscretizer<Integer,Integer>(reduceFunction,keySelector,triggers,evictions,centralTriggers,null);
  List<Integer> result=MockContext.createAndExecute(invokable,inputs);
  List<Integer> actual=new LinkedList<Integer>();
  for (  Integer current : result) {
    actual.add(current);
  }
  assertEquals(new HashSet<Integer>(expectedDistributedEviction),new HashSet<Integer>(actual));
  assertEquals(expectedDistributedEviction.size(),actual.size());
  triggers.clear();
  centralTriggers.add(new CountTriggerPolicy<Integer>(2,-1));
  LinkedList<EvictionPolicy<Integer>> centralEvictions=new LinkedList<EvictionPolicy<Integer>>();
  centralEvictions.add(new CountEvictionPolicy<Integer>(2,2,-1));
  invokable=new GroupedStreamDiscretizer<Integer,Integer>(reduceFunction,keySelector,triggers,null,centralTriggers,centralEvictions);
  result=MockContext.createAndExecute(invokable,inputs);
  actual=new LinkedList<Integer>();
  for (  Integer current : result) {
    actual.add(current);
  }
  assertEquals(new HashSet<Integer>(expectedCentralEviction),new HashSet<Integer>(actual));
  assertEquals(expectedCentralEviction.size(),actual.size());
}
