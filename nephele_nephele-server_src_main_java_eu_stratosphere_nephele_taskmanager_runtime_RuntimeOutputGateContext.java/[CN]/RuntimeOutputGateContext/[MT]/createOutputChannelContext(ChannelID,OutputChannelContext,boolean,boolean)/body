{
  if (previousContext != null) {
    throw new IllegalStateException("Found previous output context for channel " + channelID);
  }
  AbstractOutputChannel<? extends Record> channel=null;
  for (int i=0; i < this.outputGate.getNumberOfOutputChannels(); ++i) {
    AbstractOutputChannel<? extends Record> candidateChannel=this.outputGate.getOutputChannel(i);
    if (candidateChannel.getID().equals(channelID)) {
      channel=candidateChannel;
      break;
    }
  }
  if (channel == null) {
    throw new IllegalArgumentException("Cannot find output channel with ID " + channelID);
  }
  if (!(channel instanceof AbstractByteBufferedOutputChannel)) {
    throw new IllegalStateException("Channel with ID" + channelID + " is not of type AbstractByteBufferedOutputChannel");
  }
  final AbstractByteBufferedOutputChannel<? extends Record> outputChannel=(AbstractByteBufferedOutputChannel<? extends Record>)channel;
  RuntimeOutputChannelBroker outputChannelBroker;
  AbstractOutputChannelForwarder last;
  if (outputChannel.getType() == ChannelType.FILE) {
    final EphemeralCheckpoint checkpoint=this.taskContext.getEphemeralCheckpoint();
    if (checkpoint == null) {
      throw new IllegalStateException("No ephemeral checkpoint for file channel " + outputChannel.getID());
    }
    final EphemeralCheckpointForwarder checkpointForwarder=new EphemeralCheckpointForwarder(checkpoint,null);
    outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,checkpointForwarder,this.compressor);
    last=checkpointForwarder;
  }
 else {
    final RuntimeDispatcher runtimeDispatcher=new RuntimeDispatcher(this.taskContext.getTransferEnvelopeDispatcher());
    final SpillingBarrier spillingBarrier=new SpillingBarrier(isReceiverRunning,mergeSpillBuffers,runtimeDispatcher);
    final ForwardingBarrier forwardingBarrier=new ForwardingBarrier(channelID,spillingBarrier);
    final EphemeralCheckpoint checkpoint=this.taskContext.getEphemeralCheckpoint();
    if (checkpoint != null) {
      final EphemeralCheckpointForwarder checkpointForwarder=new EphemeralCheckpointForwarder(checkpoint,forwardingBarrier);
      outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,checkpointForwarder,this.compressor);
    }
 else {
      outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,forwardingBarrier,this.compressor);
    }
    last=runtimeDispatcher;
  }
  final OutputChannelForwardingChain forwardingChain=new OutputChannelForwardingChain(outputChannelBroker,last);
  outputChannelBroker.setForwardingChain(forwardingChain);
  return new RuntimeOutputChannelContext(outputChannel,forwardingChain);
}
