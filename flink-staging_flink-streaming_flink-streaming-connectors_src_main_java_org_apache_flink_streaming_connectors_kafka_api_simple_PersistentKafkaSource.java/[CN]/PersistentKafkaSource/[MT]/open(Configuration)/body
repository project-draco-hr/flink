{
  LOG.info("Starting PersistentKafkaSource");
  StreamingRuntimeContext context=(StreamingRuntimeContext)getRuntimeContext();
  int indexOfSubtask=context.getIndexOfThisSubtask();
  int numberOfSubtasks=context.getNumberOfParallelSubtasks();
  KafkaTopicUtils kafkaTopicUtils=new KafkaTopicUtils(consumerConfig.zkConnect(),consumerConfig.zkSyncTimeMs(),consumerConfig.zkConnectionTimeoutMs());
  int numberOfPartitions=kafkaTopicUtils.getNumberOfPartitions(topicId);
  if (indexOfSubtask >= numberOfPartitions) {
    LOG.info("Creating idle consumer because this subtask ({}) is higher than the number partitions ({})",indexOfSubtask + 1,numberOfPartitions);
    iterator=new KafkaIdleConsumerIterator();
  }
 else {
    if (context.containsState("kafka")) {
      LOG.info("Initializing PersistentKafkaSource from existing state.");
      kafkaOffSetOperatorState=(OperatorState<Map<Integer,KafkaOffset>>)context.getState("kafka");
      partitionOffsets=kafkaOffSetOperatorState.getState();
    }
 else {
      LOG.info("No existing state found. Creating new");
      partitionOffsets=new HashMap<Integer,KafkaOffset>();
      for (int partitionIndex=indexOfSubtask; partitionIndex < numberOfPartitions; partitionIndex+=numberOfSubtasks) {
        partitionOffsets.put(partitionIndex,startingOffset);
      }
      kafkaOffSetOperatorState=new OperatorState<Map<Integer,KafkaOffset>>(partitionOffsets);
      context.registerState("kafka",kafkaOffSetOperatorState);
    }
    iterator=new KafkaMultiplePartitionsIterator(topicId,partitionOffsets,kafkaTopicUtils,this.consumerConfig);
    if (LOG.isInfoEnabled()) {
      LOG.info("PersistentKafkaSource ({}/{}) listening to partitionOffsets {} of topic {}.",indexOfSubtask + 1,numberOfSubtasks,partitionOffsets.keySet(),topicId);
    }
  }
  iterator.initialize();
}
