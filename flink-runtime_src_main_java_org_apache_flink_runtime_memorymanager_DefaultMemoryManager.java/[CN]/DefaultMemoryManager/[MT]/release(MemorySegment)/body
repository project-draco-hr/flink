{
  if (segment == null || segment.isFreed() || !(segment instanceof DefaultMemorySegment)) {
    return;
  }
  final DefaultMemorySegment defSeg=(DefaultMemorySegment)segment;
  final AbstractInvokable owner=defSeg.owner;
synchronized (this.lock) {
    if (this.isShutDown) {
      throw new IllegalStateException("Memory manager has been shut down.");
    }
    try {
      Set<DefaultMemorySegment> segsForOwner=this.allocatedSegments.get(owner);
      if (segsForOwner != null) {
        segsForOwner.remove(defSeg);
        if (segsForOwner.isEmpty()) {
          this.allocatedSegments.remove(owner);
        }
      }
      byte[] buffer=defSeg.destroy();
      if (isPreAllocated) {
        this.freeSegments.add(buffer);
      }
 else {
        numNonAllocatedPages++;
      }
    }
 catch (    Throwable t) {
      throw new RuntimeException("Error removing book-keeping reference to allocated memory segment.",t);
    }
  }
}
