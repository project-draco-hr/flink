{
  if (segments == null) {
    return;
  }
synchronized (this.lock) {
    if (this.isShutDown) {
      throw new IllegalStateException("Memory manager has been shut down.");
    }
    boolean successfullyReleased=false;
    do {
      final Iterator<T> segmentsIterator=segments.iterator();
      AbstractInvokable lastOwner=null;
      Set<DefaultMemorySegment> segsForOwner=null;
      try {
        while (segmentsIterator.hasNext()) {
          final MemorySegment seg=segmentsIterator.next();
          if (seg == null || seg.isFreed()) {
            continue;
          }
          final DefaultMemorySegment defSeg=(DefaultMemorySegment)seg;
          final AbstractInvokable owner=defSeg.owner;
          try {
            if (lastOwner != owner) {
              lastOwner=owner;
              segsForOwner=this.allocatedSegments.get(owner);
            }
            if (segsForOwner != null) {
              segsForOwner.remove(defSeg);
              if (segsForOwner.isEmpty()) {
                this.allocatedSegments.remove(owner);
              }
            }
            byte[] buffer=defSeg.destroy();
            if (isPreAllocated) {
              this.freeSegments.add(buffer);
            }
 else {
              numNonAllocatedPages++;
            }
          }
 catch (          Throwable t) {
            throw new RuntimeException("Error removing book-keeping reference to allocated memory segment.",t);
          }
        }
        segments.clear();
        successfullyReleased=true;
      }
 catch (      ConcurrentModificationException e) {
      }
    }
 while (!successfullyReleased);
  }
}
