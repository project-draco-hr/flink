{
  if (owner == null) {
    throw new IllegalAccessError("The memory owner must not be null.");
  }
  if (target instanceof ArrayList) {
    ((ArrayList<MemorySegment>)target).ensureCapacity(numPages);
  }
synchronized (this.lock) {
    if (this.isShutDown) {
      throw new IllegalStateException("Memory manager has been shut down.");
    }
    if (numPages > (this.freeSegments.size() + numNonAllocatedPages)) {
      throw new MemoryAllocationException("Could not allocate " + numPages + " pages. Only "+ this.freeSegments.size()+ " pages are remaining.");
    }
    Set<DefaultMemorySegment> segmentsForOwner=this.allocatedSegments.get(owner);
    if (segmentsForOwner == null) {
      segmentsForOwner=new HashSet<DefaultMemorySegment>(4 * numPages / 3 + 1);
      this.allocatedSegments.put(owner,segmentsForOwner);
    }
    if (isPreAllocated) {
      for (int i=numPages; i > 0; i--) {
        byte[] buffer=this.freeSegments.poll();
        final DefaultMemorySegment segment=new DefaultMemorySegment(owner,buffer);
        target.add(segment);
        segmentsForOwner.add(segment);
      }
    }
 else {
      for (int i=numPages; i > 0; i--) {
        byte[] buffer=new byte[pageSize];
        final DefaultMemorySegment segment=new DefaultMemorySegment(owner,buffer);
        target.add(segment);
        segmentsForOwner.add(segment);
      }
      numNonAllocatedPages-=numPages;
    }
  }
}
