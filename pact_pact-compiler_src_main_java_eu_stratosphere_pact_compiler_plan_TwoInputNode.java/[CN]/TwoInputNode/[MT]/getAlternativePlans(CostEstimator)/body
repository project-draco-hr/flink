{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  final int inputSize1=this.input1.size();
  @SuppressWarnings("unchecked") List<? extends OptimizerNode>[] inPlans1=new List[inputSize1];
  for (int i=0; i < inputSize1; ++i) {
    inPlans1[i]=this.input1.get(i).getSourcePact().getAlternativePlans(estimator);
  }
  List<List<OptimizerNode>> alternativeSubPlanCominations1=new ArrayList<List<OptimizerNode>>();
  getAlternativeSubPlanCombinationsRecursively(inPlans1,new ArrayList<OptimizerNode>(0),alternativeSubPlanCominations1);
  final int inputSize2=this.input2.size();
  @SuppressWarnings("unchecked") List<? extends OptimizerNode>[] inPlans2=new List[inputSize2];
  for (int i=0; i < inputSize2; ++i) {
    inPlans2[i]=this.input2.get(i).getSourcePact().getAlternativePlans(estimator);
  }
  List<List<OptimizerNode>> alternativeSubPlanCominations2=new ArrayList<List<OptimizerNode>>();
  getAlternativeSubPlanCombinationsRecursively(inPlans2,new ArrayList<OptimizerNode>(0),alternativeSubPlanCominations2);
  List<OptimizerNode> outputPlans=new ArrayList<OptimizerNode>();
  computeValidPlanAlternatives(alternativeSubPlanCominations1,alternativeSubPlanCominations2,estimator,outputPlans);
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
