{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  final List<? extends PlanNode> subPlans1=getFirstPredecessorNode().getAlternativePlans(estimator);
  final List<? extends PlanNode> subPlans2=getSecondPredecessorNode().getAlternativePlans(estimator);
  final List<Channel> candidates1=new ArrayList<Channel>(subPlans1.size());
  final List<Channel> candidates2=new ArrayList<Channel>(subPlans2.size());
  List<InterestingProperties> ips=this.input1.getInterestingProperties();
  for (  PlanNode p : subPlans1) {
    if (ips.isEmpty()) {
      Channel c=new Channel(p);
      c.setShipStrategy(ShipStrategyType.FORWARD);
      c.setLocalStrategy(LocalStrategy.NONE);
      candidates1.add(c);
    }
 else {
      for (      InterestingProperties ip : ips) {
        candidates1.add(ip.createChannelRealizingProperties(p));
      }
    }
  }
  ips=this.input2.getInterestingProperties();
  for (  PlanNode p : subPlans2) {
    if (ips.isEmpty()) {
      Channel c=new Channel(p);
      c.setShipStrategy(ShipStrategyType.FORWARD);
      c.setLocalStrategy(LocalStrategy.NONE);
      candidates2.add(c);
    }
 else {
      for (      InterestingProperties ip : ips) {
        candidates2.add(ip.createChannelRealizingProperties(p));
      }
    }
  }
  final List<PlanNode> outputPlans=new ArrayList<PlanNode>(subPlans1.size() + subPlans2.size());
  for (  Channel first : candidates1) {
    for (    Channel second : candidates2) {
      if (areBranchCompatible(first,second)) {
        createPlanAlternative(first,second,outputPlans);
      }
    }
  }
  prunePlanAlternatives(outputPlans);
  this.cachedPlans=outputPlans;
  return outputPlans;
}
