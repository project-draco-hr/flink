{
  if (inputNodes.size() != 2)   throw new IllegalArgumentException("TwoInputNode requires exactly 2 input nodes");
  OptimizerNode inputNode1=inputNodes.get(0);
  OptimizerNode inputNode2=inputNodes.get(1);
switch (input) {
case 0:
    if (implOpMode1 != null) {
switch (implOpMode1) {
case Copy:
        if (this.explProjections1 != null) {
          return FieldSetOperations.unionSets(this.explProjections1,this.explWrites);
        }
 else {
          return null;
        }
case Projection:
      if (this.explCopies1 != null) {
        return FieldSetOperations.unionSets(FieldSetOperations.setDifference(inputNode1.outputSchema,this.explCopies1),this.explWrites);
      }
 else {
        return null;
      }
default :
    return null;
}
}
 else {
return null;
}
case 1:
if (implOpMode2 != null) {
switch (implOpMode2) {
case Copy:
if (this.explProjections2 != null) {
  return FieldSetOperations.unionSets(this.explProjections2,this.explWrites);
}
 else {
  return null;
}
case Projection:
if (this.explCopies2 != null) {
return FieldSetOperations.unionSets(FieldSetOperations.setDifference(inputNode2.outputSchema,this.explCopies2),this.explWrites);
}
 else {
return null;
}
default :
return null;
}
}
 else {
return null;
}
case -1:
if (this.implOpMode1 != null && this.implOpMode2 != null && this.explWrites != null) {
int[] projection1=null;
int[] projection2=null;
switch (this.implOpMode1) {
case Copy:
projection1=this.explProjections1;
break;
case Projection:
if (this.explCopies1 != null) {
projection1=FieldSetOperations.setDifference(inputNode1.outputSchema,this.explCopies1);
}
 else {
return null;
}
break;
default :
return null;
}
switch (this.implOpMode2) {
case Copy:
projection2=this.explProjections2;
break;
case Projection:
if (this.explCopies2 != null) {
projection2=FieldSetOperations.setDifference(inputNode2.outputSchema,this.explCopies2);
}
 else {
return null;
}
break;
default :
return null;
}
if (projection1 != null && projection2 != null) {
return FieldSetOperations.unionSets(FieldSetOperations.unionSets(projection1,projection2),this.explWrites);
}
 else {
return null;
}
}
 else {
return null;
}
default :
throw new IndexOutOfBoundsException();
}
}
