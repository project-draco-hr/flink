{
  super(template,globalProps,localProps);
  this.reads1=template.reads1;
  this.reads2=template.reads2;
  this.explCopies1=template.explCopies1;
  this.explCopies2=template.explCopies2;
  this.explProjections1=template.explProjections1;
  this.explProjections2=template.explProjections2;
  this.implOpMode1=template.implOpMode1;
  this.implOpMode2=template.implOpMode2;
  this.keySet1=template.keySet1;
  this.keySet2=template.keySet2;
  if (pred1 != null) {
    this.input1=new PactConnection(conn1,pred1,this);
  }
  if (pred2 != null) {
    this.input2=new PactConnection(conn2,pred2,this);
  }
  if (template.openBranches != null) {
    if (this.branchPlan == null) {
      this.branchPlan=new HashMap<OptimizerNode,OptimizerNode>(8);
    }
    for (    UnclosedBranchDescriptor uc : template.openBranches) {
      OptimizerNode brancher=uc.branchingNode;
      OptimizerNode selectedCandidate=null;
      if (pred1 != null) {
        if (pred1.branchPlan != null) {
          selectedCandidate=pred1.branchPlan.get(brancher);
          this.branchPlan.put(brancher,selectedCandidate);
        }
      }
      if (selectedCandidate == null && pred2 != null) {
        if (pred2.branchPlan != null) {
          selectedCandidate=pred2.branchPlan.get(brancher);
          this.branchPlan.put(brancher,selectedCandidate);
        }
      }
      if (selectedCandidate == null) {
        throw new CompilerException("Candidates for a node with open branches are missing information about the selected candidate ");
      }
    }
  }
}
