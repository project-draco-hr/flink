{
  try {
    final int sequences=10;
    final Random rnd=new Random();
    final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    final SequenceConsumer consumer=new SequenceConsumer(error,sequences);
    consumer.start();
    final int maxNumEventsAndBuffers=30000;
    final int maxNumChannels=1656;
    for (int round=0; round < 2 * sequences; round++) {
      if (round % 2 == 1) {
        assertNull(spiller.rollOver());
      }
 else {
        final long bufferSeed=rnd.nextLong();
        final Random bufferRnd=new Random(bufferSeed);
        final int numEventsAndBuffers=rnd.nextInt(maxNumEventsAndBuffers) + 1;
        final int numChannels=rnd.nextInt(maxNumChannels) + 1;
        final ArrayList<BufferOrEvent> events=new ArrayList<BufferOrEvent>(128);
        for (int i=0; i < numEventsAndBuffers; i++) {
          boolean isEvent=rnd.nextDouble() < 0.05d;
          if (isEvent) {
            BufferOrEvent evt=generateRandomEvent(rnd,numChannels);
            events.add(evt);
            spiller.add(evt);
          }
 else {
            BufferOrEvent evt=generateRandomBuffer(bufferRnd.nextInt(PAGE_SIZE) + 1,bufferRnd.nextInt(numChannels));
            spiller.add(evt);
          }
        }
        bufferRnd.setSeed(bufferSeed);
        BufferSpiller.SpilledBufferOrEventSequence seq=spiller.rollOver();
        SequenceToConsume stc=new SequenceToConsume(bufferRnd,events,seq,numEventsAndBuffers,numChannels);
        consumer.queue(stc);
      }
    }
    consumer.join(180000);
    assertFalse("sequence consumer did not finish its work in time",consumer.isAlive());
    if (error.get() != null) {
      Throwable t=error.get();
      if (t instanceof Error) {
        throw (Error)t;
      }
 else {
        throw new Exception("Error while consuming the spilled records",t);
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
