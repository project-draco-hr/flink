{
  OptimizerNode n=this.con2node.get(c);
  if (n.getId() > 0) {
    return;
  }
  n.setId(this.id);
  n.setInputs(this.con2node);
  this.id=n.getId() + 1;
  if (this.computeEstimates) {
    n.computeOutputEstimates(this.statistics);
  }
  if (n instanceof BulkIterationNode) {
    final BulkIterationNode iterNode=(BulkIterationNode)n;
    final BulkIteration iter=iterNode.getIterationContract();
    final GraphCreatingVisitor recursiveCreator=new GraphCreatingVisitor(this,true,this.statistics,this.maxMachines,iterNode.getDegreeOfParallelism(),this.computeEstimates);
    iter.getNextPartialSolution().accept(recursiveCreator);
    OptimizerNode rootOfStepFunction=recursiveCreator.con2node.get(iter.getNextPartialSolution());
    BulkPartialSolutionNode partialSolution=(BulkPartialSolutionNode)recursiveCreator.con2node.get(iter.getPartialSolution());
    if (partialSolution == null) {
      throw new CompilerException("Error: The step functions result does not depend on the partial solution.");
    }
    PactConnection rootConn=new PactConnection(rootOfStepFunction);
    rootOfStepFunction.addOutgoingConnection(rootConn);
    iterNode.setNextPartialSolution(rootOfStepFunction,rootConn);
    iterNode.setPartialSolution(partialSolution);
    this.numMemoryConsumers+=recursiveCreator.numMemoryConsumers;
    rootOfStepFunction.accept(new StaticDynamicPathIdentifier(iterNode.getCostWeight()));
  }
 else   if (n instanceof WorksetIterationNode) {
    final WorksetIterationNode iterNode=(WorksetIterationNode)n;
    final DeltaIteration iter=iterNode.getIterationContract();
    final GraphCreatingVisitor recursiveCreator=new GraphCreatingVisitor(this,true,this.statistics,this.maxMachines,iterNode.getDegreeOfParallelism(),this.computeEstimates);
    iter.getSolutionSetDelta().accept(recursiveCreator);
    final SolutionSetNode solutionSetNode=(SolutionSetNode)recursiveCreator.con2node.get(iter.getSolutionSet());
    final WorksetNode worksetNode=(WorksetNode)recursiveCreator.con2node.get(iter.getWorkset());
    if (worksetNode == null) {
      throw new CompilerException("In the given plan, the solution set delta does not depend on the workset. This is a prerequisite in workset iterations.");
    }
    iter.getNextWorkset().accept(recursiveCreator);
    if (solutionSetNode == null || solutionSetNode.getOutgoingConnections() == null || solutionSetNode.getOutgoingConnections().isEmpty()) {
      throw new CompilerException("Error: The step function does not reference the solution set.");
    }
 else {
      if (solutionSetNode.getOutgoingConnections().size() > 1) {
        throw new CompilerException("Error: The solution set may currently be joined with only once.");
      }
 else {
        OptimizerNode successor=solutionSetNode.getOutgoingConnections().get(0).getTarget();
        if (successor.getClass() == MatchNode.class) {
          MatchNode mn=(MatchNode)successor;
          if (mn.getFirstPredecessorNode() == solutionSetNode) {
            mn.fixDriverStrategy(DriverStrategy.HYBRIDHASH_BUILD_FIRST);
          }
 else           if (mn.getSecondPredecessorNode() == solutionSetNode) {
            mn.fixDriverStrategy(DriverStrategy.HYBRIDHASH_BUILD_SECOND);
          }
 else {
            throw new CompilerException();
          }
        }
 else         if (successor.getClass() == CoGroupNode.class) {
          CoGroupNode cg=(CoGroupNode)successor;
          if (cg.getFirstPredecessorNode() == solutionSetNode) {
            cg.makeCoGroupWithSolutionSet(0);
          }
 else           if (cg.getSecondPredecessorNode() == solutionSetNode) {
            cg.makeCoGroupWithSolutionSet(1);
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          throw new CompilerException("Error: The solution set may only be joined with through a Match or a CoGroup.");
        }
      }
    }
    final OptimizerNode nextWorksetNode=recursiveCreator.con2node.get(iter.getNextWorkset());
    final OptimizerNode solutionSetDeltaNode=recursiveCreator.con2node.get(iter.getSolutionSetDelta());
    iterNode.setPartialSolution(solutionSetNode,worksetNode);
    iterNode.setNextPartialSolution(solutionSetDeltaNode,nextWorksetNode);
    this.numMemoryConsumers+=recursiveCreator.numMemoryConsumers;
    StaticDynamicPathIdentifier pathIdentifier=new StaticDynamicPathIdentifier(iterNode.getCostWeight());
    nextWorksetNode.accept(pathIdentifier);
    solutionSetDeltaNode.accept(pathIdentifier);
  }
}
