{
  checkNotNull(savepointPath,"Savepoint path");
synchronized (lock) {
    if (isShutdown()) {
      throw new IllegalStateException("CheckpointCoordinator is shut down");
    }
    LOG.info("Rolling back to savepoint '{}'.",savepointPath);
    CompletedCheckpoint checkpoint=savepointStore.getState(savepointPath);
    LOG.info("Savepoint: {}@{}",checkpoint.getCheckpointID(),checkpoint.getTimestamp());
    LOG.debug("Rolling back individual operators.");
    for (    Map.Entry<JobVertexID,TaskState> taskStateEntry : checkpoint.getTaskStates().entrySet()) {
      TaskState taskState=taskStateEntry.getValue();
      ExecutionJobVertex executionJobVertex=tasks.get(taskStateEntry.getKey());
      if (executionJobVertex != null) {
        if (executionJobVertex.getParallelism() != taskState.getParallelism()) {
          String msg=String.format("Failed to rollback to savepoint %s. " + "Parallelism mismatch between savepoint state and new program. " + "Cannot map operator %s with parallelism %d to new program with "+ "parallelism %d. This indicates that the program has been changed "+ "in a non-compatible way after the savepoint.",checkpoint,taskStateEntry.getKey(),taskState.getParallelism(),executionJobVertex.getParallelism());
          throw new IllegalStateException(msg);
        }
        List<Set<Integer>> keyGroupPartitions=createKeyGroupPartitions(numberKeyGroups,executionJobVertex.getParallelism());
        for (int i=0; i < executionJobVertex.getTaskVertices().length; i++) {
          SubtaskState subtaskState=taskState.getState(i);
          SerializedValue<StateHandle<?>> state=null;
          if (subtaskState != null) {
            state=subtaskState.getState();
          }
          Map<Integer,SerializedValue<StateHandle<?>>> kvStateForTaskMap=taskState.getUnwrappedKvStates(keyGroupPartitions.get(i));
          Execution currentExecutionAttempt=executionJobVertex.getTaskVertices()[i].getCurrentExecutionAttempt();
          currentExecutionAttempt.setInitialState(state,kvStateForTaskMap);
        }
      }
 else {
        String msg=String.format("Failed to rollback to savepoint %s. " + "Cannot map old state for task %s to the new program. " + "This indicates that the program has been changed in a "+ "non-compatible way  after the savepoint.",checkpoint,taskStateEntry.getKey());
        throw new IllegalStateException(msg);
      }
    }
    long nextCheckpointId=checkpoint.getCheckpointID();
    checkpointIdCounter.start();
    checkpointIdCounter.setCount(nextCheckpointId + 1);
    LOG.info("Reset the checkpoint ID to {}",nextCheckpointId);
    if (savepointRestorePath == null) {
      savepointRestorePath=savepointPath;
    }
  }
}
