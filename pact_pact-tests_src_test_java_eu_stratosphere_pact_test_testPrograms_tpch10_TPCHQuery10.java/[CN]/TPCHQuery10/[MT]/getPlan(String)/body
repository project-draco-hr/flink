{
  int degreeOfParallelism=1;
  String ordersPath="";
  String lineitemsPath="";
  String customersPath="";
  String nationsPath="";
  String resultPath="";
  if (args.length != 6)   LOGGER.warn("number of arguments do not match!");
 else {
    degreeOfParallelism=Integer.parseInt(args[0]);
    ordersPath=args[1];
    lineitemsPath=args[2];
    customersPath=args[3];
    nationsPath=args[4];
    resultPath=args[5];
  }
  FileDataSourceContract<PactInteger,Tuple> orders=new FileDataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,ordersPath,"Orders");
  orders.setParameter(TextInputFormat.RECORD_DELIMITER,"\n");
  orders.setDegreeOfParallelism(degreeOfParallelism);
  FileDataSourceContract<PactInteger,Tuple> lineitems=new FileDataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,lineitemsPath,"LineItems");
  lineitems.setParameter(TextInputFormat.RECORD_DELIMITER,"\n");
  lineitems.setDegreeOfParallelism(degreeOfParallelism);
  FileDataSourceContract<PactInteger,Tuple> customers=new FileDataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,customersPath,"Customers");
  customers.setParameter(TextInputFormat.RECORD_DELIMITER,"\n");
  customers.setDegreeOfParallelism(degreeOfParallelism);
  FileDataSourceContract<PactInteger,Tuple> nations=new FileDataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,nationsPath,"Nations");
  nations.setParameter(TextInputFormat.RECORD_DELIMITER,"\n");
  nations.setDegreeOfParallelism(degreeOfParallelism);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> mapO=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(FilterO.class,"FilterO");
  mapO.setDegreeOfParallelism(degreeOfParallelism);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> mapLi=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(FilterLI.class,"FilterLi");
  mapLi.setDegreeOfParallelism(degreeOfParallelism);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> projectC=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(ProjectC.class,"ProjectC");
  projectC.setDegreeOfParallelism(degreeOfParallelism);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> projectN=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(ProjectN.class,"ProjectN");
  projectN.setDegreeOfParallelism(degreeOfParallelism);
  MatchContract<PactInteger,Tuple,Tuple,PactInteger,Tuple> joinOL=new MatchContract<PactInteger,Tuple,Tuple,PactInteger,Tuple>(JoinOL.class,"JoinOL");
  joinOL.setDegreeOfParallelism(degreeOfParallelism);
  MatchContract<PactInteger,Tuple,Tuple,PactInteger,Tuple> joinCOL=new MatchContract<PactInteger,Tuple,Tuple,PactInteger,Tuple>(JoinCOL.class,"JoinCOL");
  joinCOL.setDegreeOfParallelism(degreeOfParallelism);
  MatchContract<PactInteger,Tuple,Tuple,GroupKey,Tuple> joinNCOL=new MatchContract<PactInteger,Tuple,Tuple,GroupKey,Tuple>(JoinNCOL.class,"JoinNCOL");
  joinNCOL.setDegreeOfParallelism(degreeOfParallelism);
  ReduceContract<GroupKey,Tuple,GroupKey,Tuple> reduce=new ReduceContract<TPCHQuery10.GroupKey,Tuple,TPCHQuery10.GroupKey,Tuple>(Sum.class,"Reduce");
  reduce.setDegreeOfParallelism(degreeOfParallelism);
  FileDataSinkContract<GroupKey,Tuple> result=new FileDataSinkContract<GroupKey,Tuple>(TupleOutputFormat.class,resultPath,"Output");
  result.setDegreeOfParallelism(degreeOfParallelism);
  result.setInput(reduce);
  reduce.setInput(joinNCOL);
  joinNCOL.setFirstInput(joinCOL);
  joinNCOL.setSecondInput(projectN);
  joinCOL.setFirstInput(projectC);
  joinCOL.setSecondInput(joinOL);
  joinOL.setFirstInput(mapO);
  joinOL.setSecondInput(mapLi);
  projectC.setInput(customers);
  projectN.setInput(nations);
  mapLi.setInput(lineitems);
  mapO.setInput(orders);
  return new Plan(result,"TPCH Q10");
}
