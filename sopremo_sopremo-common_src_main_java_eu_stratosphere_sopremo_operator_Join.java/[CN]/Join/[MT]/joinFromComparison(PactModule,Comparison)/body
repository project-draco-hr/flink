{
  Contract in1=this.addKeyExtraction(module,(Path)comparison.getExpr1());
  Contract in2=this.addKeyExtraction(module,(Path)comparison.getExpr2());
  DualInputContract<PactJsonObject.Key,PactJsonObject,PactJsonObject.Key,PactJsonObject,PactNull,PactJsonObject> join=null;
switch (comparison.getBinaryOperator()) {
case EQUAL:
    if (!this.outerJoinFlag.isEmpty()) {
      boolean leftOuter=this.outerJoinFlag.get(this.getInputIndex((Path)comparison.getExpr1()));
      boolean rightOuter=this.outerJoinFlag.get(this.getInputIndex((Path)comparison.getExpr2()));
      join=new CoGroupContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,PactNull,PactJsonObject>(OuterJoinStub.class);
      join.getStubParameters().setBoolean("leftOuter",leftOuter);
      join.getStubParameters().setBoolean("rightOuter",rightOuter);
      break;
    }
  join=new MatchContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,PactNull,PactJsonObject>(InnerJoinStub.class);
break;
default :
join=new CrossContract<PactJsonObject.Key,PactJsonObject,PactJsonObject.Key,PactJsonObject,PactNull,PactJsonObject>(ThetaJoinStub.class);
setObject(join.getStubParameters(),"comparison",comparison);
break;
}
module.getOutput(0).setInput(join);
join.setFirstInput(in1);
join.setSecondInput(in2);
return join;
}
