{
  Contract in1=PactUtil.addKeyExtraction(module,(Path)comparison.getExpr1(),context);
  Contract in2=PactUtil.addKeyExtraction(module,(Path)comparison.getExpr2(),context);
  DualInputContract<PactJsonObject.Key,PactJsonObject,PactJsonObject.Key,PactJsonObject,Key,PactJsonObject> join=null;
switch (comparison.getBinaryOperator()) {
case EQUAL:
    if (!this.outerJoinFlag.isEmpty()) {
      boolean leftOuter=this.outerJoinFlag.get(PactUtil.getInputIndex((Path)comparison.getExpr1()));
      boolean rightOuter=this.outerJoinFlag.get(PactUtil.getInputIndex((Path)comparison.getExpr2()));
      join=new CoGroupContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,Key,PactJsonObject>(OuterJoinStub.class);
      join.getStubParameters().setBoolean("leftOuter",leftOuter);
      join.getStubParameters().setBoolean("rightOuter",rightOuter);
      break;
    }
  join=new MatchContract<PactJsonObject.Key,PactJsonObject,PactJsonObject,Key,PactJsonObject>(InnerJoinStub.class);
break;
default :
join=new CrossContract<PactJsonObject.Key,PactJsonObject,PactJsonObject.Key,PactJsonObject,Key,PactJsonObject>(ThetaJoinStub.class);
PactUtil.setObject(join.getStubParameters(),"comparison",comparison);
break;
}
module.getOutput(0).setInput(join);
join.setFirstInput(in1);
join.setSecondInput(in2);
return join;
}
