{
  if (timestamp <= nextTs) {
    throw new RuntimeException("Checkpoint timestamp is smaller than previous ts + 1, " + "this should not happen.");
  }
  if (!cache.modified.isEmpty()) {
    for (    Entry<Tuple2<K,N>,Optional<V>> state : cache.modified.entrySet()) {
      batchInsert.add(state,timestamp);
    }
    batchInsert.flush(timestamp);
    cache.modified.clear();
  }
 else   if (compact) {
    for (    final Connection c : connections.connections()) {
      SQLRetrier.retry(new Callable<Void>(){
        @Override public Void call() throws Exception {
          dbAdapter.keepAlive(c);
          return null;
        }
      }
,numSqlRetries,sqlRetrySleep);
    }
  }
  nextTs=timestamp + 1;
  completedCheckpoints.put(checkpointId,timestamp);
  return new DbKvStateSnapshot<K,N,V>(kvStateId,timestamp,lastCompactedTs,namespaceSerializer,stateDesc);
}
