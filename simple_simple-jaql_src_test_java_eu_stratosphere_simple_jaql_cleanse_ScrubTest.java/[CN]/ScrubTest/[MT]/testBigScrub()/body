{
  final SopremoPlan actualPlan=this.parseScript("using cleansing;\n" + "$dirty_earmarks = read hdfs('UsEarmark.json');\n" + "$nick_names = read hdfs('UsNickNames.json');\n"+ "NormalizeName = javaudf('eu.stratosphere.simple.jaql.cleanse.ScrubTest.normalizeName');\n"+ "$scrubbed_earmarks = scrub $dirty_earmark in $dirty_earmarks with {\n"+ "	// normalization with built-in expressions\n"+ "	amount: [$ as decimal, $ * 1000],\n"+ "	// normalization with user-defined functions\n"+ "	sponsorLastName: [required if $dirty_earmark.type == 's', NormalizeName],\n"+ "	sponsorFirstName: [required, NormalizeName, replace $ with $nick_names default $],\n"+ "};\n"+ "write $scrubbed_earmarks to hdfs('scrubbed_earmarks.json');");
  final SopremoPlan expectedPlan=new SopremoPlan();
  final Source dirty_earmarks=new Source("UsEarmark.json");
  final Source nick_names=new Source("UsNickNames.json");
  final Scrubbing scrubbing=new Scrubbing().withInputs(dirty_earmarks);
  scrubbing.addRule(new CoerceExpression(DecimalNode.class),new ObjectAccess("amount"));
  scrubbing.addRule(new ArithmeticExpression(EvaluationExpression.VALUE,ArithmeticOperator.MULTIPLICATION,new ConstantExpression(1000)),new ObjectAccess("amount"));
  scrubbing.addRule(new TernaryExpression(new ComparativeExpression(new PathExpression(Scrubbing.CONTEXT_NODE,new ObjectAccess("type")),BinaryOperator.EQUAL,new ConstantExpression("s")),new NonNullRule(),EvaluationExpression.VALUE),new ObjectAccess("sponsorLastName"));
  scrubbing.addRule(new MethodCall("NormalizeName",new InputSelection(0)),new ObjectAccess("sponsorLastName"));
  scrubbing.addRule(new NonNullRule(),new ObjectAccess("sponsorFirstName"));
  scrubbing.addRule(new MethodCall("NormalizeName",new InputSelection(0)),new ObjectAccess("sponsorFirstName"));
  final Replace replace=new Replace().withInputs(dirty_earmarks,nick_names).withDefaultExpression(new InputSelection(0).withTag(JsonStreamExpression.THIS_CONTEXT));
  scrubbing.addRule(new NestedOperatorExpression(replace),new ObjectAccess("sponsorFirstName"));
  final Sink output=new Sink("scrubbed_earmarks.json").withInputs(scrubbing);
  expectedPlan.setSinks(output);
  assertEquals(expectedPlan,actualPlan);
}
