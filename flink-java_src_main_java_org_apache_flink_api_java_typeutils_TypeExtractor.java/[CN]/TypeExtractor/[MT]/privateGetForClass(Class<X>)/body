{
  Validate.notNull(clazz);
  if (!clazz.isPrimitive() && (Modifier.isInterface(clazz.getModifiers()) || (Modifier.isAbstract(clazz.getModifiers()) && !clazz.isArray()))) {
    throw new InvalidTypesException("Interfaces and abstract classes are not valid types: " + clazz);
  }
  if (clazz.equals(Object.class)) {
    throw new InvalidTypesException("Object is not a valid type.");
  }
  if (clazz.isArray()) {
    PrimitiveArrayTypeInfo<X> primitiveArrayInfo=PrimitiveArrayTypeInfo.getInfoFor(clazz);
    if (primitiveArrayInfo != null) {
      return primitiveArrayInfo;
    }
    BasicArrayTypeInfo<X,?> basicArrayInfo=BasicArrayTypeInfo.getInfoFor(clazz);
    if (basicArrayInfo != null) {
      return basicArrayInfo;
    }
 else {
      return ObjectArrayTypeInfo.getInfoFor(clazz);
    }
  }
  if (Writable.class.isAssignableFrom(clazz)) {
    return (TypeInformation<X>)WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>)clazz);
  }
  TypeInformation<X> basicTypeInfo=BasicTypeInfo.getInfoFor(clazz);
  if (basicTypeInfo != null) {
    return basicTypeInfo;
  }
  if (Value.class.isAssignableFrom(clazz)) {
    Class<? extends Value> valueClass=clazz.asSubclass(Value.class);
    return (TypeInformation<X>)ValueTypeInfo.getValueTypeInfo(valueClass);
  }
  if (Tuple.class.isAssignableFrom(clazz)) {
    throw new InvalidTypesException("Type information extraction for tuples cannot be done based on the class.");
  }
  if (alreadySeen.contains(clazz)) {
    return new GenericTypeInfo<X>(clazz);
  }
  alreadySeen.add(clazz);
  if (clazz.equals(Class.class)) {
    return new GenericTypeInfo<X>(clazz);
  }
  return new GenericTypeInfo<X>(clazz);
}
