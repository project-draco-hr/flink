{
  if (typeHierarchy.size() <= 1) {
    getTypeHierarchy(typeHierarchy,clazz,Object.class);
  }
  if (clazzTypeHint != null) {
    getTypeHierarchy(typeHierarchy,clazzTypeHint,Object.class);
  }
  List<Field> fields=getAllDeclaredFields(clazz);
  List<PojoField> pojoFields=new ArrayList<PojoField>();
  for (  Field field : fields) {
    Type fieldType=field.getGenericType();
    if (!isValidPojoField(field,clazz,typeHierarchy)) {
      LOG.warn("Class " + clazz + " is not a valid POJO type");
      return null;
    }
    try {
      ArrayList<Type> fieldTypeHierarchy=new ArrayList<Type>(typeHierarchy);
      fieldTypeHierarchy.add(fieldType);
      pojoFields.add(new PojoField(field,createTypeInfoWithTypeHierarchy(fieldTypeHierarchy,fieldType,null,null)));
    }
 catch (    InvalidTypesException e) {
      Class<?> genericClass=Object.class;
      if (isClassType(fieldType)) {
        genericClass=typeToClass(fieldType);
      }
      pojoFields.add(new PojoField(field,new GenericTypeInfo(genericClass)));
    }
  }
  CompositeType<X> pojoType=new PojoTypeInfo<X>(clazz,pojoFields);
  List<Method> methods=getAllDeclaredMethods(clazz);
  for (  Method method : methods) {
    if (method.getName().equals("readObject") || method.getName().equals("writeObject")) {
      LOG.warn("Class " + clazz + " contains custom serialization methods we do not call.");
      return null;
    }
  }
  try {
    clazz.getDeclaredConstructor();
  }
 catch (  NoSuchMethodException e) {
    LOG.warn("Class " + clazz + " must have a default constructor to be used as a POJO.");
    return null;
  }
  return pojoType;
}
