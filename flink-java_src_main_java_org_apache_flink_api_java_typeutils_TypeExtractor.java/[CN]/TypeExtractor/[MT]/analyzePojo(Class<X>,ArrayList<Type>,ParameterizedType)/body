{
  if (typeHierarchy.size() == 0) {
    recursivelyGetTypeHierarchy(typeHierarchy,clazz,Object.class);
  }
  if (clazzTypeHint != null) {
    recursivelyGetTypeHierarchy(typeHierarchy,clazzTypeHint,Object.class);
  }
  List<Field> fields=getAllDeclaredFields(clazz);
  List<PojoField> pojoFields=new ArrayList<PojoField>();
  for (  Field field : fields) {
    Type fieldType=field.getGenericType();
    if (!isValidPojoField(field,clazz,typeHierarchy)) {
      LOG.warn("Class " + clazz + " is not a valid POJO type");
      return null;
    }
    try {
      typeHierarchy.add(fieldType);
      pojoFields.add(new PojoField(field,createTypeInfoWithTypeHierarchy(typeHierarchy,fieldType,null,null)));
    }
 catch (    InvalidTypesException e) {
      throw new InvalidTypesException("Flink is currently unable to serialize this type: " + fieldType + ""+ "\nThe system is internally using the Avro serializer which is not able to handle that type.",e);
    }
  }
  CompositeType<X> pojoType=new PojoTypeInfo<X>(clazz,pojoFields);
  List<Method> methods=getAllDeclaredMethods(clazz);
  for (  Method method : methods) {
    if (method.getName().equals("readObject") || method.getName().equals("writeObject")) {
      LOG.warn("Class " + clazz + " contains custom serialization methods we do not call.");
      return null;
    }
  }
  try {
    clazz.getDeclaredConstructor();
  }
 catch (  NoSuchMethodException e) {
    LOG.warn("Class " + clazz + " must have a default constructor to be used as a POJO.");
    return null;
  }
  return pojoType;
}
