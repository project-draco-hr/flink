{
  if (isClassType(t) && Tuple.class.isAssignableFrom(typeToClass(t))) {
    Type curT=t;
    if (typeToClass(t).equals(Tuple.class)) {
      throw new InvalidTypesException("Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.");
    }
    while (!(isClassType(curT) && typeToClass(curT).getSuperclass().equals(Tuple.class))) {
      typeHierarchy.add(curT);
      curT=typeToClass(curT).getGenericSuperclass();
    }
    if (curT instanceof Class<?>) {
      throw new InvalidTypesException("Tuple needs to be parameterized by using generics.");
    }
    typeHierarchy.add(curT);
    ParameterizedType tupleChild=(ParameterizedType)curT;
    Type[] subtypes=new Type[tupleChild.getActualTypeArguments().length];
    for (int i=0; i < subtypes.length; i++) {
      if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
        subtypes[i]=materializeTypeVariable(typeHierarchy,(TypeVariable<?>)tupleChild.getActualTypeArguments()[i]);
      }
 else {
        subtypes[i]=tupleChild.getActualTypeArguments()[i];
      }
    }
    TypeInformation<?>[] tupleSubTypes=new TypeInformation<?>[subtypes.length];
    for (int i=0; i < subtypes.length; i++) {
      ArrayList<Type> subTypeHierarchy=new ArrayList<Type>(typeHierarchy);
      subTypeHierarchy.add(subtypes[i]);
      if (subtypes[i] instanceof TypeVariable<?>) {
        tupleSubTypes[i]=createTypeInfoFromInputs((TypeVariable<?>)subtypes[i],subTypeHierarchy,in1Type,in2Type);
        if (tupleSubTypes[i] == null) {
          throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>)subtypes[i]).getName() + "' in '"+ ((TypeVariable<?>)subtypes[i]).getGenericDeclaration()+ "' could not be determined. This is most likely a type erasure problem. "+ "The type extraction currently supports types with generic variables only in cases where "+ "all variables in the return type can be deduced from the input type(s).");
        }
      }
 else {
        tupleSubTypes[i]=createTypeInfoWithTypeHierarchy(subTypeHierarchy,subtypes[i],in1Type,in2Type);
      }
    }
    Class<?> tAsClass=null;
    if (isClassType(t)) {
      tAsClass=typeToClass(t);
    }
    Preconditions.checkNotNull(tAsClass,"t has a unexpected type");
    int fieldCount=countFieldsInClass(tAsClass);
    if (fieldCount != tupleSubTypes.length) {
      if (t instanceof ParameterizedType) {
        return (TypeInformation<OUT>)analyzePojo(tAsClass,new ArrayList<Type>(typeHierarchy),(ParameterizedType)t,in1Type,in2Type);
      }
 else {
        return (TypeInformation<OUT>)analyzePojo(tAsClass,new ArrayList<Type>(typeHierarchy),null,in1Type,in2Type);
      }
    }
    return new TupleTypeInfo(tAsClass,tupleSubTypes);
  }
 else   if (t instanceof TypeVariable) {
    Type typeVar=materializeTypeVariable(typeHierarchy,(TypeVariable<?>)t);
    if (!(typeVar instanceof TypeVariable)) {
      return createTypeInfoWithTypeHierarchy(typeHierarchy,typeVar,in1Type,in2Type);
    }
 else {
      TypeInformation<OUT> typeInfo=(TypeInformation<OUT>)createTypeInfoFromInputs((TypeVariable<?>)t,typeHierarchy,in1Type,in2Type);
      if (typeInfo != null) {
        return typeInfo;
      }
 else {
        throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>)t).getName() + "' in '"+ ((TypeVariable<?>)t).getGenericDeclaration()+ "' could not be determined. This is most likely a type erasure problem. "+ "The type extraction currently supports types with generic variables only in cases where "+ "all variables in the return type can be deduced from the input type(s).");
      }
    }
  }
 else   if (t instanceof GenericArrayType) {
    GenericArrayType genericArray=(GenericArrayType)t;
    Type componentType=genericArray.getGenericComponentType();
    if (componentType instanceof Class) {
      Class<?> componentClass=(Class<?>)componentType;
      String className;
      if (componentClass.isPrimitive()) {
        className=encodePrimitiveClass(componentClass);
      }
 else {
        className="L" + componentClass.getName() + ";";
      }
      Class<OUT> classArray;
      try {
        classArray=(Class<OUT>)Class.forName("[" + className);
      }
 catch (      ClassNotFoundException e) {
        throw new InvalidTypesException("Could not convert GenericArrayType to Class.");
      }
      return getForClass(classArray);
    }
    TypeInformation<?> componentInfo=createTypeInfoWithTypeHierarchy(typeHierarchy,genericArray.getGenericComponentType(),in1Type,in2Type);
    return ObjectArrayTypeInfo.getInfoFor(t,componentInfo);
  }
 else   if (t instanceof ParameterizedType) {
    return (TypeInformation<OUT>)privateGetForClass(typeToClass(t),typeHierarchy,(ParameterizedType)t,in1Type,in2Type);
  }
 else   if (t instanceof Class) {
    return privateGetForClass((Class<OUT>)t,typeHierarchy);
  }
  throw new InvalidTypesException("Type Information could not be created.");
}
