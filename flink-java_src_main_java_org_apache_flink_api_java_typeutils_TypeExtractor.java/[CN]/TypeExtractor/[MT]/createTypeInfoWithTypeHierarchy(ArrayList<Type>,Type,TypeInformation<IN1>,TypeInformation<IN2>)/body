{
  if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>)t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>)((ParameterizedType)t).getRawType()))) {
    Type curT=t;
    if (curT instanceof Class<?> && ((Class<?>)curT).equals(Tuple.class)) {
      throw new InvalidTypesException("Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.");
    }
    while (!(curT instanceof ParameterizedType && ((Class<?>)((ParameterizedType)curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>)curT).getSuperclass().equals(Tuple.class))) {
      typeHierarchy.add(curT);
      if (curT instanceof ParameterizedType) {
        curT=((Class<?>)((ParameterizedType)curT).getRawType()).getGenericSuperclass();
      }
 else {
        curT=((Class<?>)curT).getGenericSuperclass();
      }
    }
    if (curT instanceof Class<?>) {
      throw new InvalidTypesException("Tuple needs to be parameterized by using generics.");
    }
    ParameterizedType tupleChild=(ParameterizedType)curT;
    Type[] subtypes=new Type[tupleChild.getActualTypeArguments().length];
    for (int i=0; i < subtypes.length; i++) {
      if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
        subtypes[i]=materializeTypeVariable(typeHierarchy,(TypeVariable<?>)tupleChild.getActualTypeArguments()[i]);
      }
 else {
        subtypes[i]=tupleChild.getActualTypeArguments()[i];
      }
    }
    TypeInformation<?>[] tupleSubTypes=new TypeInformation<?>[subtypes.length];
    for (int i=0; i < subtypes.length; i++) {
      if (subtypes[i] instanceof TypeVariable<?>) {
        tupleSubTypes[i]=createTypeInfoFromInputs((TypeVariable<?>)subtypes[i],typeHierarchy,in1Type,in2Type);
        if (tupleSubTypes[i] == null) {
          throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>)subtypes[i]).getName() + "' in '"+ ((TypeVariable<?>)subtypes[i]).getGenericDeclaration()+ "' could not be determined. This is most likely a type erasure problem. "+ "The type extraction currently supports types with generic variables only in cases where "+ "all variables in the return type can be deduced from the input type(s).");
        }
      }
 else {
        tupleSubTypes[i]=createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy),subtypes[i],in1Type,in2Type);
      }
    }
    Class<?> tAsClass=null;
    if (t instanceof Class<?>) {
      tAsClass=(Class<?>)t;
    }
 else     if (t instanceof ParameterizedType) {
      tAsClass=(Class<? extends Tuple>)((ParameterizedType)t).getRawType();
    }
    Preconditions.checkNotNull(tAsClass,"t has a unexpected type");
    int fieldCount=countFieldsInClass(tAsClass);
    if (fieldCount != tupleSubTypes.length) {
      return (TypeInformation<OUT>)analyzePojo(tAsClass,new ArrayList<Type>(),null);
    }
    return new TupleTypeInfo(tAsClass,tupleSubTypes);
  }
 else   if (t instanceof TypeVariable) {
    Type typeVar=materializeTypeVariable(typeHierarchy,(TypeVariable<?>)t);
    if (!(typeVar instanceof TypeVariable)) {
      return createTypeInfoWithTypeHierarchy(typeHierarchy,typeVar,in1Type,in2Type);
    }
 else {
      TypeInformation<OUT> typeInfo=(TypeInformation<OUT>)createTypeInfoFromInputs((TypeVariable<?>)t,typeHierarchy,in1Type,in2Type);
      if (typeInfo != null) {
        return typeInfo;
      }
 else {
        throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>)t).getName() + "' in '"+ ((TypeVariable<?>)t).getGenericDeclaration()+ "' could not be determined. This is most likely a type erasure problem. "+ "The type extraction currently supports types with generic variables only in cases where "+ "all variables in the return type can be deduced from the input type(s).");
      }
    }
  }
 else   if (t instanceof GenericArrayType) {
    GenericArrayType genericArray=(GenericArrayType)t;
    Type componentType=genericArray.getGenericComponentType();
    if (componentType instanceof Class) {
      Class<?> componentClass=(Class<?>)componentType;
      String className;
      if (componentClass.isPrimitive()) {
        className=encodePrimitiveClass(componentClass);
      }
 else {
        className="L" + componentClass.getName() + ";";
      }
      Class<OUT> classArray=null;
      try {
        classArray=(Class<OUT>)Class.forName("[" + className);
      }
 catch (      ClassNotFoundException e) {
        throw new InvalidTypesException("Could not convert GenericArrayType to Class.");
      }
      return getForClass(classArray);
    }
    TypeInformation<?> componentInfo=createTypeInfoWithTypeHierarchy(typeHierarchy,genericArray.getGenericComponentType(),in1Type,in2Type);
    return ObjectArrayTypeInfo.getInfoFor(t,componentInfo);
  }
 else   if (t instanceof ParameterizedType) {
    return privateGetForClass((Class<OUT>)((ParameterizedType)t).getRawType(),typeHierarchy,(ParameterizedType)t);
  }
 else   if (t instanceof Class) {
    return privateGetForClass((Class<OUT>)t,new ArrayList<Type>());
  }
  throw new InvalidTypesException("Type Information could not be created.");
}
