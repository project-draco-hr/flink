{
  if (!this.type.isTupleType()) {
    throw new InvalidProgramException("Specifying order keys via field positions is only valid for tuple data types");
  }
  if (field >= this.type.getArity()) {
    throw new InvalidProgramException("Order key out of tuple bounds.");
  }
  Keys.ExpressionKeys<T> ek;
  try {
    ek=new Keys.ExpressionKeys<T>(new int[]{field},this.type);
  }
 catch (  IllegalArgumentException iae) {
    throw new InvalidProgramException("Invalid specification of field expression.",iae);
  }
  int[] flatKeys=ek.computeLogicalKeyPositions();
  if (this.sortKeyPositions == null) {
    this.sortKeyPositions=flatKeys;
    this.sortOrders=new Order[flatKeys.length];
    Arrays.fill(this.sortOrders,order);
  }
 else {
    int oldLength=this.sortKeyPositions.length;
    int newLength=oldLength + flatKeys.length;
    this.sortKeyPositions=Arrays.copyOf(this.sortKeyPositions,newLength);
    this.sortOrders=Arrays.copyOf(this.sortOrders,newLength);
    for (int i=0; i < flatKeys.length; i++) {
      this.sortKeyPositions[oldLength + i]=flatKeys[i];
      this.sortOrders[oldLength + i]=order;
    }
  }
  return this;
}
