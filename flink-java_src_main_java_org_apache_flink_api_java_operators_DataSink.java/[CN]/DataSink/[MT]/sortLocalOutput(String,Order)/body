{
  int numFields;
  int[] fields;
  Order[] orders;
  if (this.type instanceof CompositeType) {
    Keys.ExpressionKeys<T> ek;
    try {
      isValidSortKeyType(fieldExpression);
      ek=new Keys.ExpressionKeys<T>(new String[]{fieldExpression},this.type);
    }
 catch (    IllegalArgumentException iae) {
      throw new InvalidProgramException("Invalid specification of field expression.",iae);
    }
    fields=ek.computeLogicalKeyPositions();
    numFields=fields.length;
    orders=new Order[numFields];
    Arrays.fill(orders,order);
  }
 else {
    fieldExpression=fieldExpression.trim();
    if (!(fieldExpression.equals("*") || fieldExpression.equals("_"))) {
      throw new InvalidProgramException("Output sorting of non-composite types can only be defined on the full type. " + "Use a field wildcard for that (\"*\" or \"_\")");
    }
 else {
      isValidSortKeyType(fieldExpression);
      numFields=1;
      fields=new int[]{0};
      orders=new Order[]{order};
    }
  }
  if (this.sortKeyPositions == null) {
    this.sortKeyPositions=fields;
    this.sortOrders=orders;
  }
 else {
    int oldLength=this.sortKeyPositions.length;
    int newLength=oldLength + numFields;
    this.sortKeyPositions=Arrays.copyOf(this.sortKeyPositions,newLength);
    this.sortOrders=Arrays.copyOf(this.sortOrders,newLength);
    for (int i=0; i < numFields; i++) {
      this.sortKeyPositions[oldLength + i]=fields[i];
      this.sortOrders[oldLength + i]=orders[i];
    }
  }
  return this;
}
