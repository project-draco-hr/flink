{
  ExecutionPipeline pipeline=vertex.getExecutionPipeline();
  if (pipeline == null) {
    pipeline=new ExecutionPipeline();
    vertex.setExecutionPipeline(pipeline);
  }
  alreadyVisited.add(vertex);
  final Environment env=vertex.getEnvironment();
  if (forward) {
    final int numberOfOutputGates=env.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=env.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
 else         if (channelType == ChannelType.INMEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          recurse=true;
        }
        if (channelType == ChannelType.INMEMORY) {
          connectedVertex.setExecutionPipeline(pipeline);
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,true,alreadyVisited);
        }
      }
    }
  }
 else {
    final int numberOfInputGates=env.getNumberOfInputGates();
    for (int i=0; i < numberOfInputGates; ++i) {
      final InputGate<? extends Record> inputGate=env.getInputGate(i);
      final ChannelType channelType=inputGate.getChannelType();
      final int numberOfInputChannels=inputGate.getNumberOfInputChannels();
      for (int j=0; j < numberOfInputChannels; ++j) {
        final AbstractInputChannel<? extends Record> inputChannel=inputGate.getInputChannel(j);
        final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(inputChannel.getConnectedChannelID());
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
 else         if (channelType == ChannelType.INMEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          recurse=true;
        }
        if (channelType == ChannelType.INMEMORY) {
          connectedVertex.setExecutionPipeline(pipeline);
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,false,alreadyVisited);
        }
      }
    }
  }
}
