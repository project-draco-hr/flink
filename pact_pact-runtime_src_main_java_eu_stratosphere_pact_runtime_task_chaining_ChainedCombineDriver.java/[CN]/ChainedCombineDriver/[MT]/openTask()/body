{
  final Configuration stubConfig=this.config.getStubParameters();
  stubConfig.setInteger("pact.parallel.task.id",this.parent.getEnvironment().getIndexInSubtaskGroup());
  stubConfig.setInteger("pact.parallel.task.count",this.parent.getEnvironment().getCurrentNumberOfSubtasks());
  if (this.parent.getEnvironment().getTaskName() != null) {
    stubConfig.setString("pact.parallel.task.name",this.parent.getEnvironment().getTaskName());
  }
  RegularPactTask.openUserCode(this.combiner,stubConfig);
  final long availableMemory=this.config.getMemorySize();
  LocalStrategy ls=config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case COMBININGSORT:
    strategyMinMem=MIN_REQUIRED_MEMORY;
  break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException("The Combine task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ strategyMinMem+ " bytes.");
}
final MemoryManager memoryManager=this.parent.getEnvironment().getMemoryManager();
final TypeSerializer<T> serializer;
final TypeComparator<T> comparator;
try {
final Class<? extends TypeSerializerFactory<T>> serializerFactoryClazz=this.config.getSerializerFactoryForInput(0,this.userCodeClassLoader);
final Class<? extends TypeComparatorFactory<T>> comparatorFactoryClazz=this.config.getComparatorFactoryForInput(0,this.userCodeClassLoader);
final TypeSerializerFactory<T> serializerFactory;
final TypeComparatorFactory<T> comparatorFactory;
if (serializerFactoryClazz == null) {
  @SuppressWarnings("unchecked") TypeSerializerFactory<T> pf=(TypeSerializerFactory<T>)PactRecordSerializerFactory.get();
  serializerFactory=pf;
}
 else {
  serializerFactory=InstantiationUtil.instantiate(serializerFactoryClazz,TypeSerializerFactory.class);
}
if (comparatorFactoryClazz == null) {
  @SuppressWarnings("unchecked") TypeComparatorFactory<T> pf=(TypeComparatorFactory<T>)PactRecordComparatorFactory.get();
  comparatorFactory=pf;
}
 else {
  comparatorFactory=InstantiationUtil.instantiate(comparatorFactoryClazz,TypeComparatorFactory.class);
}
serializer=serializerFactory.getSerializer();
try {
  comparator=comparatorFactory.createComparator(this.config.getConfigForInputParameters(0),this.userCodeClassLoader);
}
 catch (ClassNotFoundException cnfex) {
  throw new Exception("The comparator could not be created, because it cannot load dependent data types.",cnfex);
}
}
 catch (ClassNotFoundException cnfex) {
throw new Exception("The registered serializer/comparator factory could not be loaded.",cnfex);
}
switch (ls) {
case COMBININGSORT:
this.sorter=new AsynchronousPartialSorterCollector<T>(memoryManager,this.parent,serializer,comparator.duplicate(),availableMemory);
this.inputCollector=this.sorter.getInputCollector();
break;
default :
throw new RuntimeException("Invalid local strategy provided for CombineTask.");
}
this.combinerThread=new CombinerThread(this.sorter,serializer,comparator,this.combiner,this.outputCollector);
this.combinerThread.start();
if (this.parent != null) {
this.parent.userThreadStarted(this.combinerThread);
}
}
