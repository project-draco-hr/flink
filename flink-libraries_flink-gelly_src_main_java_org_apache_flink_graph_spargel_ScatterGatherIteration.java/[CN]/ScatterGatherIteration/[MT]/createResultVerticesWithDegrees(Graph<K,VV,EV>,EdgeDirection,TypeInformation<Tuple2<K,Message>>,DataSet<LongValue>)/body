{
  DataSet<Tuple2<K,Message>> messages;
  this.updateFunction.setOptDegrees(this.configuration.isOptDegrees());
  DataSet<Tuple2<K,Long>> inDegrees=graph.inDegrees();
  DataSet<Tuple2<K,Long>> outDegrees=graph.outDegrees();
  DataSet<Tuple3<K,Long,Long>> degrees=inDegrees.join(outDegrees).where(0).equalTo(0).with(new FlatJoinFunction<Tuple2<K,Long>,Tuple2<K,Long>,Tuple3<K,Long,Long>>(){
    @Override public void join(    Tuple2<K,Long> first,    Tuple2<K,Long> second,    Collector<Tuple3<K,Long,Long>> out){
      out.collect(new Tuple3<K,Long,Long>(first.f0,first.f1,second.f1));
    }
  }
).withForwardedFieldsFirst("f0;f1").withForwardedFieldsSecond("f1");
  DataSet<Vertex<K,Tuple3<VV,Long,Long>>> verticesWithDegrees=initialVertices.join(degrees).where(0).equalTo(0).with(new FlatJoinFunction<Vertex<K,VV>,Tuple3<K,Long,Long>,Vertex<K,Tuple3<VV,Long,Long>>>(){
    @Override public void join(    Vertex<K,VV> vertex,    Tuple3<K,Long,Long> degrees,    Collector<Vertex<K,Tuple3<VV,Long,Long>>> out) throws Exception {
      out.collect(new Vertex<K,Tuple3<VV,Long,Long>>(vertex.getId(),new Tuple3<VV,Long,Long>(vertex.getValue(),degrees.f1,degrees.f2)));
    }
  }
).withForwardedFieldsFirst("f0");
  TypeInformation<Vertex<K,Tuple3<VV,Long,Long>>> vertexTypes=verticesWithDegrees.getType();
  final DeltaIteration<Vertex<K,Tuple3<VV,Long,Long>>,Vertex<K,Tuple3<VV,Long,Long>>> iteration=verticesWithDegrees.iterateDelta(verticesWithDegrees,this.maximumNumberOfIterations,0);
  setUpIteration(iteration);
switch (messagingDirection) {
case IN:
    messages=buildMessagingFunctionVerticesWithDegrees(iteration,messageTypeInfo,1,0,numberOfVertices);
  break;
case OUT:
messages=buildMessagingFunctionVerticesWithDegrees(iteration,messageTypeInfo,0,0,numberOfVertices);
break;
case ALL:
messages=buildMessagingFunctionVerticesWithDegrees(iteration,messageTypeInfo,1,0,numberOfVertices).union(buildMessagingFunctionVerticesWithDegrees(iteration,messageTypeInfo,0,0,numberOfVertices));
break;
default :
throw new IllegalArgumentException("Illegal edge direction");
}
@SuppressWarnings({"unchecked","rawtypes"}) VertexUpdateUdf<K,Tuple3<VV,Long,Long>,Message> updateUdf=new VertexUpdateUdfVVWithDegrees(updateFunction,vertexTypes);
CoGroupOperator<?,?,Vertex<K,Tuple3<VV,Long,Long>>> updates=messages.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(updateUdf);
if (this.configuration != null && this.configuration.isOptNumVertices()) {
updates=updates.withBroadcastSet(numberOfVertices,"number of vertices");
}
configureUpdateFunction(updates);
return iteration.closeWith(updates,updates).map(new MapFunction<Vertex<K,Tuple3<VV,Long,Long>>,Vertex<K,VV>>(){
public Vertex<K,VV> map(Vertex<K,Tuple3<VV,Long,Long>> vertex){
return new Vertex<K,VV>(vertex.getId(),vertex.getValue().f0);
}
}
);
}
