{
  this.jobID=tdd.getJobID();
  this.taskName=tdd.getTaskName();
  this.invokableClass=tdd.getInvokableClass();
  this.jobConfiguration=tdd.getJobConfiguration();
  this.taskConfiguration=tdd.getTaskConfiguration();
  this.indexInSubtaskGroup=tdd.getIndexInSubtaskGroup();
  this.currentNumberOfSubtasks=tdd.getCurrentNumberOfSubtasks();
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.inputSplitProvider=inputSplitProvider;
  final int noogdd=tdd.getNumberOfOutputGateDescriptors();
  final int noigdd=tdd.getNumberOfInputGateDescriptors();
  this.unboundOutputGates=new ArrayDeque<GateDeploymentDescriptor>(noogdd);
  this.unboundInputGates=new ArrayDeque<GateDeploymentDescriptor>(noigdd);
  for (int i=0; i < noogdd; ++i) {
    this.unboundOutputGates.add(tdd.getOutputGateDescriptor(i));
  }
  for (int i=0; i < noigdd; ++i) {
    this.unboundInputGates.add(tdd.getInputGateDescriptor(i));
  }
  this.invokable=this.invokableClass.newInstance();
  this.invokable.setEnvironment(this);
  this.invokable.registerInputOutput();
  if (!this.unboundOutputGates.isEmpty() && LOG.isErrorEnabled()) {
    LOG.error("Inconsistency: " + this.unboundOutputGates.size() + " unbound output gate deployment descriptors left");
  }
  if (!this.unboundInputGates.isEmpty() && LOG.isErrorEnabled()) {
    LOG.error("Inconsistency: " + this.unboundInputGates.size() + " unbound input gate deployment descriptors left");
  }
  for (int i=0; i < noogdd; ++i) {
    final GateDeploymentDescriptor gdd=tdd.getOutputGateDescriptor(i);
    final OutputGate og=this.outputGates.get(i);
    final ChannelType channelType=gdd.getChannelType();
    final CompressionLevel compressionLevel=gdd.getCompressionLevel();
    final int nocdd=gdd.getNumberOfChannelDescriptors();
    for (int j=0; j < nocdd; ++j) {
      final ChannelDeploymentDescriptor cdd=gdd.getChannelDescriptor(j);
switch (channelType) {
case FILE:
        og.createFileOutputChannel(og,cdd.getOutputChannelID(),cdd.getInputChannelID(),compressionLevel);
      break;
case NETWORK:
    og.createNetworkOutputChannel(og,cdd.getOutputChannelID(),cdd.getInputChannelID(),compressionLevel);
  break;
case INMEMORY:
og.createInMemoryOutputChannel(og,cdd.getOutputChannelID(),cdd.getInputChannelID(),compressionLevel);
break;
default :
throw new IllegalStateException("Unknown channel type");
}
}
}
for (int i=0; i < noigdd; ++i) {
final GateDeploymentDescriptor gdd=tdd.getInputGateDescriptor(i);
final InputGate ig=this.inputGates.get(i);
final ChannelType channelType=gdd.getChannelType();
final CompressionLevel compressionLevel=gdd.getCompressionLevel();
final int nicdd=gdd.getNumberOfChannelDescriptors();
for (int j=0; j < nicdd; ++j) {
final ChannelDeploymentDescriptor cdd=gdd.getChannelDescriptor(j);
switch (channelType) {
case FILE:
ig.createFileInputChannel(ig,cdd.getInputChannelID(),cdd.getOutputChannelID(),compressionLevel);
break;
case NETWORK:
ig.createNetworkInputChannel(ig,cdd.getInputChannelID(),cdd.getOutputChannelID(),compressionLevel);
break;
case INMEMORY:
ig.createInMemoryInputChannel(ig,cdd.getInputChannelID(),cdd.getOutputChannelID(),compressionLevel);
break;
default :
throw new IllegalStateException("Unknown channel type");
}
}
}
}
