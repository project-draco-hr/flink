{
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException("invokableClassName is null");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException("Class " + invokableClassName + " not found in one of the supplied jar files: "+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    this.unboundOutputGateIDs.add(gateID);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    this.unboundInputGateIDs.add(gateID);
  }
  this.taskConfiguration=new Configuration();
  this.taskConfiguration.read(in);
  this.jobConfiguration=new Configuration();
  this.jobConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
  for (int i=0; i < numOuputGates; ++i) {
    final OutputGate<? extends Record> outputGate=this.outputGates.get(i);
    final int numberOfOutputChannels=in.readInt();
    for (int j=0; j < numberOfOutputChannels; ++j) {
      final ChannelID channelID=new ChannelID();
      channelID.read(in);
      final ChannelID connectedChannelID=new ChannelID();
      connectedChannelID.read(in);
      final ChannelType channelType=EnumUtils.readEnum(in,ChannelType.class);
      final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
      AbstractOutputChannel<? extends Record> outputChannel=null;
switch (channelType) {
case INMEMORY:
        outputChannel=outputGate.createInMemoryOutputChannel(channelID,compressionLevel);
      break;
case NETWORK:
    outputChannel=outputGate.createNetworkOutputChannel(channelID,compressionLevel);
  break;
case FILE:
outputChannel=outputGate.createFileOutputChannel(channelID,compressionLevel);
break;
}
if (outputChannel == null) {
throw new IOException("Unable to create output channel for channel ID " + channelID);
}
outputChannel.setConnectedChannelID(connectedChannelID);
}
}
for (int i=0; i < numInputGates; ++i) {
final InputGate<? extends Record> inputGate=this.inputGates.get(i);
final int numberOfInputChannels=in.readInt();
for (int j=0; j < numberOfInputChannels; ++j) {
final ChannelID channelID=new ChannelID();
channelID.read(in);
final ChannelID connectedChannelID=new ChannelID();
connectedChannelID.read(in);
final ChannelType channelType=EnumUtils.readEnum(in,ChannelType.class);
final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
AbstractInputChannel<? extends Record> inputChannel=null;
switch (channelType) {
case INMEMORY:
inputChannel=inputGate.createInMemoryInputChannel(channelID,compressionLevel);
break;
case NETWORK:
inputChannel=inputGate.createNetworkInputChannel(channelID,compressionLevel);
break;
case FILE:
inputChannel=inputGate.createFileInputChannel(channelID,compressionLevel);
break;
}
if (inputChannel == null) {
throw new IOException("Unable to create output channel for channel ID " + channelID);
}
inputChannel.setConnectedChannelID(connectedChannelID);
}
}
}
