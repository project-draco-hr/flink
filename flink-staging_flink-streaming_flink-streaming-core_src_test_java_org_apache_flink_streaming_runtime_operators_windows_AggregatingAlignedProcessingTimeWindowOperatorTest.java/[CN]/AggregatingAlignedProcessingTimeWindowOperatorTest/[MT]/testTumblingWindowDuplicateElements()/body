{
  final ScheduledExecutorService timerService=Executors.newSingleThreadScheduledExecutor();
  try {
    final int windowSize=50;
    final CollectingOutput<Integer> out=new CollectingOutput<>(windowSize);
    final StreamingRuntimeContext mockContext=mock(StreamingRuntimeContext.class);
    when(mockContext.getTaskName()).thenReturn("Test task name");
    final Object lock=new Object();
    doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocationOnMock) throws Throwable {
        final Long timestamp=(Long)invocationOnMock.getArguments()[0];
        final Triggerable target=(Triggerable)invocationOnMock.getArguments()[1];
        timerService.schedule(new Callable<Object>(){
          @Override public Object call() throws Exception {
synchronized (lock) {
              target.trigger(timestamp);
            }
            return null;
          }
        }
,timestamp - System.currentTimeMillis(),TimeUnit.MILLISECONDS);
        return null;
      }
    }
).when(mockContext).registerTimer(anyLong(),any(Triggerable.class));
    AggregatingProcessingTimeWindowOperator<Integer,Integer> op=new AggregatingProcessingTimeWindowOperator<>(sumFunction,identitySelector,windowSize,windowSize);
    op.setup(out,mockContext);
    op.open(new Configuration());
    final int numWindows=10;
    long previousNextTime=0;
    int window=1;
    while (window <= numWindows) {
      long nextTime=op.getNextEvaluationTime();
      int val=((int)nextTime) ^ ((int)(nextTime >>> 32));
synchronized (lock) {
        op.processElement(new StreamRecord<Integer>(val));
      }
      if (nextTime != previousNextTime) {
        window++;
        previousNextTime=nextTime;
      }
      Thread.sleep(1);
    }
    op.close();
    op.dispose();
    List<Integer> result=out.getElements();
    assertTrue(result.size() >= numWindows && result.size() <= 2 * numWindows);
    HashSet<Integer> set=new HashSet<>(result);
    assertTrue(set.size() == 10 || set.size() == 11);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    timerService.shutdown();
  }
}
