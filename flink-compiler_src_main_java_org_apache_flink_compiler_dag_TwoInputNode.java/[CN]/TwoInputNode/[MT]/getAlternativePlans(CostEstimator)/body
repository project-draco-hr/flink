{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  boolean childrenSkippedDueToReplicatedInput=false;
  final List<? extends PlanNode> subPlans1=getFirstPredecessorNode().getAlternativePlans(estimator);
  final List<? extends PlanNode> subPlans2=getSecondPredecessorNode().getAlternativePlans(estimator);
  final Set<RequestedGlobalProperties> intGlobal1=this.input1.getInterestingProperties().getGlobalProperties();
  final Set<RequestedGlobalProperties> intGlobal2=this.input2.getInterestingProperties().getGlobalProperties();
  final List<Set<? extends NamedChannel>> broadcastPlanChannels=new ArrayList<Set<? extends NamedChannel>>();
  List<PactConnection> broadcastConnections=getBroadcastConnections();
  List<String> broadcastConnectionNames=getBroadcastConnectionNames();
  for (int i=0; i < broadcastConnections.size(); i++) {
    PactConnection broadcastConnection=broadcastConnections.get(i);
    String broadcastConnectionName=broadcastConnectionNames.get(i);
    List<PlanNode> broadcastPlanCandidates=broadcastConnection.getSource().getAlternativePlans(estimator);
    HashSet<NamedChannel> broadcastChannels=new HashSet<NamedChannel>(broadcastPlanCandidates.size());
    for (    PlanNode plan : broadcastPlanCandidates) {
      final NamedChannel c=new NamedChannel(broadcastConnectionName,plan);
      c.setShipStrategy(ShipStrategyType.BROADCAST);
      broadcastChannels.add(c);
    }
    broadcastPlanChannels.add(broadcastChannels);
  }
  final GlobalPropertiesPair[] allGlobalPairs;
  final LocalPropertiesPair[] allLocalPairs;
{
    Set<GlobalPropertiesPair> pairsGlob=new HashSet<GlobalPropertiesPair>();
    Set<LocalPropertiesPair> pairsLoc=new HashSet<LocalPropertiesPair>();
    for (    OperatorDescriptorDual ods : getProperties()) {
      pairsGlob.addAll(ods.getPossibleGlobalProperties());
      pairsLoc.addAll(ods.getPossibleLocalProperties());
    }
    allGlobalPairs=(GlobalPropertiesPair[])pairsGlob.toArray(new GlobalPropertiesPair[pairsGlob.size()]);
    allLocalPairs=(LocalPropertiesPair[])pairsLoc.toArray(new LocalPropertiesPair[pairsLoc.size()]);
  }
  final ArrayList<PlanNode> outputPlans=new ArrayList<PlanNode>();
  final int dop=getDegreeOfParallelism();
  final int inDop1=getFirstPredecessorNode().getDegreeOfParallelism();
  final int inDop2=getSecondPredecessorNode().getDegreeOfParallelism();
  final boolean dopChange1=dop != inDop1;
  final boolean dopChange2=dop != inDop2;
  for (  PlanNode child1 : subPlans1) {
    if (child1.getGlobalProperties().isFullyReplicated()) {
      if (dopChange1) {
        childrenSkippedDueToReplicatedInput=true;
        continue;
      }
 else {
        this.input1.setShipStrategy(ShipStrategyType.FORWARD);
      }
    }
    for (    PlanNode child2 : subPlans2) {
      if (child2.getGlobalProperties().isFullyReplicated()) {
        if (dopChange2) {
          childrenSkippedDueToReplicatedInput=true;
          continue;
        }
 else {
          this.input2.setShipStrategy(ShipStrategyType.FORWARD);
        }
      }
      if (!areBranchCompatible(child1,child2)) {
        continue;
      }
      for (      RequestedGlobalProperties igps1 : intGlobal1) {
        final Channel c1=new Channel(child1,this.input1.getMaterializationMode());
        if (this.input1.getShipStrategy() == null) {
          igps1.parameterizeChannel(c1,dopChange1);
          if (dopChange1 && !c1.getShipStrategy().isNetworkStrategy()) {
            c1.getGlobalProperties().reset();
          }
        }
 else {
          if (this.keys1 != null) {
            c1.setShipStrategy(this.input1.getShipStrategy(),this.keys1.toFieldList());
          }
 else {
            c1.setShipStrategy(this.input1.getShipStrategy());
          }
          if (dopChange1) {
            c1.adjustGlobalPropertiesForFullParallelismChange();
          }
        }
        for (        RequestedGlobalProperties igps2 : intGlobal2) {
          final Channel c2=new Channel(child2,this.input2.getMaterializationMode());
          if (this.input2.getShipStrategy() == null) {
            igps2.parameterizeChannel(c2,dopChange2);
            if (dopChange2 && !c2.getShipStrategy().isNetworkStrategy()) {
              c2.getGlobalProperties().reset();
            }
          }
 else {
            if (this.keys2 != null) {
              c2.setShipStrategy(this.input2.getShipStrategy(),this.keys2.toFieldList());
            }
 else {
              c2.setShipStrategy(this.input2.getShipStrategy());
            }
            if (dopChange2) {
              c2.adjustGlobalPropertiesForFullParallelismChange();
            }
          }
          outer:           for (          GlobalPropertiesPair gpp : allGlobalPairs) {
            if (gpp.getProperties1().isMetBy(c1.getGlobalProperties()) && gpp.getProperties2().isMetBy(c2.getGlobalProperties())) {
              for (              OperatorDescriptorDual desc : getProperties()) {
                if (desc.areCompatible(gpp.getProperties1(),gpp.getProperties2(),c1.getGlobalProperties(),c2.getGlobalProperties())) {
                  Channel c1Clone=c1.clone();
                  c1Clone.setRequiredGlobalProps(gpp.getProperties1());
                  c2.setRequiredGlobalProps(gpp.getProperties2());
                  addLocalCandidates(c1Clone,c2,broadcastPlanChannels,igps1,igps2,outputPlans,allLocalPairs,estimator);
                  break outer;
                }
              }
            }
          }
          if (this.input2.getShipStrategy() != null) {
            break;
          }
        }
        if (this.input1.getShipStrategy() != null) {
          break;
        }
      }
    }
  }
  if (outputPlans.isEmpty()) {
    if (childrenSkippedDueToReplicatedInput) {
      throw new CompilerException("No plan meeting the requirements could be created @ " + this + ". Most likely reason: Invalid use of replicated input.");
    }
 else {
      throw new CompilerException("No plan meeting the requirements could be created @ " + this + ". Most likely reason: Too restrictive plan hints.");
    }
  }
  for (  PlanNode node : outputPlans) {
    estimator.costOperator(node);
  }
  prunePlanAlternatives(outputPlans);
  outputPlans.trimToSize();
  this.cachedPlans=outputPlans;
  return outputPlans;
}
