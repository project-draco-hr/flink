{
  if (this.taskVertices.isEmpty()) {
    return Collections.emptyList();
  }
  List<AbstractJobVertex> sorted=new ArrayList<AbstractJobVertex>(this.taskVertices.size());
  Set<AbstractJobVertex> remaining=new LinkedHashSet<AbstractJobVertex>(this.taskVertices.values());
{
    Iterator<AbstractJobVertex> iter=remaining.iterator();
    while (iter.hasNext()) {
      AbstractJobVertex vertex=iter.next();
      if (vertex.hasNoConnectedInputs()) {
        sorted.add(vertex);
        iter.remove();
      }
    }
  }
  int startNodePos=0;
  while (!remaining.isEmpty()) {
    if (startNodePos >= sorted.size()) {
      throw new InvalidProgramException("The job graph is cyclic.");
    }
    AbstractJobVertex current=sorted.get(startNodePos++);
    addNodesThatHaveNoNewPredecessors(current,sorted,remaining);
  }
  return sorted;
}
