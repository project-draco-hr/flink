{
  if (inputData.isEmpty()) {
    return Collections.emptyList();
  }
  ReduceFunction<T> function=this.userFunction.getUserCodeObject();
  UnaryOperatorInformation<T,T> operatorInfo=getOperatorInfo();
  TypeInformation<T> inputType=operatorInfo.getInputType();
  int[] inputColumns=getKeyColumns(0);
  if (!(inputType instanceof CompositeType) && inputColumns.length > 0) {
    throw new InvalidProgramException("Grouping is only possible on composite types.");
  }
  FunctionUtils.setFunctionRuntimeContext(function,ctx);
  FunctionUtils.openFunction(function,this.parameters);
  TypeSerializer<T> serializer=getOperatorInfo().getInputType().createSerializer();
  if (inputColumns.length > 0) {
    boolean[] inputOrderings=new boolean[inputColumns.length];
    TypeComparator<T> inputComparator=((CompositeType<T>)inputType).createComparator(inputColumns,inputOrderings);
    Map<TypeComparable<T>,T> aggregateMap=new HashMap<TypeComparable<T>,T>(inputData.size() / 10);
    for (    T next : inputData) {
      TypeComparable<T> wrapper=new TypeComparable<T>(next,inputComparator);
      T existing=aggregateMap.get(wrapper);
      T result;
      if (mutableObjectSafeMode) {
        if (existing != null) {
          result=function.reduce(existing,serializer.copy(next));
        }
 else {
          result=next;
        }
        result=serializer.copy(result);
      }
 else {
        if (existing != null) {
          result=function.reduce(existing,next);
        }
 else {
          result=next;
        }
      }
      aggregateMap.put(wrapper,result);
    }
    FunctionUtils.closeFunction(function);
    return new ArrayList<T>(aggregateMap.values());
  }
 else {
    T aggregate=inputData.get(0);
    if (mutableObjectSafeMode) {
      aggregate=serializer.copy(aggregate);
      for (int i=1; i < inputData.size(); i++) {
        T next=function.reduce(aggregate,serializer.copy(inputData.get(i)));
        aggregate=serializer.copy(next);
      }
    }
 else {
      for (int i=1; i < inputData.size(); i++) {
        aggregate=function.reduce(aggregate,inputData.get(i));
      }
    }
    FunctionUtils.setFunctionRuntimeContext(function,ctx);
    return Collections.singletonList(aggregate);
  }
}
