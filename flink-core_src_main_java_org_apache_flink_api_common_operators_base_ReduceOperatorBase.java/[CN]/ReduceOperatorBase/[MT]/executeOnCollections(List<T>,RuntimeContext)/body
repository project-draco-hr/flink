{
  ReduceFunction<T> function=this.userFunction.getUserCodeObject();
  UnaryOperatorInformation<T,T> operatorInfo=getOperatorInfo();
  TypeInformation<T> inputType=operatorInfo.getInputType();
  if (!(inputType instanceof CompositeType)) {
    throw new InvalidProgramException("Input type of groupReduce operation must be" + " composite type.");
  }
  FunctionUtils.setFunctionRuntimeContext(function,ctx);
  FunctionUtils.openFunction(function,this.parameters);
  int[] inputColumns=getKeyColumns(0);
  if (inputColumns.length > 0) {
    boolean[] inputOrderings=new boolean[inputColumns.length];
    TypeComparator<T> inputComparator=((CompositeType<T>)inputType).createComparator(inputColumns,inputOrderings);
    Map<TypeComparable<T>,T> aggregateMap=new HashMap<TypeComparable<T>,T>(inputData.size() / 10);
    for (    T next : inputData) {
      TypeComparable<T> wrapper=new TypeComparable<T>(next,inputComparator);
      T existing=aggregateMap.get(wrapper);
      T result;
      if (existing != null) {
        result=function.reduce(existing,next);
      }
 else {
        result=next;
      }
      aggregateMap.put(wrapper,result);
    }
    List<T> result=new ArrayList<T>(aggregateMap.values().size());
    result.addAll(aggregateMap.values());
    FunctionUtils.closeFunction(function);
    return result;
  }
 else {
    T aggregate=inputData.get(0);
    for (int i=1; i < inputData.size(); i++) {
      aggregate=function.reduce(aggregate,inputData.get(i));
    }
    List<T> result=new ArrayList<T>(1);
    result.add(aggregate);
    FunctionUtils.setFunctionRuntimeContext(function,ctx);
    return result;
  }
}
