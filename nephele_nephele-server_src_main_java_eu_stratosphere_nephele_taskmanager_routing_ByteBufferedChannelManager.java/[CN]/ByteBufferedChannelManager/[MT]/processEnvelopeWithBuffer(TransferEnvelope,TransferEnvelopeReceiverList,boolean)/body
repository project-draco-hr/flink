{
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      LOG.error("Expected receiver list to have exactly one element");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      try {
        sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
      }
  finally {
        recycleBuffer(transferEnvelope);
      }
      return;
    }
    if (!cc.isInputChannel()) {
      LOG.error("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  try {
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
      for (      final ChannelID localReceiver : localReceivers) {
        final ChannelContext cc=this.registeredChannels.get(localReceiver);
        if (cc == null) {
          sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
          continue;
        }
        if (!cc.isInputChannel()) {
          LOG.error("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
          continue;
        }
        final InputChannelContext inputChannelContext=(InputChannelContext)cc;
        final Buffer destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        try {
          srcBuffer.copyToBuffer(destBuffer);
        }
 catch (        IOException e) {
          destBuffer.recycleBuffer();
          throw e;
        }
        final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
        dup.setBuffer(destBuffer);
        inputChannelContext.queueTransferEnvelope(dup);
      }
    }
    if (receiverList.hasRemoteReceivers()) {
      final List<RemoteReceiver> remoteReceivers=receiverList.getRemoteReceivers();
      for (      final RemoteReceiver remoteReceiver : remoteReceivers) {
        final TransferEnvelope dup=transferEnvelope.duplicate();
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,dup);
      }
    }
  }
  finally {
    srcBuffer.recycleBuffer();
  }
}
