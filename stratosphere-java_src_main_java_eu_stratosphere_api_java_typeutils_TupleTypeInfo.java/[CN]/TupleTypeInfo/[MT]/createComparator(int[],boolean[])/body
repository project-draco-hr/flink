{
  if (logicalKeyFields == null || orders == null || logicalKeyFields.length != orders.length || logicalKeyFields.length > types.length) {
    throw new IllegalArgumentException();
  }
  if (logicalKeyFields.length == 1 && logicalKeyFields[0] == 0) {
    return createLeadingFieldComparator(orders[0],types[0]);
  }
  int maxKey=logicalKeyFields[0];
  for (  int key : logicalKeyFields) {
    if (key > maxKey) {
      maxKey=key;
    }
  }
  boolean[] isKey=new boolean[maxKey + 1];
  for (  int key : logicalKeyFields) {
    isKey[key]=true;
  }
  TypeComparator<?>[] fieldComparators=new TypeComparator<?>[logicalKeyFields.length];
  TypeSerializer<?>[] fieldSerializers=new TypeSerializer<?>[maxKey + 1 - logicalKeyFields.length];
  int cIndex=0;
  int sIndex=0;
  for (int i=0; i < maxKey + 1; i++) {
    if (isKey[i]) {
      if (types[i].isKeyType() && types[i] instanceof AtomicType) {
        fieldComparators[cIndex]=((AtomicType<?>)types[i]).createComparator(orders[cIndex]);
        cIndex++;
      }
 else {
        throw new IllegalArgumentException("The field at position " + i + " ("+ types[i]+ ") is no atomic key type.");
      }
    }
 else {
      fieldSerializers[sIndex]=types[i].createSerializer();
      sIndex++;
    }
  }
  return new TupleComparator<T>(logicalKeyFields,fieldComparators,fieldSerializers);
}
