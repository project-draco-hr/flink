{
  if (logicalKeyFields == null || orders == null || logicalKeyFields.length != orders.length || logicalKeyFields.length > types.length) {
    throw new IllegalArgumentException();
  }
  if (logicalKeyFields.length == 1 && logicalKeyFields[0] == 0) {
    return createLeadingFieldComparator(orders[0],types[0]);
  }
  int maxKey=-1;
  for (  int key : logicalKeyFields) {
    maxKey=Math.max(key,maxKey);
  }
  if (maxKey >= this.types.length) {
    throw new IllegalArgumentException("The key position " + maxKey + " is out of range for Tuple"+ types.length);
  }
  TypeComparator<?>[] fieldComparators=new TypeComparator<?>[logicalKeyFields.length];
  for (int i=0; i < logicalKeyFields.length; i++) {
    int keyPos=logicalKeyFields[i];
    if (types[keyPos].isKeyType() && types[keyPos] instanceof AtomicType) {
      fieldComparators[i]=((AtomicType<?>)types[keyPos]).createComparator(orders[i]);
    }
 else {
      throw new IllegalArgumentException("The field at position " + i + " ("+ types[keyPos]+ ") is no atomic key type.");
    }
  }
  TypeSerializer<?>[] fieldSerializers=new TypeSerializer<?>[maxKey + 1];
  for (int i=0; i <= maxKey; i++) {
    fieldSerializers[i]=types[i].createSerializer();
  }
  return new TupleComparator<T>(logicalKeyFields,fieldComparators,fieldSerializers);
}
