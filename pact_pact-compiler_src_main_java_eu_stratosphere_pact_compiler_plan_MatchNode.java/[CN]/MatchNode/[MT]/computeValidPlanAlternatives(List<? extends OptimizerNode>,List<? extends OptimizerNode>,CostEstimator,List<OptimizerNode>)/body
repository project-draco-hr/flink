{
  for (  OptimizerNode subPlan1 : altSubPlans1) {
    for (    OptimizerNode subPlan2 : altSubPlans2) {
      if (!areBranchCompatible(subPlan1,subPlan2)) {
        continue;
      }
      ShipStrategy ss1=this.input1.getShipStrategy();
      ShipStrategy ss2=this.input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1.type() == ShipStrategyType.NONE) {
        gp1=subPlan1.getGlobalPropertiesForParent(this);
        if (ss2.type() == ShipStrategyType.NONE) {
          gp2=subPlan2.getGlobalPropertiesForParent(this);
          if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=new ForwardSS();
          }
          if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isComputablyPartitioned()) {
            if (!partitioningIsOnRightFields(gp1,0) || !gp1.getPartitioning().isComputablyPartitioned()) {
              ss2=new ForwardSS();
            }
 else {
              if (gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning()) && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
                ss2=new ForwardSS();
              }
 else {
                if (gp1.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,new ForwardSS(),new PartitionHashSS(this.keySet2),estimator);
                }
 else                 if (gp1.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,new ForwardSS(),new PartitionRangeSS(this.keySet2),estimator);
                }
                if (gp2.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionHashSS(this.keySet1),new ForwardSS(),estimator);
                }
 else                 if (gp2.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionRangeSS(this.keySet1),new ForwardSS(),estimator);
                }
                continue;
              }
            }
          }
          if (ss1.type() == ShipStrategyType.FORWARD) {
            if (ss2.type() == ShipStrategyType.FORWARD) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitioningProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionRangeSS(this.keySet1),new PartitionRangeSS(this.keySet2),estimator);
              }
            }
 else {
              if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,new PartitionHashSS(this.keySet2),estimator);
              }
 else               if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,new PartitionRangeSS(this.keySet2),estimator);
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionHashSS(this.keySet1),new PartitionHashSS(this.keySet2),estimator);
              }
 else {
                throw new CompilerException("Invalid partitioning property for input 1 of match '" + getPactContract().getName() + "'.");
              }
            }
          }
 else           if (ss2.type() == ShipStrategyType.FORWARD) {
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionHashSS(this.keySet1),ss2,estimator);
            }
 else             if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionRangeSS(this.keySet1),ss2,estimator);
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionHashSS(this.keySet1),new PartitionHashSS(this.keySet2),estimator);
            }
 else {
              throw new CompilerException("Invalid partitioning property for input 2 of match '" + getPactContract().getName() + "'.");
            }
          }
 else {
            createLocalAlternatives(outputPlans,subPlan1,subPlan2,new PartitionHashSS(this.keySet1),new PartitionHashSS(this.keySet2),estimator);
            if (haveValidOutputEstimates(subPlan1) && haveValidOutputEstimates(subPlan2)) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,new BroadcastSS(),new ForwardSS(),estimator);
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,new ForwardSS(),new BroadcastSS(),estimator);
            }
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
switch (ss2.type()) {
case BROADCAST:
            ss1=new ForwardSS();
          ;
        break;
case FORWARD:
      if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isPartitioned()) {
        if (gp2.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) {
          ss1=new PartitionHashSS(this.keySet1);
        }
 else         if (gp2.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) {
          ss1=new PartitionRangeSS(this.keySet1);
        }
 else {
          throw new CompilerException();
        }
      }
 else {
        ss1=new BroadcastSS();
      }
    break;
case PARTITION_HASH:
  ss1=(partitioningIsOnSameSubkey(gp1.getPartitionedFields(),this.keySet2) && gp1.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) ? new ForwardSS() : new PartitionHashSS(this.keySet1);
break;
case PARTITION_RANGE:
ss1=(partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) ? new ForwardSS() : new PartitionRangeSS(this.keySet1);
break;
default :
throw new CompilerException("Invalid fixed shipping strategy '" + ss2.name() + "' for match contract '"+ getPactContract().getName()+ "'.");
}
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
}
 else if (ss2.type() == ShipStrategyType.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
gp2=subPlan2.getGlobalPropertiesForParent(this);
switch (ss1.type()) {
case BROADCAST:
ss2=new ForwardSS();
;
break;
case FORWARD:
if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) {
ss2=new PartitionHashSS(this.keySet2);
}
 else if (gp1.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) {
ss2=new PartitionRangeSS(this.keySet2);
}
 else {
throw new CompilerException();
}
}
 else {
ss2=new BroadcastSS();
}
break;
case PARTITION_HASH:
ss2=(partitioningIsOnSameSubkey(this.keySet1,gp2.getPartitionedFields()) && partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitioningProperty.HASH_PARTITIONED) ? new ForwardSS() : new PartitionHashSS(this.keySet2);
break;
case PARTITION_RANGE:
ss2=(partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitioningProperty.RANGE_PARTITIONED) ? new ForwardSS() : new PartitionRangeSS(this.keySet2);
break;
default :
throw new CompilerException("Invalid fixed shipping strategy '" + ss1.name() + "' for match contract '"+ getPactContract().getName()+ "'.");
}
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
if ((ss1.type() == ShipStrategyType.BROADCAST && ss2.type() != ShipStrategyType.BROADCAST) || (ss1.type() != ShipStrategyType.BROADCAST && ss2.type() == ShipStrategyType.BROADCAST)) {
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning() && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
}
