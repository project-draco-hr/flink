{
  for (  List<OptimizerNode> predList1 : alternativeSubPlanCominations1) {
    for (    List<OptimizerNode> predList2 : alternativeSubPlanCominations2) {
      if (!areBranchCompatible(predList1,predList2)) {
        continue;
      }
      ShipStrategy ss1=checkShipStrategyCompatibility(this.input1);
      if (ss1 == null)       continue;
      ShipStrategy ss2=checkShipStrategyCompatibility(this.input2);
      if (ss2 == null)       continue;
      if (areBranchesEqual(predList1,predList2)) {
        if (ss1 != ShipStrategy.NONE && ss2 != ShipStrategy.NONE && ss1.equals(ss2)) {
          createLocalAlternatives(outputPlans,predList1,predList2,ss1,ss1,estimator);
        }
 else         if (ss1 != ShipStrategy.NONE && ss2 == ShipStrategy.NONE) {
          createLocalAlternatives(outputPlans,predList1,predList2,ss1,ss1,estimator);
        }
 else         if (ss1 == ShipStrategy.NONE && ss2 != ShipStrategy.NONE) {
          createLocalAlternatives(outputPlans,predList1,predList2,ss2,ss2,estimator);
        }
 else         if (ss1 != ShipStrategy.NONE && ss2 != ShipStrategy.NONE && !ss1.equals(ss2)) {
          continue;
        }
        GlobalProperties gp;
        if (predList1.size() == 1) {
          gp=predList1.get(0).getGlobalProperties();
        }
 else {
          gp=new GlobalProperties();
        }
        if (!partitioningIsOnRightFields(gp,0) || gp.getPartitioning().equals(PartitionProperty.NONE)) {
          createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
        }
 else {
          createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.FORWARD,ShipStrategy.FORWARD,estimator);
        }
        continue;
      }
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        if (predList1.size() == 1) {
          gp1=predList1.get(0).getGlobalProperties();
        }
 else {
          gp1=new GlobalProperties();
        }
        if (ss2 == ShipStrategy.NONE) {
          if (predList2.size() == 1) {
            gp2=predList2.get(0).getGlobalProperties();
          }
 else {
            gp2=new GlobalProperties();
          }
          if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isComputablyPartitioned()) {
            if (!partitioningIsOnRightFields(gp1,0) || !gp1.getPartitioning().isComputablyPartitioned()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning()) && Arrays.equals(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
                ss2=ShipStrategy.FORWARD;
              }
 else {
                if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                }
 else                 if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                }
                if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
                }
 else                 if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
                }
                continue;
              }
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createLocalAlternatives(outputPlans,predList1,predList2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_RANGE,ShipStrategy.PARTITION_RANGE,estimator);
              }
            }
 else {
              if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,predList1,predList2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,predList1,predList2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException("Invalid partitioning property for input 1 of match '" + getPactContract().getName() + "'.");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException("Invalid partitioning property for input 2 of match '" + getPactContract().getName() + "'.");
            }
          }
 else {
            createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            if (haveValidOutputEstimates(predList1) && haveValidOutputEstimates(predList2)) {
              createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
              createLocalAlternatives(outputPlans,predList1,predList2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
            }
          }
        }
 else {
          if (predList2.size() == 1) {
            gp2=PactConnection.getGlobalPropertiesAfterConnection(predList2.get(0),this,ss2);
          }
 else {
            gp2=new GlobalProperties();
          }
switch (ss2) {
case BROADCAST:
            ss1=ShipStrategy.FORWARD;
          break;
case FORWARD:
        if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isPartitioned()) {
          if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_HASH;
          }
 else           if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_RANGE;
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          ss1=ShipStrategy.BROADCAST;
        }
      break;
case PARTITION_HASH:
    int[] keyFields2=getPactContract().getKeyColumnNumbers(1);
  ss1=(Arrays.equals(keyFields2,gp1.getPartitionedFields()) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss1=(partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException("Invalid fixed shipping strategy '" + ss2.name() + "' for match contract '"+ getPactContract().getName()+ "'.");
}
createLocalAlternatives(outputPlans,predList1,predList2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
if (predList1.size() == 1) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(predList1.get(0),this,ss1);
}
 else {
gp1=new GlobalProperties();
}
if (predList2.size() == 1) {
gp2=predList2.get(0).getGlobalProperties();
}
 else {
gp2=new GlobalProperties();
}
switch (ss1) {
case BROADCAST:
ss2=ShipStrategy.FORWARD;
break;
case FORWARD:
if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
ss2=ShipStrategy.BROADCAST;
}
break;
case PARTITION_HASH:
int[] keyFields1=getPactContract().getKeyColumnNumbers(0);
ss2=(Arrays.equals(keyFields1,gp2.getPartitionedFields()) && partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException("Invalid fixed shipping strategy '" + ss1.name() + "' for match contract '"+ getPactContract().getName()+ "'.");
}
createLocalAlternatives(outputPlans,predList1,predList2,ss1,ss2,estimator);
}
 else {
if ((ss1 == ShipStrategy.BROADCAST && ss2 != ShipStrategy.BROADCAST) || (ss1 != ShipStrategy.BROADCAST && ss2 == ShipStrategy.BROADCAST)) {
createLocalAlternatives(outputPlans,predList1,predList2,ss1,ss2,estimator);
}
 else {
if (predList1.size() == 1) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(predList1.get(0),this,ss1);
}
 else {
gp1=new GlobalProperties();
}
if (predList2.size() == 1) {
gp2=PactConnection.getGlobalPropertiesAfterConnection(predList2.get(0),this,ss2);
}
 else {
gp2=new GlobalProperties();
}
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning() && Arrays.equals(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
createLocalAlternatives(outputPlans,predList1,predList2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
}
