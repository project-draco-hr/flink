{
  try {
    final int[] newPartitions={4,52,17,1,2,3,89,42,31,127,14};
    final int[] initialPartitions=Arrays.copyOfRange(newPartitions,0,7);
    final Set<Integer> allNewPartitions=new HashSet<>();
    final Set<Integer> allInitialPartitions=new HashSet<>();
    for (    int i : newPartitions) {
      allNewPartitions.add(i);
    }
    for (    int i : initialPartitions) {
      allInitialPartitions.add(i);
    }
    final int numConsumers=3;
    final int minInitialPartitionsPerConsumer=initialPartitions.length / numConsumers;
    final int maxInitialPartitionsPerConsumer=initialPartitions.length / numConsumers + 1;
    final int minNewPartitionsPerConsumer=newPartitions.length / numConsumers;
    final int maxNewPartitionsPerConsumer=newPartitions.length / numConsumers + 1;
    List<TopicPartition> parts1=FlinkKafkaConsumer.assignPartitions(initialPartitions,"test-topic",numConsumers,0);
    List<TopicPartition> parts2=FlinkKafkaConsumer.assignPartitions(initialPartitions,"test-topic",numConsumers,1);
    List<TopicPartition> parts3=FlinkKafkaConsumer.assignPartitions(initialPartitions,"test-topic",numConsumers,2);
    assertNotNull(parts1);
    assertNotNull(parts2);
    assertNotNull(parts3);
    assertTrue(parts1.size() >= minInitialPartitionsPerConsumer);
    assertTrue(parts1.size() <= maxInitialPartitionsPerConsumer);
    assertTrue(parts2.size() >= minInitialPartitionsPerConsumer);
    assertTrue(parts2.size() <= maxInitialPartitionsPerConsumer);
    assertTrue(parts3.size() >= minInitialPartitionsPerConsumer);
    assertTrue(parts3.size() <= maxInitialPartitionsPerConsumer);
    for (    TopicPartition p : parts1) {
      assertTrue(allInitialPartitions.remove(p.partition()));
    }
    for (    TopicPartition p : parts2) {
      assertTrue(allInitialPartitions.remove(p.partition()));
    }
    for (    TopicPartition p : parts3) {
      assertTrue(allInitialPartitions.remove(p.partition()));
    }
    assertTrue(allInitialPartitions.isEmpty());
    List<TopicPartition> parts1new=FlinkKafkaConsumer.assignPartitions(newPartitions,"test-topic",numConsumers,0);
    List<TopicPartition> parts2new=FlinkKafkaConsumer.assignPartitions(newPartitions,"test-topic",numConsumers,1);
    List<TopicPartition> parts3new=FlinkKafkaConsumer.assignPartitions(newPartitions,"test-topic",numConsumers,2);
    assertTrue(parts1new.size() > parts1.size());
    assertTrue(parts2new.size() > parts2.size());
    assertTrue(parts3new.size() > parts3.size());
    assertTrue(parts1new.containsAll(parts1));
    assertTrue(parts2new.containsAll(parts2));
    assertTrue(parts3new.containsAll(parts3));
    assertTrue(parts1new.size() >= minNewPartitionsPerConsumer);
    assertTrue(parts1new.size() <= maxNewPartitionsPerConsumer);
    assertTrue(parts2new.size() >= minNewPartitionsPerConsumer);
    assertTrue(parts2new.size() <= maxNewPartitionsPerConsumer);
    assertTrue(parts3new.size() >= minNewPartitionsPerConsumer);
    assertTrue(parts3new.size() <= maxNewPartitionsPerConsumer);
    for (    TopicPartition p : parts1new) {
      assertTrue(allNewPartitions.remove(p.partition()));
    }
    for (    TopicPartition p : parts2new) {
      assertTrue(allNewPartitions.remove(p.partition()));
    }
    for (    TopicPartition p : parts3new) {
      assertTrue(allNewPartitions.remove(p.partition()));
    }
    assertTrue(allNewPartitions.isEmpty());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
