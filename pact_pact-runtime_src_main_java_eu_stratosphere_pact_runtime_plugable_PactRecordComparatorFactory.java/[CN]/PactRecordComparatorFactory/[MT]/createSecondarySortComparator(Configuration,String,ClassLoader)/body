{
  final int numKeyFields=config.getInteger(keyPrefix + NUM_KEYS,-1);
  final int numSSKeyFields=config.getInteger(keyPrefix + NUM_SS_KEYS,-1);
  if (numKeyFields < 0) {
    throw new CorruptConfigurationException("The number of keys for the comparator with config prefix '" + keyPrefix + "' is invalid: "+ numKeyFields);
  }
  if (numSSKeyFields < 0) {
    throw new CorruptConfigurationException("The number of secondary sort keys for the comparator with config prefix '" + keyPrefix + "' is invalid: "+ numSSKeyFields);
  }
  final int[] positions=new int[numKeyFields + numSSKeyFields];
  @SuppressWarnings("unchecked") final Class<? extends Key>[] types=new Class[numKeyFields + numSSKeyFields];
  for (int i=0; i < numKeyFields; i++) {
    final int p=config.getInteger(keyPrefix + KEY_POS_PREFIX + i,-1);
    if (p >= 0) {
      positions[i]=p;
    }
 else {
      throw new CorruptConfigurationException("Contained invalid position for key no positions for keys.");
    }
    final String name=config.getString(keyPrefix + KEY_CLASS_PREFIX + i,null);
    if (name != null) {
      types[i]=Class.forName(name,true,cl).asSubclass(Key.class);
    }
 else {
      throw new CorruptConfigurationException("The key type (" + i + ") for the comparator with config prefix '"+ keyPrefix+ "' is null");
    }
  }
  for (int i=0; i < numSSKeyFields; i++) {
    final int p=config.getInteger(keyPrefix + SS_KEY_POS_PREFIX + i,-1);
    if (p >= 0) {
      positions[numKeyFields + i]=p;
    }
 else {
      throw new CorruptConfigurationException("Contained invalid position for key no positions for keys.");
    }
    final String name=config.getString(keyPrefix + SS_KEY_CLASS_PREFIX + i,null);
    if (name != null) {
      types[numKeyFields + i]=Class.forName(name,true,cl).asSubclass(Key.class);
    }
 else {
      throw new CorruptConfigurationException("The key type (" + i + ") for the comparator with config prefix '"+ keyPrefix+ "' is null");
    }
  }
  return new PactRecordComparator(positions,types);
}
