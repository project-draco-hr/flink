{
  if (n.getIncomingConnections() == null) {
    throw new CompilerException("Cannot compute costs on operator before incoming connections are set.");
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
  List<PactConnection> incomingConnections=n.getIncomingConnections();
  for (int i=0; i < incomingConnections.size(); i++) {
    PactConnection connection=incomingConnections.get(i);
    Costs tempGlobalCost=new Costs();
switch (connection.getShipStrategy().type()) {
case NONE:
      throw new CompilerException("Cannot determine costs: Shipping strategy has not been set for an input.");
case FORWARD:
case PARTITION_LOCAL_HASH:
    tempGlobalCost.setNetworkCost(0);
  tempGlobalCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(connection,tempGlobalCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(connection,tempGlobalCost);
break;
case BROADCAST:
getBroadcastCost(connection,tempGlobalCost);
break;
case SFR:
throw new CompilerException("Symmetric-Fragment-And-Replicate Strategy currently not supported.");
default :
throw new CompilerException("Unknown shipping strategy for input: " + connection.getShipStrategy().name());
}
globCost.addCosts(tempGlobalCost);
}
PactConnection primConn=null;
PactConnection secConn=null;
{
if (incomingConnections.size() > 0) {
primConn=incomingConnections.get(0);
}
if (incomingConnections.size() > 1) {
secConn=incomingConnections.get(1);
}
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primConn,locCost);
break;
case SORT_BOTH_MERGE:
getLocalDoubleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_FIRST_MERGE:
getLocalSingleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SECOND_MERGE:
getLocalSingleSortMergeCost(n,secConn,primConn,locCost);
break;
case MERGE:
getLocalMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SELF_NESTEDLOOP:
getLocalSortSelfNestedLoopCost(n,primConn,10,locCost);
break;
case SELF_NESTEDLOOP:
getLocalSelfNestedLoopCost(n,primConn,10,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primConn,secConn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secConn,primConn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primConn,secConn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secConn,primConn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primConn,secConn,BlockResettableMutableObjectIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secConn,primConn,BlockResettableMutableObjectIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primConn,secConn,128 * 1024,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secConn,primConn,128 * 1024,locCost);
break;
default :
throw new CompilerException("Unknown local strategy: " + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}
