{
  Preconditions.checkNotNull(expressionsIn,"Field expression cannot be null.");
  if (type instanceof AtomicType) {
    if (!type.isKeyType()) {
      throw new InvalidProgramException("This type (" + type + ") cannot be used as key.");
    }
 else     if (expressionsIn.length != 1 || !(Keys.ExpressionKeys.SELECT_ALL_CHAR.equals(expressionsIn[0]) || Keys.ExpressionKeys.SELECT_ALL_CHAR_SCALA.equals(expressionsIn[0]))) {
      throw new InvalidProgramException("Field expression for atomic type must be equal to '*' or '_'.");
    }
    keyFields=new ArrayList<>(1);
    keyFields.add(new FlatFieldDescriptor(0,type));
  }
 else {
    CompositeType<T> cType=(CompositeType<T>)type;
    String[] expressions=removeDuplicates(expressionsIn);
    if (expressionsIn.length != expressions.length) {
      LOG.warn("The key expressions contained duplicates. They are now unique");
    }
    keyFields=new ArrayList<>(expressions.length);
    for (    String expression : expressions) {
      List<FlatFieldDescriptor> keys=cType.getFlatFields(expression);
      for (      FlatFieldDescriptor key : keys) {
        TypeInformation<?> keyType=key.getType();
        if (!keyType.isKeyType()) {
          throw new InvalidProgramException("This type (" + key.getType() + ") cannot be used as key.");
        }
        if (!(keyType instanceof AtomicType || keyType instanceof CompositeType)) {
          throw new InvalidProgramException("Field type is neither CompositeType nor AtomicType: " + keyType);
        }
      }
      if (keys.size() == 0) {
        throw new InvalidProgramException("Unable to extract key from expression '" + expression + "' on key "+ cType);
      }
      keyFields.addAll(keys);
    }
  }
}
