{
  if (!type.isTupleType()) {
    throw new InvalidProgramException("Specifying keys via field positions is only valid " + "for tuple data types. Type: " + type);
  }
  if (!allowEmpty && (groupingFields == null || groupingFields.length == 0)) {
    throw new IllegalArgumentException("The grouping fields must not be empty.");
  }
  if (groupingFields == null || groupingFields.length == 0) {
    groupingFields=new int[type.getArity()];
    for (int i=0; i < groupingFields.length; i++) {
      groupingFields[i]=i;
    }
  }
 else {
    groupingFields=rangeCheckFields(groupingFields,type.getArity() - 1);
  }
  Preconditions.checkArgument(groupingFields.length > 0,"Grouping fields can not be empty at this point");
  keyFields=new ArrayList<FlatFieldDescriptor>(type.getTotalFields());
  for (int j=0; j < groupingFields.length; j++) {
    int keyPos=groupingFields[j];
    int offset=0;
    for (int i=0; i < type.getArity(); i++) {
      TypeInformation fieldType=((CompositeType<?>)type).getTypeAt(i);
      if (i < keyPos) {
        offset+=fieldType.getTotalFields();
      }
 else {
        if (fieldType instanceof CompositeType) {
          ((CompositeType)fieldType).getFlatFields("*",offset,keyFields);
        }
 else         if (fieldType instanceof AtomicType) {
          keyFields.add(new FlatFieldDescriptor(offset,fieldType));
        }
 else {
          throw new InvalidProgramException("Field type is neither CompositeType nor AtomicType: " + fieldType);
        }
        break;
      }
    }
  }
  keyFields=removeNullElementsFromList(keyFields);
}
