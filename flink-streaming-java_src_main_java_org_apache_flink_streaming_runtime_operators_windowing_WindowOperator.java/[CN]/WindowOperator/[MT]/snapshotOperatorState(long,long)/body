{
  if (mergingWindowsByKey != null) {
    TupleSerializer<Tuple2<W,W>> tupleSerializer=new TupleSerializer<>((Class)Tuple2.class,new TypeSerializer[]{windowSerializer,windowSerializer});
    ListStateDescriptor<Tuple2<W,W>> mergeStateDescriptor=new ListStateDescriptor<>("merging-window-set",tupleSerializer);
    for (    Map.Entry<K,MergingWindowSet<W>> key : mergingWindowsByKey.entrySet()) {
      setKeyContext(key.getKey());
      ListState<Tuple2<W,W>> mergeState=getStateBackend().getPartitionedState(null,VoidSerializer.INSTANCE,mergeStateDescriptor);
      mergeState.clear();
      key.getValue().persist(mergeState);
    }
  }
  StreamTaskState taskState=super.snapshotOperatorState(checkpointId,timestamp);
  AbstractStateBackend.CheckpointStateOutputView out=getStateBackend().createCheckpointStateOutputView(checkpointId,timestamp);
  out.writeInt(watermarkTimersQueue.size());
  for (  Timer<K,W> timer : watermarkTimersQueue) {
    keySerializer.serialize(timer.key,out);
    windowSerializer.serialize(timer.window,out);
    out.writeLong(timer.timestamp);
  }
  out.writeInt(processingTimeTimers.size());
  for (  Timer<K,W> timer : processingTimeTimersQueue) {
    keySerializer.serialize(timer.key,out);
    windowSerializer.serialize(timer.window,out);
    out.writeLong(timer.timestamp);
  }
  taskState.setOperatorState(out.closeAndGetHandle());
  return taskState;
}
