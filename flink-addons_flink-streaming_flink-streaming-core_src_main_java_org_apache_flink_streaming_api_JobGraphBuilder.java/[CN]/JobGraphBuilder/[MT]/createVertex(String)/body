{
  if (!builtVertices.contains(vertexName)) {
    if (!outEdgeList.get(vertexName).isEmpty()) {
      for (      String outName : outEdgeList.get(vertexName)) {
        if (isChainable(vertexName,outName)) {
          chainRecursively(vertexName,vertexName,outName);
        }
 else {
          createVertex(outName);
        }
      }
    }
    List<String> chainedNames=chainedVertices.get(vertexName);
    boolean isChained=chainedNames != null;
    int numChained=isChained ? chainedNames.size() : 0;
    String lastInChain=lastInChains.get(vertexName);
    Class<? extends AbstractInvokable> vertexClass=vertexClasses.get(vertexName);
    StreamInvokable<?,?> invokableObject=invokableObjects.get(vertexName);
    int parallelism=vertexParallelism.get(vertexName);
    byte[] outputSelector=outputSelectors.get(lastInChain);
    Map<String,OperatorState<?>> state=operatorStates.get(vertexName);
    String cname=chainedVertices.get(vertexName) == null ? "" : " => " + StringUtils.join(chainedVertices.get(vertexName)," => ");
    AbstractJobVertex vertex=new AbstractJobVertex(vertexName + cname);
    this.jobGraph.addVertex(vertex);
    vertex.setInvokableClass(vertexClass);
    vertex.setParallelism(parallelism);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Parallelism set: {} for {}",parallelism,vertexName);
    }
    StreamConfig config=new StreamConfig(vertex.getConfiguration());
    config.setBufferTimeout(bufferTimeout.get(lastInChain));
    config.setTypeSerializerIn1(typeSerializersIn1.get(vertexName));
    config.setTypeSerializerIn2(typeSerializersIn2.get(vertexName));
    config.setTypeSerializerOut1(typeSerializersOut1.get(vertexName));
    config.setTypeSerializerOut2(typeSerializersOut2.get(vertexName));
    config.setUserInvokable(invokableObject);
    config.setOutputSelector(outputSelector);
    config.setOperatorStates(state);
    if (vertexClass.equals(StreamIterationHead.class) || vertexClass.equals(StreamIterationTail.class)) {
      config.setIterationId(iterationIds.get(vertexName));
      config.setIterationWaitTime(iterationWaitTime.get(vertexName));
    }
    if (inputFormatList.containsKey(vertexName)) {
      vertex.setInputSplitSource(inputFormatList.get(vertexName));
    }
    config.setNumberofChainedTasks(numChained);
    for (int i=0; i < numChained; i++) {
      config.setChainedInvokable((ChainableInvokable<?,?>)invokableObjects.get(chainedNames.get(i)),i);
      config.setChainedSerializer(typeSerializersIn1.get(chainedNames.get(i)),i);
    }
    streamVertices.put(vertexName,vertex);
    builtVertices.add(vertexName);
  }
}
