{
  Class<? extends AbstractInvokable> componentClass=componentClasses.get(componentName);
  StreamInvokable<?> invokableObject=invokableObjects.get(componentName);
  String operatorName=operatorNames.get(componentName);
  byte[] serializedFunction=serializedFunctions.get(componentName);
  int parallelism=componentParallelism.get(componentName);
  byte[] outputSelector=outputSelectors.get(componentName);
  AbstractJobVertex component=new AbstractJobVertex(componentName);
  this.jobGraph.addVertex(component);
  component.setInvokableClass(componentClass);
  component.setParallelism(parallelism);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Parallelism set: {} for {}",parallelism,componentName);
  }
  StreamConfig config=new StreamConfig(component.getConfiguration());
  config.setMutability(mutability.get(componentName));
  config.setBufferTimeout(bufferTimeout.get(componentName));
  config.setTypeWrapperIn1(typeWrapperIn1.get(componentName));
  config.setTypeWrapperIn2(typeWrapperIn2.get(componentName));
  config.setTypeWrapperOut1(typeWrapperOut1.get(componentName));
  config.setTypeWrapperOut2(typeWrapperOut2.get(componentName));
  config.setUserInvokable(invokableObject);
  config.setComponentName(componentName);
  config.setFunction(serializedFunction,operatorName);
  config.setOutputSelector(outputSelector);
  if (componentClass.equals(StreamIterationSource.class) || componentClass.equals(StreamIterationSink.class)) {
    config.setIterationId(iterationIds.get(componentName));
    config.setIterationWaitTime(iterationWaitTime.get(componentName));
  }
  components.put(componentName,component);
}
