{
  Class<? extends AbstractInvokable> componentClass=componentClasses.get(componentName);
  StreamInvokable<?> invokableObject=invokableObjects.get(componentName);
  String operatorName=operatorNames.get(componentName);
  byte[] serializedFunction=serializedFunctions.get(componentName);
  int parallelism=componentParallelism.get(componentName);
  byte[] outputSelector=outputSelectors.get(componentName);
  AbstractJobVertex component=null;
  if (componentClass.equals(StreamSource.class) || componentClass.equals(StreamIterationSource.class)) {
    component=new JobInputVertex(componentName,this.jobGraph);
  }
 else   if (componentClass.equals(StreamTask.class) || componentClass.equals(CoStreamTask.class)) {
    component=new JobTaskVertex(componentName,this.jobGraph);
  }
 else   if (componentClass.equals(StreamSink.class) || componentClass.equals(StreamIterationSink.class)) {
    component=new JobOutputVertex(componentName,this.jobGraph);
  }
 else {
    throw new RuntimeException("Unsupported component class");
  }
  component.setInvokableClass(componentClass);
  component.setNumberOfSubtasks(parallelism);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Parallelism set: " + parallelism + " for "+ componentName);
  }
  StreamConfig config=new StreamConfig(component.getConfiguration());
  config.setMutability(mutability.get(componentName));
  config.setBufferTimeout(bufferTimeout.get(componentName));
  config.setTypeWrapperIn1(typeWrapperIn1.get(componentName));
  config.setTypeWrapperIn2(typeWrapperIn2.get(componentName));
  config.setTypeWrapperOut1(typeWrapperOut1.get(componentName));
  config.setTypeWrapperOut2(typeWrapperOut2.get(componentName));
  config.setUserInvokable(invokableObject);
  config.setComponentName(componentName);
  config.setFunction(serializedFunction,operatorName);
  config.setOutputSelector(outputSelector);
  if (componentClass.equals(StreamIterationSource.class) || componentClass.equals(StreamIterationSink.class)) {
    config.setIterationId(iterationIds.get(componentName));
    config.setIterationWaitTime(iterationWaitTime.get(componentName));
  }
  components.put(componentName,component);
  if (parallelism > maxParallelism) {
    maxParallelism=parallelism;
    maxParallelismVertexName=componentName;
  }
}
