{
  Class<? extends AbstractInvokable> vertexClass=vertexClasses.get(vertexName);
  StreamInvokable<?,?> invokableObject=invokableObjects.get(vertexName);
  String operatorName=operatorNames.get(vertexName);
  byte[] serializedFunction=serializedFunctions.get(vertexName);
  int parallelism=vertexParallelism.get(vertexName);
  byte[] outputSelector=outputSelectors.get(vertexName);
  Map<String,OperatorState<?>> state=operatorStates.get(vertexName);
  AbstractJobVertex vertex=new AbstractJobVertex(vertexName);
  this.jobGraph.addVertex(vertex);
  vertex.setInvokableClass(vertexClass);
  vertex.setParallelism(parallelism);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Parallelism set: {} for {}",parallelism,vertexName);
  }
  StreamConfig config=new StreamConfig(vertex.getConfiguration());
  config.setMutability(mutability.get(vertexName));
  config.setBufferTimeout(bufferTimeout.get(vertexName));
  config.setTypeWrapperIn1(typeWrapperIn1.get(vertexName));
  config.setTypeWrapperIn2(typeWrapperIn2.get(vertexName));
  config.setTypeWrapperOut1(typeWrapperOut1.get(vertexName));
  config.setTypeWrapperOut2(typeWrapperOut2.get(vertexName));
  config.setUserInvokable(invokableObject);
  config.setVertexName(vertexName);
  config.setFunction(serializedFunction,operatorName);
  config.setOutputSelector(outputSelector);
  config.setOperatorStates(state);
  if (vertexClass.equals(StreamIterationHead.class) || vertexClass.equals(StreamIterationTail.class)) {
    config.setIterationId(iterationIds.get(vertexName));
    config.setIterationWaitTime(iterationWaitTime.get(vertexName));
  }
  streamVertices.put(vertexName,vertex);
}
