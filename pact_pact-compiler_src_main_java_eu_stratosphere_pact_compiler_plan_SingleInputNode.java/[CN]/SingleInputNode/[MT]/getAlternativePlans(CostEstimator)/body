{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  final int inputSize=this.input.size();
  @SuppressWarnings("unchecked") List<? extends OptimizerNode>[] inPlans=new List[inputSize];
  for (int i=0; i < inputSize; ++i) {
    inPlans[i]=this.input.get(i).getSourcePact().getAlternativePlans(estimator);
  }
  List<List<OptimizerNode>> alternativeSubPlanCominations=new ArrayList<List<OptimizerNode>>();
  getAlternativeSubPlanCombinationsRecursively(inPlans,new ArrayList<OptimizerNode>(0),alternativeSubPlanCominations);
  for (int i=0; i < alternativeSubPlanCominations.size(); ++i) {
    if (!areBranchCompatible(alternativeSubPlanCominations.get(i),null)) {
      alternativeSubPlanCominations.remove(i);
      --i;
    }
  }
  List<OptimizerNode> outputPlans=new ArrayList<OptimizerNode>();
  computeValidPlanAlternatives(alternativeSubPlanCominations,estimator,outputPlans);
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
