{
  final int nextRecursionLevel=p.recursionLevel + 1;
  if (nextRecursionLevel > MAX_RECURSION_DEPTH) {
    throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing " + "partitions enough to be memory resident. Probably cause: Too many duplicate keys.");
  }
  final K tempKey;
  final BV tempValue;
  try {
    tempKey=this.keyClass.newInstance();
    tempValue=this.buildSideValueClass.newInstance();
  }
 catch (  IllegalAccessException ex) {
    throw new RuntimeException("Cannot create instance of data type. Class or nullary constructor not public.");
  }
catch (  InstantiationException iex) {
    throw new RuntimeException("Cannot create instance of data type. No public nullary constructor.");
  }
catch (  Exception ex) {
    throw new RuntimeException(ex);
  }
  final int totalBuffersAvailable=this.availableMemory.size() + this.writeBehindBuffersAvailable;
  if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {
    throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.");
  }
  long numBuckets=(p.buildSideRecordCounter * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1;
  final long totalBuffersNeeded=(numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.buildSideBlockCounter + 1;
  if (totalBuffersNeeded < totalBuffersAvailable) {
    ensureNumBuffersReturned(p.buildSideBlockCounter);
    final BulkBlockChannelReader reader=this.ioManager.createBulkBlockChannelReader(p.buildSideChannel.getChannelID(),this.availableMemory,p.buildSideBlockCounter);
    reader.closeAndDelete();
    final List<MemorySegment> partitionBuffers=reader.getFullSegments();
    final Partition newPart=new Partition(0,nextRecursionLevel,partitionBuffers,p.buildSideRecordCounter);
    this.partitionsBeingBuilt.add(newPart);
    initTable((int)numBuckets,(byte)1);
    PartitionIterator<K,BV> pIter=newPart.getPartitionIterator(tempKey,tempValue);
    while (pIter.next()) {
      final int hashCode=hash(pIter.getHashCode(),nextRecursionLevel);
      final long pointer=pIter.getPointer();
      final int posHashCode=hashCode % this.numBuckets;
      final int bucketArrayPos=posHashCode >> this.bucketsPerSegmentBits;
      final int bucketInSegmentPos=(posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
      final MemorySegment bucket=this.buckets[bucketArrayPos];
      insertBucketEntry(newPart,bucket,bucketInSegmentPos,hashCode,pointer);
    }
  }
 else {
    final int avgRecordLenPartition=(int)(((long)p.buildSideBlockCounter) * (this.segmentSize - PARTITION_BLOCK_HEADER_LEN) / p.buildSideRecordCounter);
    final int bucketCount=(int)(((long)totalBuffersAvailable) * RECORD_TABLE_BYTES / (avgRecordLenPartition + RECORD_OVERHEAD_BYTES));
    final int splits=(int)(totalBuffersNeeded / totalBuffersAvailable) + 1;
    final int partitionFanOut=Math.min(10 * splits,MAX_NUM_PARTITIONS);
    createPartitions(partitionFanOut,nextRecursionLevel);
    initTable(bucketCount,(byte)partitionFanOut);
    final List<MemorySegment> segments=new ArrayList<MemorySegment>(2);
    segments.add(getNextBuffer());
    segments.add(getNextBuffer());
    final BlockReaderIterator<K,BV> reader=new BlockReaderIterator<K,BV>(this.ioManager,p.buildSideChannel.getChannelID(),segments,this.availableMemory,p.buildSideBlockCounter);
    final KeyValuePair<K,BV> pair=new KeyValuePair<K,BV>(tempKey,tempValue);
    while (reader.next(pair)) {
      final int hashCode=hash(pair.getKey().hashCode(),nextRecursionLevel);
      insertIntoTable(pair,hashCode);
    }
    for (int i=0; i < this.partitionsBeingBuilt.size(); i++) {
      Partition part=this.partitionsBeingBuilt.get(i);
      part.finalizeBuildPhase(this.ioManager,this.currentEnumerator);
    }
  }
}
