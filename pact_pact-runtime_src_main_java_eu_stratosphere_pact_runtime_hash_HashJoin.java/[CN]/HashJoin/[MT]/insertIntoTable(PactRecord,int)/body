{
  final int posHashCode=hashCode % this.numBuckets;
  final int bucketArrayPos=posHashCode >> this.bucketsPerSegmentBits;
  final int bucketInSegmentPos=(posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
  final MemorySegment bucket=this.buckets[bucketArrayPos];
  final int partitionNumber=bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET);
  if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {
    throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.");
  }
  final Partition p=this.partitionsBeingBuilt.get(partitionNumber);
  long pointer=p.insertIntoBuildBuffer(record);
  if (pointer == -1) {
    MemorySegment nextSeg=getNextBuffer();
    if (nextSeg == null) {
      int spilledPartitionNum=spillPartition();
      if (spilledPartitionNum != partitionNumber) {
        nextSeg=getNextBuffer();
        if (nextSeg == null) {
          throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling partition.");
        }
        p.addBuildSideBuffer(nextSeg);
      }
    }
 else {
      p.addBuildSideBuffer(nextSeg);
    }
    pointer=p.insertIntoBuildBuffer(record);
    if (pointer == -1) {
      throw new IOException("Record could not be added to fresh buffer. Probably cause: Record length exceeds buffer size limit.");
    }
  }
  if (p.isInMemory()) {
    insertBucketEntry(p,bucket,bucketInSegmentPos,hashCode,pointer);
  }
 else {
    return;
  }
}
