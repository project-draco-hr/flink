{
  final ProbeSideIterator<K,V> probeIter=this.probeIterator;
  while (probeIter.nextKey()) {
    final K currKey=probeIter.getCurrentKey();
    final int hash=hash(currKey.hashCode(),this.currentRecursionDepth);
    final int posHashCode=hash % this.numBuckets;
    final int bucketArrayPos=posHashCode >> this.bucketsPerSegmentBits;
    final int bucketInSegmentOffset=(posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
    final MemorySegment bucket=this.buckets[bucketArrayPos];
    final int partitionNumber=bucket.get(bucketInSegmentOffset + HEADER_PARTITION_OFFSET);
    final Partition p=this.partitionsBeingBuilt.get(partitionNumber);
    if (p.isInMemory()) {
      this.bucketIterator.set(bucket,p.overflowSegments,p.inMemoryBuffers,currKey,hash,bucketInSegmentOffset);
      return true;
    }
 else {
      while (probeIter.hasNext()) {
        final KeyValuePair<K,V> nextPair=probeIter.next();
        p.insertIntoProbeBuffer(nextPair);
      }
    }
  }
  int buffersAvailable=0;
  for (int i=0; i < this.partitionsBeingBuilt.size(); i++) {
    Partition p=this.partitionsBeingBuilt.get(i);
    buffersAvailable+=p.finalizeProbePhase(this.availableMemory,this.partitionsPending);
  }
  this.partitionsBeingBuilt.clear();
  this.writeBehindBuffersAvailable+=buffersAvailable;
  releaseTable();
  if (DEBUG_CHECKS) {
    HashSet<MemorySegment> segSet=new HashSet<MemorySegment>();
    for (int i=0; i < this.availableMemory.size(); i++) {
      MemorySegment seg=this.availableMemory.get(i);
      if (seg == null) {
        throw new RuntimeException("Bookkeeping error: null booked as Memory Segment.");
      }
      if (segSet.contains(seg)) {
        throw new RuntimeException("Bookkeeping error: Available Memory Segment booked twice.");
      }
      segSet.add(seg);
    }
    HashSet<MemorySegment> wbSet=new HashSet<MemorySegment>();
    Iterator<MemorySegment> wbIter=this.writeBehindBuffers.iterator();
    while (wbIter.hasNext()) {
      MemorySegment seg=wbIter.next();
      if (seg == null) {
        throw new RuntimeException("Bookkeeping error: null booked as Memory Segment.");
      }
      if (segSet.contains(seg)) {
        throw new RuntimeException("Bookkeeping error: Write-behind buffer also occurred as available memory.");
      }
      if (wbSet.contains(seg)) {
        throw new RuntimeException("Bookkeeping error: Write-behind buffer booked twice");
      }
      wbSet.add(seg);
    }
  }
  if (!this.partitionsPending.isEmpty()) {
    final Partition p=this.partitionsPending.get(0);
    buildTableFromSpilledPartition(p);
    LinkedBlockingQueue<MemorySegment> returnQueue=new LinkedBlockingQueue<MemorySegment>();
    this.currentSpilledProbeSide=this.ioManager.createBlockChannelReader(p.probeSideChannel.getChannelID(),returnQueue);
    List<MemorySegment> memory=new ArrayList<MemorySegment>();
    memory.add(getNextBuffer());
    memory.add(getNextBuffer());
    Iterator<KeyValuePair<K,V>> probeReader=new BlockReaderUtilIterator<K,V>(this.currentSpilledProbeSide,returnQueue,memory,this.availableMemory,p.probeBlockCounter,this.keySerialization,this.valueSerialization);
    this.probeIterator.set(probeReader);
    this.partitionsPending.remove(0);
    this.currentRecursionDepth=p.recursionLevel + 1;
    return nextKey();
  }
 else {
    return false;
  }
}
