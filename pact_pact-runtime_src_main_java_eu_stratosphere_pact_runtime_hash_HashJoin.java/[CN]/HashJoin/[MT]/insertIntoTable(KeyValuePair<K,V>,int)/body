{
  final int posHashCode=hashCode % this.numBuckets;
  final int bucketArrayPos=posHashCode >> this.bucketsPerSegmentBits;
  final int bucketInSegmentPos=(posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
  final MemorySegment bucket=this.buckets[bucketArrayPos];
  final int partitionNumber=bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET);
  if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {
    throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.");
  }
  final Partition p=this.partitionsBeingBuilt.get(partitionNumber);
  long pointer=p.insertIntoBuildBuffer(pair);
  if (pointer == -1) {
    MemorySegment nextSeg=getNextBuffer();
    if (nextSeg == null) {
      spillPartition();
      nextSeg=getNextBuffer();
      if (nextSeg == null) {
        throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling partition.");
      }
    }
    p.addBuildSideBuffer(nextSeg);
    pointer=p.insertIntoBuildBuffer(pair);
    if (pointer == -1) {
      throw new IOException("Record could not be added to fresh buffer. Probably cause: Record length exceeds buffer size limit.");
    }
  }
  if (p.isInMemory()) {
    final int count=bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET);
    if (count < NUM_ENTRIES_PER_BUCKET) {
      bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN),hashCode);
      bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN),pointer);
      bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET,(short)(count + 1));
    }
 else {
      final long originalForwardPointer=bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET);
      final long forwardForNewBucket;
      if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {
        final int overflowSegNum=(int)(originalForwardPointer >>> 32);
        final int segOffset=(int)(originalForwardPointer & 0xffffffff);
        final MemorySegment seg=p.overflowSegments[overflowSegNum];
        final short obCount=seg.getShort(segOffset + HEADER_COUNT_OFFSET);
        if (obCount < NUM_ENTRIES_PER_BUCKET) {
          seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN),hashCode);
          seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN),pointer);
          seg.putShort(segOffset + HEADER_COUNT_OFFSET,(short)(obCount + 1));
          return;
        }
 else {
          forwardForNewBucket=originalForwardPointer;
        }
      }
 else {
        forwardForNewBucket=BUCKET_FORWARD_POINTER_NOT_SET;
      }
      MemorySegment overflowSeg;
      final int overflowBucketNum;
      final int overflowBucketOffset;
      if (p.nextOverflowBucket == 0) {
        overflowSeg=getNextBuffer();
        if (overflowSeg == null) {
          final int spilledPart=spillPartition();
          if (spilledPart == partitionNumber) {
            return;
          }
          overflowSeg=getNextBuffer();
          if (overflowSeg == null) {
            throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.");
          }
        }
        overflowBucketOffset=0;
        overflowBucketNum=p.numOverflowSegments;
        if (p.overflowSegments.length <= p.numOverflowSegments) {
          MemorySegment[] newSegsArray=new MemorySegment[p.overflowSegments.length * 2];
          System.arraycopy(p.overflowSegments,0,newSegsArray,0,p.overflowSegments.length);
          p.overflowSegments=newSegsArray;
        }
        p.overflowSegments[p.numOverflowSegments]=overflowSeg;
        p.numOverflowSegments++;
      }
 else {
        overflowBucketNum=p.numOverflowSegments - 1;
        overflowSeg=p.overflowSegments[overflowBucketNum];
        overflowBucketOffset=p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS;
      }
      p.nextOverflowBucket=(p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1);
      overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET,forwardForNewBucket);
      final long pointerToNewBucket=(((long)overflowBucketNum) << 32) | ((long)overflowBucketOffset);
      bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET,pointerToNewBucket);
      overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH,hashCode);
      overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET,pointer);
      overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET,(short)1);
    }
  }
 else {
    return;
  }
}
