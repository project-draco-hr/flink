{
  final int bucketArrayPos=hashCode >> this.bucketsPerSegmentBits;
  final int bucketInSegmentPos=(hashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
  final RandomAccessView bucket=this.buckets[bucketArrayPos];
  final int partitionNumber=bucket.get(bucketInSegmentPos);
  final int bucketStatus=bucket.getInt(bucketInSegmentPos + 1);
  if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {
    throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.");
  }
  final Partition p=this.partitionsBeingBuilt.get(partitionNumber);
  long pointer=p.insertIntoBuffer(pair);
  if (pointer == -1) {
    MemorySegment nextSeg=getNextBuffer();
    if (nextSeg == null) {
      spillPartition();
      nextSeg=getNextBuffer();
      if (nextSeg == null) {
        throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling partition.");
      }
    }
    p.addBuffer(nextSeg);
    pointer=p.insertIntoBuffer(pair);
    if (pointer == -1) {
      throw new IOException("Record could not be added to fresh buffer. Probably cause: Record length exceeds buffer size limit.");
    }
  }
  if (p.isInMemory()) {
    final int nextPos=bucket.getInt(bucketInSegmentPos + 2);
    if (nextPos == -1) {
    }
 else     if (nextPos + 12 > HASH_BUCKET_SIZE) {
    }
 else {
      bucket.putInt(bucketInSegmentPos + nextPos,hashCode);
      bucket.putLong(bucketInSegmentPos + nextPos + 4,pointer);
      bucket.putInt(bucketInSegmentPos + 2,nextPos + 12);
    }
  }
 else {
    if (bucketStatus == BUCKET_STATUS_IN_MEMORY) {
    }
    throw new RuntimeException("Spilled buckets are not supported at the moment.");
  }
}
