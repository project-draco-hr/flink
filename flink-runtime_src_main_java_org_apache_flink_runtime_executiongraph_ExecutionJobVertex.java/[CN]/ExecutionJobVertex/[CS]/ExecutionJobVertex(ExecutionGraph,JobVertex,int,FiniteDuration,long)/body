{
  if (graph == null || jobVertex == null) {
    throw new NullPointerException();
  }
  this.graph=graph;
  this.jobVertex=jobVertex;
  int vertexParallelism=jobVertex.getParallelism();
  int numTaskVertices=vertexParallelism > 0 ? vertexParallelism : defaultParallelism;
  this.parallelism=numTaskVertices;
  this.taskVertices=new ExecutionVertex[numTaskVertices];
  this.inputs=new ArrayList<IntermediateResult>(jobVertex.getInputs().size());
  this.slotSharingGroup=jobVertex.getSlotSharingGroup();
  this.coLocationGroup=jobVertex.getCoLocationGroup();
  if (coLocationGroup != null && slotSharingGroup == null) {
    throw new JobException("Vertex uses a co-location constraint without using slot sharing");
  }
  this.producedDataSets=new IntermediateResult[jobVertex.getNumberOfProducedIntermediateDataSets()];
  for (int i=0; i < jobVertex.getProducedDataSets().size(); i++) {
    final IntermediateDataSet result=jobVertex.getProducedDataSets().get(i);
    this.producedDataSets[i]=new IntermediateResult(result.getId(),this,numTaskVertices,result.getResultType());
  }
  for (int i=0; i < numTaskVertices; i++) {
    ExecutionVertex vertex=new ExecutionVertex(this,i,this.producedDataSets,timeout,createTimestamp);
    this.taskVertices[i]=vertex;
  }
  for (  IntermediateResult ir : this.producedDataSets) {
    if (ir.getNumberOfAssignedPartitions() != parallelism) {
      throw new RuntimeException("The intermediate result's partitions were not correctly assigned.");
    }
  }
  try {
    @SuppressWarnings("unchecked") InputSplitSource<InputSplit> splitSource=(InputSplitSource<InputSplit>)jobVertex.getInputSplitSource();
    if (splitSource != null) {
      inputSplits=splitSource.createInputSplits(numTaskVertices);
      if (inputSplits != null) {
        if (splitSource instanceof StrictlyLocalAssignment) {
          inputSplitsPerSubtask=computeLocalInputSplitsPerTask(inputSplits);
          splitAssigner=new PredeterminedInputSplitAssigner(inputSplitsPerSubtask);
        }
 else {
          splitAssigner=splitSource.getInputSplitAssigner(inputSplits);
        }
      }
    }
 else {
      inputSplits=null;
    }
  }
 catch (  Throwable t) {
    throw new JobException("Creating the input splits caused an error: " + t.getMessage(),t);
  }
  finishedSubtasks=new boolean[parallelism];
}
