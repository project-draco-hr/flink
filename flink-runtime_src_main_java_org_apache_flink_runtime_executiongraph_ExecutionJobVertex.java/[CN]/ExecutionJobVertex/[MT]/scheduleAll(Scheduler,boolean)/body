{
  ExecutionVertex[] vertices=this.taskVertices;
  if (inputSplitsPerSubtask != null) {
    final Map<String,List<Instance>> instances=scheduler.getInstancesByHost();
    final Map<String,Integer> assignments=new HashMap<String,Integer>();
    for (int i=0; i < vertices.length; i++) {
      List<LocatableInputSplit> splitsForHost=inputSplitsPerSubtask[i];
      if (splitsForHost == null || splitsForHost.isEmpty()) {
        continue;
      }
      String[] hostNames=splitsForHost.get(0).getHostnames();
      if (hostNames == null || hostNames.length == 0 || hostNames[0] == null) {
        continue;
      }
      String host=hostNames[0];
      ExecutionVertex v=vertices[i];
      List<Instance> instancesOnHost=instances.get(host);
      if (instancesOnHost == null || instancesOnHost.isEmpty()) {
        throw new NoResourceAvailableException("Cannot schedule a strictly local task to host " + host + ". No TaskManager available on that host.");
      }
      Integer pos=assignments.get(host);
      if (pos == null) {
        pos=0;
        assignments.put(host,0);
      }
 else {
        assignments.put(host,pos + 1 % instancesOnHost.size());
      }
      v.setLocationConstraintHosts(Collections.singletonList(instancesOnHost.get(pos)));
    }
  }
  for (  ExecutionVertex ev : vertices) {
    ev.scheduleForExecution(scheduler,queued);
  }
}
