{
  if (stage >= this.stages.size()) {
    LOG.error("Illegal stage  " + stage + " requested");
    return;
  }
  final ExecutionStage nextStage=this.stages.get(this.indexToCurrentExecutionStage);
  if (nextStage == null) {
    LOG.error("Stage " + stage + " is not a valid execution stage");
    return;
  }
  final Set<AbstractInstance> collectedInstances=new HashSet<AbstractInstance>();
  for (int i=0; i < nextStage.getNumberOfStageMembers(); i++) {
    final ExecutionGroupVertex groupVertex=nextStage.getStageMember(i);
    for (int j=0; j < groupVertex.getCurrentNumberOfGroupMembers(); j++) {
      final ExecutionVertex vertex=groupVertex.getGroupMember(j);
      if (vertex.getExecutionState() == executionState) {
        final AbstractInstance instance=vertex.getAllocatedResource().getInstance();
        if (collectedInstances.contains(instance)) {
          continue;
        }
 else {
          collectedInstances.add(instance);
        }
        if (instance instanceof DummyInstance) {
          Integer num=instanceTypeMap.get(instance.getType());
          num=(num == null) ? Integer.valueOf(1) : Integer.valueOf(num.intValue() + 1);
          instanceTypeMap.put(instance.getType(),num);
        }
 else {
          LOG.info("Execution Vertex " + vertex.getName() + " ("+ vertex.getID()+ ") is already assigned to non-dummy instance, skipping...");
        }
      }
    }
  }
}
