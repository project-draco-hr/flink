{
switch (this.jobStatus) {
case CREATED:
    if (jobHasScheduledStatus()) {
      this.jobStatus=InternalJobStatus.SCHEDULED;
    }
 else     if (latestStateChange == ExecutionState.CANCELED) {
      if (jobHasFailedOrCanceledStatus()) {
        this.jobStatus=InternalJobStatus.CANCELED;
      }
    }
  break;
case SCHEDULED:
if (latestStateChange == ExecutionState.RUNNING) {
  this.jobStatus=InternalJobStatus.RUNNING;
  return;
}
 else if (latestStateChange == ExecutionState.CANCELED) {
  if (jobHasFailedOrCanceledStatus()) {
    this.jobStatus=InternalJobStatus.CANCELED;
  }
}
break;
case RUNNING:
if (latestStateChange == ExecutionState.CANCELING || latestStateChange == ExecutionState.CANCELED) {
this.jobStatus=InternalJobStatus.CANCELING;
return;
}
if (latestStateChange == ExecutionState.FAILED) {
final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(this,true);
while (it.hasNext()) {
final ExecutionVertex vertex=it.next();
if (vertex.getExecutionState() == ExecutionState.FAILED && !vertex.hasRetriesLeft()) {
this.jobStatus=InternalJobStatus.FAILING;
return;
}
 else {
this.jobStatus=InternalJobStatus.RECOVERING;
return;
}
}
}
if (latestStateChange == ExecutionState.RECOVERING) {
this.jobStatus=InternalJobStatus.RECOVERING;
return;
}
if (jobHasFinishedStatus()) {
this.jobStatus=InternalJobStatus.FINISHED;
}
break;
case RECOVERING:
if (latestStateChange == ExecutionState.RERUNNING) {
this.recovering.clear();
this.jobStatus=InternalJobStatus.RUNNING;
}
break;
case FAILING:
if (jobHasFailedOrCanceledStatus()) {
this.jobStatus=InternalJobStatus.FAILED;
}
break;
case FAILED:
LOG.error("Received update of execute state in job status FAILED");
break;
case CANCELING:
if (jobHasFailedOrCanceledStatus()) {
this.jobStatus=InternalJobStatus.CANCELED;
}
break;
case CANCELED:
LOG.error("Received update of execute state in job status CANCELED");
break;
case FINISHED:
LOG.error("Received update of execute state in job status FINISHED");
break;
}
}
