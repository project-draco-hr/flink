{
  final ExecutionGroupVertex source=groupEdge.getSourceVertex();
  final int indexOfOutputGate=groupEdge.getIndexOfOutputGate();
  final ExecutionGroupVertex target=groupEdge.getTargetVertex();
  final int indexOfInputGate=groupEdge.getIndexOfInputGate();
  final Map<GateID,List<ExecutionEdge>> inputChannelMap=new HashMap<GateID,List<ExecutionEdge>>();
  final int currentNumberOfSourceNodes=source.getCurrentNumberOfGroupMembers();
  for (int i=0; i < currentNumberOfSourceNodes; ++i) {
    final ExecutionVertex sourceVertex=source.getGroupMember(i);
    final ExecutionGate outputGate=sourceVertex.getOutputGate(indexOfOutputGate);
    if (outputGate == null) {
      throw new IllegalStateException("wire: " + sourceVertex.getName() + " has no output gate with index "+ indexOfOutputGate);
    }
    if (outputGate.getNumberOfEdges() > 0) {
      throw new IllegalStateException("wire: wire called on source " + sourceVertex.getName() + " ("+ i+ "), but number of output channels is "+ outputGate.getNumberOfEdges()+ "!");
    }
    final int currentNumberOfTargetNodes=target.getCurrentNumberOfGroupMembers();
    final List<ExecutionEdge> outputChannels=new ArrayList<ExecutionEdge>();
    for (int j=0; j < currentNumberOfTargetNodes; ++j) {
      final ExecutionVertex targetVertex=target.getGroupMember(j);
      final ExecutionGate inputGate=targetVertex.getInputGate(indexOfInputGate);
      if (inputGate == null) {
        throw new IllegalStateException("wire: " + targetVertex.getName() + " has no input gate with index "+ indexOfInputGate);
      }
      if (inputGate.getNumberOfEdges() > 0 && i == 0) {
        throw new IllegalStateException("wire: wire called on target " + targetVertex.getName() + " ("+ j+ "), but number of input channels is "+ inputGate.getNumberOfEdges()+ "!");
      }
      if (DistributionPatternProvider.createWire(source.getForwardEdge(indexOfOutputGate).getDistributionPattern(),i,j,source.getCurrentNumberOfGroupMembers(),target.getCurrentNumberOfGroupMembers())) {
        final ExecutionEdge edge=new ExecutionEdge(outputGate,inputGate,groupEdge,new ChannelID(),new ChannelID(),outputGate.getNumberOfEdges(),inputGate.getNumberOfEdges());
        this.edgeMap.put(edge.getOutputChannelID(),edge);
        this.edgeMap.put(edge.getInputChannelID(),edge);
        outputChannels.add(edge);
        List<ExecutionEdge> inputChannels=inputChannelMap.get(inputGate.getGateID());
        if (inputChannels == null) {
          inputChannels=new ArrayList<ExecutionEdge>();
          inputChannelMap.put(inputGate.getGateID(),inputChannels);
        }
        inputChannels.add(edge);
      }
      outputGate.replaceAllEdges(outputChannels);
    }
  }
  final int currentNumberOfTargetNodes=target.getCurrentNumberOfGroupMembers();
  for (int i=0; i < currentNumberOfTargetNodes; ++i) {
    final ExecutionVertex targetVertex=target.getGroupMember(i);
    final ExecutionGate inputGate=targetVertex.getInputGate(indexOfInputGate);
    final List<ExecutionEdge> inputChannels=inputChannelMap.get(inputGate.getGateID());
    if (inputChannels == null) {
      LOG.error("Cannot find input channels for gate ID " + inputGate.getGateID());
      continue;
    }
    inputGate.replaceAllEdges(inputChannels);
  }
}
