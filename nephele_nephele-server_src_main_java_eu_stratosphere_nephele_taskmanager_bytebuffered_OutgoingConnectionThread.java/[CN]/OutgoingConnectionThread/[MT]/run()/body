{
  while (!isInterrupted()) {
synchronized (this.pendingConnectionRequests) {
      if (!this.pendingConnectionRequests.isEmpty()) {
        final OutgoingConnection outgoingConnection=this.pendingConnectionRequests.poll();
        try {
          final SocketChannel socketChannel=SocketChannel.open();
          socketChannel.configureBlocking(false);
          final SelectionKey key=socketChannel.register(this.selector,SelectionKey.OP_CONNECT);
          socketChannel.connect(outgoingConnection.getConnectionAddress());
          key.attach(outgoingConnection);
        }
 catch (        IOException ioe) {
          outgoingConnection.reportConnectionProblem(ioe);
        }
      }
    }
synchronized (this.pendingWriteEventSubscribeRequests) {
      if (!this.pendingWriteEventSubscribeRequests.isEmpty()) {
        final SelectionKey oldSelectionKey=this.pendingWriteEventSubscribeRequests.poll();
        final OutgoingConnection outgoingConnection=(OutgoingConnection)oldSelectionKey.attachment();
        final SocketChannel socketChannel=(SocketChannel)oldSelectionKey.channel();
        try {
          final SelectionKey newSelectionKey=socketChannel.register(this.selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
          newSelectionKey.attach(outgoingConnection);
          outgoingConnection.setSelectionKey(newSelectionKey);
        }
 catch (        IOException ioe) {
          outgoingConnection.reportTransmissionProblem(ioe);
        }
      }
    }
synchronized (this.connectionsToClose) {
      final Iterator<Map.Entry<OutgoingConnection,Long>> closeIt=this.connectionsToClose.entrySet().iterator();
      final long now=System.currentTimeMillis();
      while (closeIt.hasNext()) {
        final Map.Entry<OutgoingConnection,Long> entry=closeIt.next();
        if ((entry.getValue().longValue() + MIN_IDLE_TIME_BEFORE_CLOSE) < now) {
          final OutgoingConnection outgoingConnection=entry.getKey();
          closeIt.remove();
          try {
            outgoingConnection.closeConnection();
          }
 catch (          IOException ioe) {
            outgoingConnection.reportTransmissionProblem(ioe);
          }
        }
      }
    }
    try {
      this.selector.select(500);
    }
 catch (    IOException e) {
      LOG.error(e);
    }
    final Iterator<SelectionKey> iter=this.selector.selectedKeys().iterator();
    while (iter.hasNext()) {
      final SelectionKey key=iter.next();
      iter.remove();
      if (key.isValid()) {
        if (key.isConnectable()) {
          doConnect(key);
        }
 else {
          if (key.isReadable()) {
            doRead(key);
            continue;
          }
          if (key.isWritable()) {
            doWrite(key);
          }
        }
      }
 else {
        LOG.error("Received invalid key: " + key);
      }
    }
  }
  try {
    this.selector.close();
  }
 catch (  IOException ioe) {
    LOG.debug(StringUtils.stringifyException(ioe));
  }
}
