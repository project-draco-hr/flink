{
  while (!isInterrupted()) {
synchronized (this.pendingConnectionRequests) {
      if (!this.pendingConnectionRequests.isEmpty()) {
        final long now=System.currentTimeMillis();
        final ConnectionRequest connectionRequest=this.pendingConnectionRequests.peek();
        final long earliest=connectionRequest.earliestConnectionTime;
        if (earliest == -1L || earliest <= now) {
          this.pendingConnectionRequests.poll();
          final OutgoingConnection outgoingConnection=connectionRequest.outgoingConnection;
          try {
            final SocketChannel socketChannel=SocketChannel.open();
            socketChannel.configureBlocking(false);
            final SelectionKey key=socketChannel.register(this.selector,SelectionKey.OP_CONNECT);
            socketChannel.connect(outgoingConnection.getConnectionAddress());
            key.attach(outgoingConnection);
          }
 catch (          final IOException ioe) {
            ioe.printStackTrace();
            final Runnable reporterThread=new Runnable(){
              @Override public void run(){
                outgoingConnection.reportConnectionProblem(ioe);
              }
            }
;
            new Thread(reporterThread).start();
          }
        }
      }
    }
synchronized (this.pendingWriteEventSubscribeRequests) {
      if (!this.pendingWriteEventSubscribeRequests.isEmpty()) {
        final SelectionKey oldSelectionKey=this.pendingWriteEventSubscribeRequests.poll();
        final OutgoingConnection outgoingConnection=(OutgoingConnection)oldSelectionKey.attachment();
        final SocketChannel socketChannel=(SocketChannel)oldSelectionKey.channel();
        try {
          final SelectionKey newSelectionKey=socketChannel.register(this.selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
          newSelectionKey.attach(outgoingConnection);
          outgoingConnection.setSelectionKey(newSelectionKey);
        }
 catch (        final IOException ioe) {
          final Runnable reporterThread=new Runnable(){
            @Override public void run(){
              outgoingConnection.reportTransmissionProblem(ioe);
            }
          }
;
          new Thread(reporterThread).start();
        }
      }
    }
synchronized (this.connectionsToClose) {
      final Iterator<Map.Entry<OutgoingConnection,Long>> closeIt=this.connectionsToClose.entrySet().iterator();
      final long now=System.currentTimeMillis();
      while (closeIt.hasNext()) {
        final Map.Entry<OutgoingConnection,Long> entry=closeIt.next();
        if ((entry.getValue().longValue() + MIN_IDLE_TIME_BEFORE_CLOSE) < now) {
          final OutgoingConnection outgoingConnection=entry.getKey();
          closeIt.remove();
          final Runnable closeThread=new Runnable(){
            @Override public void run(){
              try {
                outgoingConnection.closeConnection();
              }
 catch (              IOException ioe) {
                outgoingConnection.reportTransmissionProblem(ioe);
              }
            }
          }
;
          new Thread(closeThread).start();
        }
      }
    }
    try {
      this.selector.select(10);
    }
 catch (    IOException e) {
      LOG.error(e);
    }
    final Iterator<SelectionKey> iter=this.selector.selectedKeys().iterator();
    while (iter.hasNext()) {
      final SelectionKey key=iter.next();
      iter.remove();
      if (key.isValid()) {
        if (key.isConnectable()) {
          doConnect(key);
        }
 else {
          if (key.isReadable()) {
            doRead(key);
            continue;
          }
          if (key.isWritable()) {
            doWrite(key);
          }
        }
      }
 else {
        LOG.error("Received invalid key: " + key);
      }
    }
  }
  try {
    this.selector.close();
  }
 catch (  IOException ioe) {
    LOG.debug(StringUtils.stringifyException(ioe));
  }
}
