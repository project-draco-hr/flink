{
  ensureBufferAvailability(task);
  RuntimeEnvironment environment=task.getRuntimeEnvironment();
  environment.registerGlobalBufferPool(this.globalBufferPool);
  if (this.localBuffersPools.containsKey(task.getVertexID())) {
    throw new IllegalStateException("Vertex " + task.getVertexID() + " has a previous buffer pool owner");
  }
  for (  OutputGate gate : environment.outputGates()) {
    for (    OutputChannel channel : gate.channels()) {
      channel.registerEnvelopeDispatcher(this);
switch (channel.getChannelType()) {
case IN_MEMORY:
        addReceiverListHint(channel.getID(),channel.getConnectedId());
      break;
case NETWORK:
    addReceiverListHint(channel.getConnectedId(),channel.getID());
  break;
}
this.channels.put(channel.getID(),channel);
}
}
this.localBuffersPools.put(task.getVertexID(),environment);
for (InputGate<?> gate : environment.inputGates()) {
gate.registerGlobalBufferPool(this.globalBufferPool);
for (int i=0; i < gate.getNumberOfInputChannels(); i++) {
InputChannel<? extends IOReadableWritable> channel=gate.getInputChannel(i);
channel.registerEnvelopeDispatcher(this);
if (channel.getChannelType() == ChannelType.IN_MEMORY) {
addReceiverListHint(channel.getID(),channel.getConnectedId());
}
this.channels.put(channel.getID(),channel);
}
this.localBuffersPools.put(gate.getGateID(),gate);
}
redistributeBuffers();
}
