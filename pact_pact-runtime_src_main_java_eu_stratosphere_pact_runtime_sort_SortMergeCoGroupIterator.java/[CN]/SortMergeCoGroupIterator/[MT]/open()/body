{
  this.matchStatus=MatchStatus.NONE_REMAINED;
  if (this.localStrategy == LocalStrategy.SORT_BOTH_MERGE || this.localStrategy == LocalStrategy.SORT_FIRST_MERGE) {
    this.sortMerger1=new UnilateralSortMerger<T1>(this.memoryManager,this.ioManager,this.reader1,this.parentTask,this.serializer1,this.sortingComparator1,this.memoryPerChannel,this.fileHandlesPerChannel,this.spillingThreshold);
  }
  if (this.localStrategy == LocalStrategy.SORT_BOTH_MERGE || this.localStrategy == LocalStrategy.SORT_SECOND_MERGE) {
    this.sortMerger2=new UnilateralSortMerger<T2>(this.memoryManager,this.ioManager,this.reader2,this.parentTask,this.serializer2,this.sortingComparator2,this.memoryPerChannel,this.fileHandlesPerChannel,this.spillingThreshold);
  }
switch (this.localStrategy) {
case SORT_BOTH_MERGE:
    this.iterator1=new KeyGroupedIterator<T1>(this.sortMerger1.getIterator(),this.serializer1,this.groupingComparator1);
  this.iterator2=new KeyGroupedIterator<T2>(this.sortMerger2.getIterator(),this.serializer2,this.groupingComparator2);
break;
case SORT_FIRST_MERGE:
this.iterator1=new KeyGroupedIterator<T1>(this.sortMerger1.getIterator(),this.serializer1,this.groupingComparator1);
this.iterator2=new KeyGroupedIterator<T2>(this.reader2,this.serializer2,this.groupingComparator2);
break;
case SORT_SECOND_MERGE:
this.iterator1=new KeyGroupedIterator<T1>(this.reader1,this.serializer1,this.groupingComparator1);
this.iterator2=new KeyGroupedIterator<T2>(this.sortMerger2.getIterator(),this.serializer2,this.groupingComparator2);
break;
case MERGE:
this.iterator1=new KeyGroupedIterator<T1>(this.reader1,this.serializer1,this.groupingComparator1);
this.iterator2=new KeyGroupedIterator<T2>(this.reader2,this.serializer2,this.groupingComparator2);
break;
default :
throw new RuntimeException("Unsupported Local Strategy in SortMergeCoGroupIterator: " + this.localStrategy);
}
}
