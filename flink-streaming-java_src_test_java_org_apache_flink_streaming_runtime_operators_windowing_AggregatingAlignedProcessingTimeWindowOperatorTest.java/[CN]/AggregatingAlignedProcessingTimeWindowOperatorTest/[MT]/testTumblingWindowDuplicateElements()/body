{
  final ScheduledExecutorService timerService=Executors.newSingleThreadScheduledExecutor();
  try {
    final int windowSize=50;
    final CollectingOutput<Tuple2<Integer,Integer>> out=new CollectingOutput<>(windowSize);
    final Object lock=new Object();
    final StreamTask<?,?> mockTask=createMockTaskWithTimer(timerService,lock);
    AggregatingProcessingTimeWindowOperator<Integer,Tuple2<Integer,Integer>> op=new AggregatingProcessingTimeWindowOperator<>(sumFunction,fieldOneSelector,IntSerializer.INSTANCE,tupleSerializer,windowSize,windowSize);
    op.setup(mockTask,new StreamConfig(new Configuration()),out);
    op.open();
    final int numWindows=10;
    long previousNextTime=0;
    int window=1;
    while (window <= numWindows) {
synchronized (lock) {
        long nextTime=op.getNextEvaluationTime();
        int val=((int)nextTime) ^ ((int)(nextTime >>> 32));
        StreamRecord<Tuple2<Integer,Integer>> next=new StreamRecord<>(new Tuple2<>(val,val));
        op.setKeyContextElement(next);
        op.processElement(next);
        if (nextTime != previousNextTime) {
          window++;
          previousNextTime=nextTime;
        }
      }
      Thread.sleep(1);
    }
synchronized (lock) {
      op.close();
    }
    op.dispose();
    List<Tuple2<Integer,Integer>> result=out.getElements();
    assertTrue(result.size() >= numWindows && result.size() <= 2 * numWindows);
    HashSet<Tuple2<Integer,Integer>> set=new HashSet<>(result);
    assertTrue(set.size() == 10);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    timerService.shutdown();
  }
}
