{
  Object tmpType;
switch (identifier) {
case SOURCE_CSV:
    setID=(Integer)receiver.getRecord(true);
  path=(String)receiver.getRecord();
fieldDelimiter=(String)receiver.getRecord();
lineDelimiter=(String)receiver.getRecord();
tmpType=(Tuple)receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
return;
case SOURCE_TEXT:
setID=(Integer)receiver.getRecord(true);
path=(String)receiver.getRecord();
return;
case SOURCE_VALUE:
setID=(Integer)receiver.getRecord(true);
int valueCount=(Integer)receiver.getRecord(true);
values=new Object[valueCount];
for (int x=0; x < valueCount; x++) {
values[x]=receiver.getRecord();
}
return;
case SOURCE_SEQ:
setID=(Integer)receiver.getRecord(true);
from=(Long)receiver.getRecord();
to=(Long)receiver.getRecord();
return;
case SINK_CSV:
parentID=(Integer)receiver.getRecord(true);
path=(String)receiver.getRecord();
fieldDelimiter=(String)receiver.getRecord();
lineDelimiter=(String)receiver.getRecord();
writeMode=((Integer)receiver.getRecord(true)) == 1 ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE;
return;
case SINK_TEXT:
parentID=(Integer)receiver.getRecord(true);
path=(String)receiver.getRecord();
writeMode=((Integer)receiver.getRecord(true)) == 1 ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE;
return;
case SINK_PRINT:
parentID=(Integer)receiver.getRecord(true);
toError=(Boolean)receiver.getRecord();
return;
case BROADCAST:
parentID=(Integer)receiver.getRecord(true);
otherID=(Integer)receiver.getRecord(true);
name=(String)receiver.getRecord();
return;
}
setID=(Integer)receiver.getRecord(true);
parentID=(Integer)receiver.getRecord(true);
switch (identifier) {
case AGGREGATE:
count=(Integer)receiver.getRecord(true);
aggregates=new AggregationEntry[count];
for (int x=0; x < count; x++) {
int encodedAgg=(Integer)receiver.getRecord(true);
int field=(Integer)receiver.getRecord(true);
aggregates[x]=new AggregationEntry(encodedAgg,field);
}
return;
case FIRST:
count=(Integer)receiver.getRecord(true);
return;
case DISTINCT:
case GROUPBY:
case PARTITION_HASH:
keys=normalizeKeys(receiver.getRecord(true));
return;
case PROJECTION:
fields=toIntArray(receiver.getRecord(true));
return;
case REBALANCE:
return;
case SORT:
field=(Integer)receiver.getRecord(true);
int encodedOrder=(Integer)receiver.getRecord(true);
switch (encodedOrder) {
case 0:
order=Order.NONE;
break;
case 1:
order=Order.ASCENDING;
break;
case 2:
order=Order.DESCENDING;
break;
case 3:
order=Order.ANY;
break;
default :
order=Order.NONE;
break;
}
return;
case UNION:
otherID=(Integer)receiver.getRecord(true);
return;
}
}
