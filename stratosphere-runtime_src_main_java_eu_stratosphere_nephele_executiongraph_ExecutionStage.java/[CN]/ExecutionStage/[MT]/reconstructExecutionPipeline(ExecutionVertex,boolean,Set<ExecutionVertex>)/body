{
  ExecutionPipeline pipeline=vertex.getExecutionPipeline();
  if (pipeline == null) {
    pipeline=new ExecutionPipeline();
    vertex.setExecutionPipeline(pipeline);
  }
  alreadyVisited.add(vertex);
  if (forward) {
    final int numberOfOutputGates=vertex.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final ExecutionGate outputGate=vertex.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfEdges();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final ExecutionEdge outputChannel=outputGate.getEdge(j);
        final ExecutionVertex connectedVertex=outputChannel.getInputGate().getVertex();
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
        if (channelType == ChannelType.IN_MEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          connectedVertex.setExecutionPipeline(pipeline);
          recurse=true;
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,true,alreadyVisited);
        }
      }
    }
  }
 else {
    final int numberOfInputGates=vertex.getNumberOfInputGates();
    for (int i=0; i < numberOfInputGates; ++i) {
      final ExecutionGate inputGate=vertex.getInputGate(i);
      final ChannelType channelType=inputGate.getChannelType();
      final int numberOfInputChannels=inputGate.getNumberOfEdges();
      for (int j=0; j < numberOfInputChannels; ++j) {
        final ExecutionEdge inputChannel=inputGate.getEdge(j);
        final ExecutionVertex connectedVertex=inputChannel.getOutputGate().getVertex();
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
        if (channelType == ChannelType.IN_MEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          connectedVertex.setExecutionPipeline(pipeline);
          recurse=true;
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,false,alreadyVisited);
        }
      }
    }
  }
}
