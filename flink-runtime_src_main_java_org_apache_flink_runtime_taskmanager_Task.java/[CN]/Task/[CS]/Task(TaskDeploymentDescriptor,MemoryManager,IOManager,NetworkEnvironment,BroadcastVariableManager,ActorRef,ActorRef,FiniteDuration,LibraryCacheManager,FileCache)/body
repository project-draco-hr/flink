{
  checkArgument(tdd.getNumberOfSubtasks() > 0);
  checkArgument(tdd.getIndexInSubtaskGroup() >= 0);
  checkArgument(tdd.getIndexInSubtaskGroup() < tdd.getNumberOfSubtasks());
  this.jobId=checkNotNull(tdd.getJobID());
  this.vertexId=checkNotNull(tdd.getVertexID());
  this.executionId=checkNotNull(tdd.getExecutionId());
  this.subtaskIndex=tdd.getIndexInSubtaskGroup();
  this.parallelism=tdd.getNumberOfSubtasks();
  this.taskName=checkNotNull(tdd.getTaskName());
  this.taskNameWithSubtask=getTaskNameWithSubtask(taskName,subtaskIndex,parallelism);
  this.jobConfiguration=checkNotNull(tdd.getJobConfiguration());
  this.taskConfiguration=checkNotNull(tdd.getTaskConfiguration());
  this.requiredJarFiles=checkNotNull(tdd.getRequiredJarFiles());
  this.nameOfInvokableClass=checkNotNull(tdd.getInvokableClassName());
  this.operatorState=tdd.getOperatorState();
  this.memoryManager=checkNotNull(memManager);
  this.ioManager=checkNotNull(ioManager);
  this.broadcastVariableManager=checkNotNull(bcVarManager);
  this.jobManager=checkNotNull(jobManagerActor);
  this.taskManager=checkNotNull(taskManagerActor);
  this.actorAskTimeout=new Timeout(checkNotNull(actorAskTimeout));
  this.libraryCache=checkNotNull(libraryCache);
  this.fileCache=checkNotNull(fileCache);
  this.network=checkNotNull(networkEnvironment);
  this.executionListenerActors=new CopyOnWriteArrayList<ActorRef>();
  final String taskNameWithSubtasksAndId=Task.getTaskNameWithSubtaskAndID(taskName,subtaskIndex,parallelism,executionId);
  List<ResultPartitionDeploymentDescriptor> partitions=tdd.getProducedPartitions();
  List<InputGateDeploymentDescriptor> consumedPartitions=tdd.getInputGates();
  this.producedPartitions=new ResultPartition[partitions.size()];
  this.writers=new ResultPartitionWriter[partitions.size()];
  for (int i=0; i < this.producedPartitions.length; i++) {
    ResultPartitionDeploymentDescriptor desc=partitions.get(i);
    ResultPartitionID partitionId=new ResultPartitionID(desc.getPartitionId(),executionId);
    this.producedPartitions[i]=new ResultPartition(taskNameWithSubtasksAndId,jobId,partitionId,desc.getPartitionType(),desc.getNumberOfSubpartitions(),networkEnvironment.getPartitionManager(),networkEnvironment.getPartitionConsumableNotifier(),ioManager,networkEnvironment.getDefaultIOMode());
    this.writers[i]=new ResultPartitionWriter(this.producedPartitions[i]);
  }
  this.inputGates=new SingleInputGate[consumedPartitions.size()];
  this.inputGatesById=new HashMap<IntermediateDataSetID,SingleInputGate>();
  for (int i=0; i < this.inputGates.length; i++) {
    SingleInputGate gate=SingleInputGate.create(taskNameWithSubtasksAndId,consumedPartitions.get(i),networkEnvironment);
    this.inputGates[i]=gate;
    inputGatesById.put(gate.getConsumedResultId(),gate);
  }
  executingThread=new Thread(TASK_THREADS_GROUP,this,taskNameWithSubtask);
  invokableHasBeenCanceled=new AtomicBoolean(false);
}
