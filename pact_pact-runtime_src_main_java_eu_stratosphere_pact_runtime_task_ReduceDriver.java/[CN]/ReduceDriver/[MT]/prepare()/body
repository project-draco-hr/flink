{
  final TaskConfig config=this.taskContext.getTaskConfig();
  final long availableMemory=config.getMemorySize();
  final int maxFileHandles=config.getNumFilehandles();
  final float spillThreshold=config.getSortSpillingTreshold();
  final LocalStrategy ls=config.getLocalStrategy();
  if ((ls == LocalStrategy.SORT || ls == LocalStrategy.COMBININGSORT) && availableMemory < MIN_REQUIRED_MEMORY) {
    throw new Exception("The Reduce task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ MIN_REQUIRED_MEMORY+ " bytes.");
  }
  final MemoryManager memoryManager=this.taskContext.getMemoryManager();
  final IOManager ioManager=this.taskContext.getIOManager();
  final MutableObjectIterator<IT> in=this.taskContext.getInput(0);
  this.serializer=this.taskContext.getInputSerializer(0);
  this.comparator=this.taskContext.getInputComparator(0);
  TypeComparator<IT> sortComparator=this.taskContext.getSecondarySortComparator(0);
  if (sortComparator == null) {
    sortComparator=this.comparator.duplicate();
  }
switch (config.getLocalStrategy()) {
case NONE:
    this.input=new SimpleCloseableInputProvider<IT>(in);
  break;
case SORT:
this.input=new UnilateralSortMerger<IT>(memoryManager,ioManager,in,this.taskContext.getOwningNepheleTask(),this.serializer,sortComparator,availableMemory,maxFileHandles,spillThreshold);
break;
case COMBININGSORT:
this.input=new CombiningUnilateralSortMerger<IT>(this.taskContext.getStub(),memoryManager,ioManager,in,this.taskContext.getOwningNepheleTask(),this.serializer,sortComparator,availableMemory,maxFileHandles,spillThreshold,false);
break;
default :
throw new Exception("Invalid local strategy provided for ReduceTask: " + ls.name());
}
}
