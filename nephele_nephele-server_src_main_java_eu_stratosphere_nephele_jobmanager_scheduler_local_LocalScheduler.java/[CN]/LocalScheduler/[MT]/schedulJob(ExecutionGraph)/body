{
synchronized (this.jobQueue) {
    final ExecutionGraphIterator it=new ExecutionGraphIterator(executionGraph,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() != ExecutionState.CREATED) {
        LOG.error("Execution vertex " + vertex + " has state "+ vertex.getExecutionState()+ ", expected "+ ExecutionState.CREATED);
      }
      vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
      vertex.setExecutionState(ExecutionState.SCHEDULED);
    }
    this.jobQueue.add(executionGraph);
  }
}
