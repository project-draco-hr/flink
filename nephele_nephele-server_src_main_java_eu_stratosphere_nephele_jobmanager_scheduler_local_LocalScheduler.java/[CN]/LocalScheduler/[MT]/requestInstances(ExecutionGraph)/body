{
  final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
  executionGraph.collectInstanceTypesRequiredForCurrentStage(requiredInstanceTypes,ExecutionState.SCHEDULED);
  if (requiredInstanceTypes.isEmpty()) {
    return;
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,executionGraph.getIndexOfCurrentExecutionStage(),true,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.setExecutionState(ExecutionState.ASSIGNING);
    }
  }
  final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    final InstanceType type=entry.getKey();
    for (int i=0; i < entry.getValue().intValue(); i++) {
      LOG.info("Trying to allocate instance of type " + type.getIdentifier());
      this.instanceManager.requestInstance(executionGraph.getJobID(),executionGraph.getJobConfiguration(),type);
    }
  }
}
