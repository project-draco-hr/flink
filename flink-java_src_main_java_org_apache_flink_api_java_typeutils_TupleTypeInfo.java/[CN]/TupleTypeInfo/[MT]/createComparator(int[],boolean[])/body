{
  if (logicalKeyFields == null || orders == null || logicalKeyFields.length != orders.length || logicalKeyFields.length > types.length) {
    throw new IllegalArgumentException();
  }
  if (logicalKeyFields.length == 1 && logicalKeyFields[0] == 0 && !types[0].isTupleType()) {
    return createLeadingFieldComparator(orders[0],types[0]);
  }
  int maxKey=-1;
  for (  int key : logicalKeyFields) {
    maxKey=Math.max(key,maxKey);
  }
  if (maxKey >= this.types.length) {
    throw new IllegalArgumentException("The key position " + maxKey + " is out of range for Tuple"+ types.length);
  }
  TypeComparator<?>[] fieldComparators=new TypeComparator<?>[logicalKeyFields.length];
  for (int i=0; i < logicalKeyFields.length; i++) {
    int keyPos=logicalKeyFields[i];
    if (types[keyPos].isKeyType() && types[keyPos] instanceof AtomicType) {
      fieldComparators[i]=((AtomicType<?>)types[keyPos]).createComparator(orders[i]);
    }
 else     if (types[keyPos].isTupleType() && types[keyPos] instanceof TupleTypeInfo) {
      TupleTypeInfo<?> tupleType=(TupleTypeInfo<?>)types[keyPos];
      int[] allFieldsKey=new int[tupleType.types.length];
      for (int h=0; h < tupleType.types.length; h++) {
        allFieldsKey[h]=h;
      }
      boolean[] tupleOrders=new boolean[tupleType.types.length];
      Arrays.fill(tupleOrders,orders[i]);
      fieldComparators[i]=tupleType.createComparator(allFieldsKey,tupleOrders);
    }
 else {
      throw new IllegalArgumentException("The field at position " + i + " ("+ types[keyPos]+ ") is no atomic key type nor tuple type.");
    }
  }
  TypeSerializer<?>[] fieldSerializers=new TypeSerializer<?>[maxKey + 1];
  for (int i=0; i <= maxKey; i++) {
    fieldSerializers[i]=types[i].createSerializer();
  }
  return new TupleComparator<T>(logicalKeyFields,fieldComparators,fieldSerializers);
}
