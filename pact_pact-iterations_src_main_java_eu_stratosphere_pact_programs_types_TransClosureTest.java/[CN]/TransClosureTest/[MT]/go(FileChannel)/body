{
  final TypeAccessorsV2<TransitiveClosureEntry> tceAccessors=new TransitiveClosureEntryAccessors();
  final TypeAccessorsV2<LongPair> ipAccessors=new LongPairAccessors();
  final TypeComparator<LongPair,TransitiveClosureEntry> comparator=new LongPairTansClosureComparator();
  final List<MemorySegment> joinMem=this.mMan.allocateStrict(this.memOwner,400 * 1024 / 32,32 * 1024);
  final List<MemorySegment> fifoMem=this.mMan.allocateStrict(this.memOwner,600 * 1024 / 32,32 * 1024);
  final MutableHashTable<TransitiveClosureEntry,LongPair> table=new MutableHashTable<TransitiveClosureEntry,LongPair>(tceAccessors,ipAccessors,comparator,joinMem,this.ioMan,40);
  final SerializedFifoBuffer fifo=new SerializedFifoBuffer(fifoMem,32 * 1024,false);
  final TCReaderItrator inStream=new TCReaderItrator(input,fifo.getWriteEnd(),ipAccessors);
  final long initialBuildStart=System.nanoTime();
  table.open(inStream,EmptyMutableObjectIterator.<LongPair>get());
  final long initialBuildElapsed=System.nanoTime() - initialBuildStart;
  System.out.println("Initial building took " + (initialBuildElapsed / 1000000) + "msecs");
  final DataInputViewV2 inView=fifo.getReadEnd();
  final DataOutputViewV2 outView=fifo.getWriteEnd();
  final LazyTransitiveClosureEntry tcEntry=new LazyTransitiveClosureEntry();
  final LongPair pair=new LongPair();
  long numModifications=0;
  final long iterationStart=System.nanoTime();
  boolean flushed=false;
  while (true) {
    try {
      ipAccessors.deserialize(pair,inView);
      LazyHashBucketIterator<TransitiveClosureEntry,LongPair> matches=table.getLazyMatchesFor(pair);
      while (matches.next(tcEntry)) {
        final long newCid=pair.getValue();
        if (tcEntry.getCid() > newCid) {
          numModifications++;
          flushed=false;
          tcEntry.setCid(newCid);
          long[] neighbors=tcEntry.getNeighbors();
          int numNeighbors=tcEntry.getNumNeighbors();
          for (int i=0; i < numNeighbors; i++) {
            pair.setKey(neighbors[i]);
            ipAccessors.serialize(pair,outView);
          }
        }
      }
    }
 catch (    EOFException eofex) {
      if (!flushed) {
        fifo.flush();
        flushed=true;
      }
 else {
        break;
      }
    }
  }
  final long iterationsElapsed=System.nanoTime() - iterationStart;
  System.out.println("Iterations took " + (iterationsElapsed / 1000000) + "msecs");
  System.out.println("Modifications: " + numModifications);
}
