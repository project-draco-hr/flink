{
  if (args == null || args.length != 4) {
    LOGGER.warn("number of arguments do not match!");
    this.ordersInputPath="";
    this.lineItemInputPath="";
    this.outputPath="";
  }
 else {
    setArgs(args);
  }
  FileDataSource orders=new FileDataSource(new IntTupleDataInFormat(),this.ordersInputPath,"Orders");
  orders.setDegreeOfParallelism(this.degreeOfParallelism);
  FileDataSource lineItems=new FileDataSource(new IntTupleDataInFormat(),this.lineItemInputPath,"LineItems");
  lineItems.setDegreeOfParallelism(this.degreeOfParallelism);
  FileDataSink result=new FileDataSink(new StringTupleDataOutFormat(),this.outputPath,"Output");
  result.setDegreeOfParallelism(degreeOfParallelism);
  MapContract lineFilter=MapContract.builder(LiFilter.class).name("LineItemFilter").build();
  lineFilter.setDegreeOfParallelism(degreeOfParallelism);
  MapContract ordersFilter=MapContract.builder(OFilter.class).name("OrdersFilter").build();
  ordersFilter.setDegreeOfParallelism(degreeOfParallelism);
  MatchContract join=MatchContract.builder(JoinLiO.class,PactInteger.class,0,0).name("OrdersLineitemsJoin").build();
  join.setDegreeOfParallelism(degreeOfParallelism);
  ReduceContract aggregation=ReduceContract.builder(CountAgg.class,PactString.class,0).name("AggregateGroupBy").build();
  aggregation.setDegreeOfParallelism(this.degreeOfParallelism);
  lineFilter.addInput(lineItems);
  ordersFilter.addInput(orders);
  join.addFirstInput(ordersFilter);
  join.addSecondInput(lineFilter);
  aggregation.addInput(join);
  result.addInput(aggregation);
  return new Plan(result,"TPC-H 4");
}
