{
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String paths=(args.length > 1 ? args[1] : "");
  String output=(args.length > 2 ? args[2] : "");
  boolean rdfInput=(args.length > 3 ? Boolean.parseBoolean(args[3]) : false);
  FileDataSource pathsInput;
  if (rdfInput) {
    pathsInput=new FileDataSource(RDFTripleInFormat.class,paths,"RDF Triples");
  }
 else {
    pathsInput=new FileDataSource(PathInFormat.class,paths,"Paths");
  }
  pathsInput.setDegreeOfParallelism(noSubTasks);
  MatchContract concatPaths=new MatchContract(ConcatPaths.class,PactString.class,0,1,"Concat Paths");
  concatPaths.setDegreeOfParallelism(noSubTasks);
  @SuppressWarnings("unchecked") CoGroupContract findShortestPaths=new CoGroupContract(FindShortestPath.class,new Class[]{PactString.class,PactString.class},new int[]{0,1},new int[]{0,1},"Find Shortest Paths");
  findShortestPaths.setDegreeOfParallelism(noSubTasks);
  FileDataSink result=new FileDataSink(PathOutFormat.class,output,"New Paths");
  result.setDegreeOfParallelism(noSubTasks);
  result.addInput(findShortestPaths);
  findShortestPaths.addFirstInput(pathsInput);
  findShortestPaths.addSecondInput(concatPaths);
  concatPaths.addFirstInput(pathsInput);
  concatPaths.addSecondInput(pathsInput);
  return new Plan(result,"Pairwise Shortest Paths");
}
