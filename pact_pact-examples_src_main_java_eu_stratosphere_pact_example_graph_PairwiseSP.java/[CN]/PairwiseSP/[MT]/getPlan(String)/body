{
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String paths=(args.length > 1 ? args[1] : "");
  String output=(args.length > 2 ? args[2] : "");
  boolean rdfInput=(args.length > 3 ? Boolean.parseBoolean(args[3]) : false);
  FileDataSourceContract<NodePair,Path> pathsInput;
  if (rdfInput) {
    pathsInput=new FileDataSourceContract<NodePair,Path>(RDFTripleInFormat.class,paths,"Input RDF Triples");
  }
 else {
    pathsInput=new FileDataSourceContract<NodePair,Path>(PathInFormat.class,paths,"Input Paths");
  }
  pathsInput.setParameter(TextInputFormat.RECORD_DELIMITER,"\n");
  pathsInput.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathStarts=new MapContract<NodePair,Path,PactString,Path>(ProjectPathStart.class,"Project Starts");
  pathStarts.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathEnds=new MapContract<NodePair,Path,PactString,Path>(ProjectPathEnd.class,"Project Ends");
  pathEnds.setDegreeOfParallelism(noSubTasks);
  MatchContract<PactString,Path,Path,NodePair,Path> concatPaths=new MatchContract<PactString,Path,Path,NodePair,Path>(ConcatPaths.class,"Concat Paths");
  concatPaths.setDegreeOfParallelism(noSubTasks);
  CoGroupContract<NodePair,Path,Path,PactNull,Path> findShortestPaths=new CoGroupContract<NodePair,Path,Path,PactNull,Path>(FindShortestPath.class,"Find Shortest Paths");
  findShortestPaths.setDegreeOfParallelism(noSubTasks);
  FileDataSinkContract<PactNull,Path> result=new FileDataSinkContract<PactNull,Path>(PathOutFormat.class,output,"Output Paths");
  result.setDegreeOfParallelism(noSubTasks);
  result.addInput(findShortestPaths);
  findShortestPaths.addFirstInput(pathsInput);
  findShortestPaths.addSecondInput(concatPaths);
  concatPaths.addFirstInput(pathStarts);
  pathStarts.addInput(pathsInput);
  concatPaths.addSecondInput(pathEnds);
  pathEnds.addInput(pathsInput);
  return new Plan(result,"Pairwise Shortest Paths");
}
