{
  boolean tmpBufferUsed=false;
  if (!compressedData.isBackedByMemory()) {
    tmpBufferUsed=true;
    final MemoryBuffer tmpBuffer=this.bufferProvider.lockTemporaryBuffer();
    tmpBuffer.reset(this.bufferProvider.getMaximumBufferSize());
    compressedData.copyToBuffer(tmpBuffer);
    compressedData.recycleBuffer();
    compressedData=tmpBuffer;
  }
  setCompressedDataBuffer((MemoryBuffer)compressedData);
  setUncompressedDataBuffer(this.bufferProvider.lockCompressionBuffer());
  if (this.uncompressedDataBuffer.position() > 0) {
    throw new IllegalStateException("Uncompressed data buffer is expected to be empty");
  }
  this.uncompressedDataBuffer.clear();
  final int result=decompressBytesDirect(SIZE_LENGTH);
  if (result < 0) {
    throw new IOException("Compression libary returned error-code: " + result);
  }
  if (this.uncompressedBuffer.isInWriteMode()) {
    this.uncompressedDataBuffer.position(result);
    this.uncompressedBuffer.finishWritePhase();
  }
 else {
    this.uncompressedDataBuffer.position(0);
    this.uncompressedDataBuffer.limit(result);
  }
  Buffer uncompressedBuffer=this.uncompressedBuffer;
  this.bufferProvider.releaseCompressionBuffer(this.compressedBuffer);
  setCompressedDataBuffer(null);
  setUncompressedDataBuffer(null);
  if (tmpBufferUsed) {
    final MemoryBuffer memBuffer=(MemoryBuffer)uncompressedBuffer;
    final ByteBuffer bb=memBuffer.getByteBuffer();
    uncompressedBuffer=BufferFactory.createFromMemory(bb.remaining(),bb,new MemoryBufferPoolConnector(){
      /** 
 * {@inheritDoc}
 */
      @Override public void recycle(      final ByteBuffer byteBuffer){
        bufferProvider.releaseTemporaryBuffer(memBuffer);
      }
    }
);
    bb.position(bb.limit());
    bb.limit(bb.capacity());
    uncompressedBuffer.finishWritePhase();
  }
  return uncompressedBuffer;
}
