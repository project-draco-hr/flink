{
  final ScheduledExecutorService timerService=Executors.newSingleThreadScheduledExecutor();
  try {
    final CollectingOutput<Integer> out=new CollectingOutput<>(50);
    final StreamingRuntimeContext mockContext=mock(StreamingRuntimeContext.class);
    when(mockContext.getTaskName()).thenReturn("Test task name");
    final Object lock=new Object();
    doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocationOnMock) throws Throwable {
        final Long timestamp=(Long)invocationOnMock.getArguments()[0];
        final Triggerable target=(Triggerable)invocationOnMock.getArguments()[1];
        timerService.schedule(new Callable<Object>(){
          @Override public Object call() throws Exception {
synchronized (lock) {
              target.trigger(timestamp);
            }
            return null;
          }
        }
,timestamp - System.currentTimeMillis(),TimeUnit.MILLISECONDS);
        return null;
      }
    }
).when(mockContext).registerTimer(anyLong(),any(Triggerable.class));
    AggregatingProcessingTimeWindowOperator<Integer,Integer> op=new AggregatingProcessingTimeWindowOperator<>(sumFunction,identitySelector,150,50);
    op.setup(out,mockContext);
    op.open(new Configuration());
synchronized (lock) {
      op.processElement(new StreamRecord<Integer>(1));
      op.processElement(new StreamRecord<Integer>(2));
    }
    out.waitForNElements(6,120000);
    List<Integer> result=out.getElements();
    assertEquals(6,result.size());
    Collections.sort(result);
    assertEquals(Arrays.asList(1,1,1,2,2,2),result);
    op.close();
    op.dispose();
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    timerService.shutdown();
  }
}
