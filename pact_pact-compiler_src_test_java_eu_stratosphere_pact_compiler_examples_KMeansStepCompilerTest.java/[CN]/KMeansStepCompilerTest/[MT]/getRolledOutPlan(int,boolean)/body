{
  final int numSubTasks=DEFAULT_PARALLELISM;
  final String dataPointInput=IN_FILE;
  final String clusterInput=IN_FILE;
  final String output=OUT_FILE;
  FileDataSource dataPoints=new FileDataSource(PointInFormat.class,dataPointInput,DATAPOINTS);
  FileDataSource clusterPoints=new FileDataSource(PointInFormat.class,clusterInput,CENTERS);
  clusterPoints.setDegreeOfParallelism(1);
  if (uniquenessHints) {
    dataPoints.getCompilerHints().addUniqueField(0);
    clusterPoints.getCompilerHints().addUniqueField(0);
  }
  Contract latestCenters=clusterPoints;
  for (int i=0; i < numSteps; i++) {
    CrossContract computeDistance=CrossContract.builder(ComputeDistance.class).input1(dataPoints).input2(latestCenters).name(CROSS_NAME + i).build();
    ReduceContract findNearestClusterCenters=new ReduceContract.Builder(FindNearestCenter.class,PactInteger.class,0).input(computeDistance).name(NEAREST_CENTER_REDUCER + i).build();
    ReduceContract recomputeClusterCenter=new ReduceContract.Builder(RecomputeClusterCenter.class,PactInteger.class,0).input(findNearestClusterCenters).name(RECOMPUTE_CENTERS_REDUCER + i).build();
    latestCenters=recomputeClusterCenter;
  }
  FileDataSink newClusterPoints=new FileDataSink(PointOutFormat.class,output,latestCenters,SINK);
  Plan plan=new Plan(newClusterPoints,"KMeans Iteration (x" + numSteps + ")");
  plan.setDefaultParallelism(numSubTasks);
  return plan;
}
