{
  final long availableMemory=this.config.getMemorySize();
  final int maxFileHandles=this.config.getNumFilehandles();
  final float spillThreshold=this.config.getSortSpillingTreshold();
  final LocalStrategy ls=this.config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case SORT_BOTH_MERGE:
    strategyMinMem=MIN_REQUIRED_MEMORY * 2;
  break;
case SORT_FIRST_MERGE:
case SORT_SECOND_MERGE:
strategyMinMem=MIN_REQUIRED_MEMORY;
break;
case MERGE:
strategyMinMem=0;
break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException("The CoGroup task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ strategyMinMem+ " bytes.");
}
final int[] keyPositions1=this.config.getLocalStrategyKeyPositions(0);
final int[] keyPositions2=this.config.getLocalStrategyKeyPositions(1);
final Class<? extends Key>[] keyClasses=this.config.getLocalStrategyKeyClasses(this.userCodeClassLoader);
if (keyPositions1 == null || keyPositions2 == null || keyClasses == null) {
throw new Exception("The key positions and types are not specified for the CoGroupTask.");
}
if (keyPositions1.length != keyPositions2.length || keyPositions2.length != keyClasses.length) {
throw new Exception("The number of key positions and types does not match in the configuration");
}
final MemoryManager memoryManager=getEnvironment().getMemoryManager();
final IOManager ioManager=getEnvironment().getIOManager();
switch (ls) {
case SORT_BOTH_MERGE:
case SORT_FIRST_MERGE:
case SORT_SECOND_MERGE:
case MERGE:
this.coGroupIterator=new SortMergeCoGroupIterator(memoryManager,ioManager,this.inputs[0],this.inputs[1],keyPositions1,keyPositions2,keyClasses,availableMemory,maxFileHandles,spillThreshold,ls,this);
break;
default :
throw new Exception("Unsupported local strategy for CoGropuTask: " + ls.name());
}
this.coGroupIterator.open();
if (LOG.isDebugEnabled()) LOG.debug(getLogString("CoGroup task iterator ready."));
}
