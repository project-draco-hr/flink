{
  final RichGroupReduceFunction<T,T> function=new DistinctFunction<T>();
  String name=getName() != null ? getName() : "Distinct at " + distinctLocationName;
  if (keys instanceof Keys.ExpressionKeys) {
    int[] logicalKeyPositions=keys.computeLogicalKeyPositions();
    UnaryOperatorInformation<T,T> operatorInfo=new UnaryOperatorInformation<T,T>(getInputType(),getResultType());
    GroupReduceOperatorBase<T,T,GroupReduceFunction<T,T>> po=new GroupReduceOperatorBase<T,T,GroupReduceFunction<T,T>>(function,operatorInfo,logicalKeyPositions,name);
    po.setCombinable(true);
    po.setInput(input);
    po.setDegreeOfParallelism(getParallelism());
    if (getType().isTupleType()) {
      SingleInputSemanticProperties sProps=new SingleInputSemanticProperties();
      for (      int field : keys.computeLogicalKeyPositions()) {
        sProps.setForwardedField(field,new FieldSet(field));
      }
      po.setSemanticProperties(sProps);
    }
    return po;
  }
 else   if (keys instanceof Keys.SelectorFunctionKeys) {
    @SuppressWarnings("unchecked") Keys.SelectorFunctionKeys<T,?> selectorKeys=(Keys.SelectorFunctionKeys<T,?>)keys;
    PlanUnwrappingReduceGroupOperator<T,T,?> po=translateSelectorFunctionDistinct(selectorKeys,function,getInputType(),getResultType(),name,input);
    po.setDegreeOfParallelism(this.getParallelism());
    return po;
  }
 else {
    throw new UnsupportedOperationException("Unrecognized key type.");
  }
}
