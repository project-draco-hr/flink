{
  final GroupReduceFunction<T,T> function=new DistinctFunction<>();
  String name=getName() != null ? getName() : "Distinct at " + distinctLocationName;
  if (keys instanceof Keys.ExpressionKeys) {
    int[] logicalKeyPositions=keys.computeLogicalKeyPositions();
    UnaryOperatorInformation<T,T> operatorInfo=new UnaryOperatorInformation<>(getInputType(),getResultType());
    GroupReduceOperatorBase<T,T,GroupReduceFunction<T,T>> po=new GroupReduceOperatorBase<>(function,operatorInfo,logicalKeyPositions,name);
    po.setCombinable(true);
    po.setInput(input);
    po.setParallelism(getParallelism());
    if (getType().isTupleType()) {
      SingleInputSemanticProperties sProps=new SingleInputSemanticProperties();
      for (      int field : keys.computeLogicalKeyPositions()) {
        sProps.addForwardedField(field,field);
      }
      po.setSemanticProperties(sProps);
    }
    return po;
  }
 else   if (keys instanceof SelectorFunctionKeys) {
    @SuppressWarnings("unchecked") SelectorFunctionKeys<T,?> selectorKeys=(SelectorFunctionKeys<T,?>)keys;
    PlanUnwrappingReduceGroupOperator<T,T,?> po=translateSelectorFunctionDistinct(selectorKeys,function,getResultType(),name,input);
    po.setParallelism(this.getParallelism());
    return po;
  }
 else {
    throw new UnsupportedOperationException("Unrecognized key type.");
  }
}
