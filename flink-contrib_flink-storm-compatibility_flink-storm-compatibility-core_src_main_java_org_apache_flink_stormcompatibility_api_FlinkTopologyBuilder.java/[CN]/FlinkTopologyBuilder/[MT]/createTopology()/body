{
  final StormTopology stormTopolgoy=this.stormBuilder.createTopology();
  final FlinkTopology env=new FlinkTopology(stormTopolgoy);
  env.setParallelism(1);
  final HashMap<String,SingleOutputStreamOperator> availableOperators=new HashMap<String,SingleOutputStreamOperator>();
  for (  final Entry<String,IRichSpout> spout : this.spouts.entrySet()) {
    final String spoutId=spout.getKey();
    final IRichSpout userSpout=spout.getValue();
    final FlinkOutputFieldsDeclarer declarer=new FlinkOutputFieldsDeclarer();
    userSpout.declareOutputFields(declarer);
    this.outputSchemas.put(spoutId,declarer.outputSchema);
    declarers.put(spoutId,declarer);
    AbstractStormSpoutWrapper spoutWrapper;
    if (userSpout instanceof FiniteStormSpout) {
      spoutWrapper=new FiniteStormSpoutWrapper((FiniteStormSpout)userSpout);
    }
 else {
      spoutWrapper=new StormSpoutWrapper(userSpout);
    }
    final DataStreamSource source=env.addSource(spoutWrapper,declarer.getOutputType());
    availableOperators.put(spoutId,source);
    int dop=1;
    final ComponentCommon common=stormTopolgoy.get_spouts().get(spoutId).get_common();
    if (common.is_set_parallelism_hint()) {
      dop=common.get_parallelism_hint();
      source.setParallelism(dop);
    }
    env.increaseNumberOfTasks(dop);
  }
  final HashMap<String,IRichBolt> unprocessedBolts=new HashMap<String,IRichBolt>();
  unprocessedBolts.putAll(this.bolts);
  final HashMap<String,Set<Entry<GlobalStreamId,Grouping>>> unprocessdInputsPerBolt=new HashMap<String,Set<Entry<GlobalStreamId,Grouping>>>();
  while (unprocessedBolts.size() > 0) {
    final Iterator<Entry<String,IRichBolt>> boltsIterator=unprocessedBolts.entrySet().iterator();
    while (boltsIterator.hasNext()) {
      final Entry<String,IRichBolt> bolt=boltsIterator.next();
      final String boltId=bolt.getKey();
      final IRichBolt userBolt=bolt.getValue();
      final FlinkOutputFieldsDeclarer declarer=new FlinkOutputFieldsDeclarer();
      userBolt.declareOutputFields(declarer);
      this.outputSchemas.put(boltId,declarer.outputSchema);
      declarers.put(boltId,declarer);
      final ComponentCommon common=stormTopolgoy.get_bolts().get(boltId).get_common();
      Set<Entry<GlobalStreamId,Grouping>> unprocessedInputs=unprocessdInputsPerBolt.get(boltId);
      if (unprocessedInputs == null) {
        unprocessedInputs=new HashSet<Entry<GlobalStreamId,Grouping>>();
        unprocessedInputs.addAll(common.get_inputs().entrySet());
        unprocessdInputsPerBolt.put(boltId,unprocessedInputs);
      }
      final Iterator<Entry<GlobalStreamId,Grouping>> inputStreamsIterator=unprocessedInputs.iterator();
      while (inputStreamsIterator.hasNext()) {
        final Entry<GlobalStreamId,Grouping> inputStream=inputStreamsIterator.next();
        final String producerId=inputStream.getKey().get_componentId();
        DataStream<?> inputDataStream=availableOperators.get(producerId);
        if (inputDataStream != null) {
          final Grouping grouping=inputStream.getValue();
          if (grouping.is_set_shuffle()) {
            inputDataStream=inputDataStream.rebalance();
          }
 else           if (grouping.is_set_fields()) {
            final List<String> fields=grouping.get_fields();
            if (fields.size() > 0) {
              FlinkOutputFieldsDeclarer procDeclarer=this.declarers.get(producerId);
              inputDataStream=inputDataStream.groupBy(procDeclarer.getGroupingFieldIndexes(grouping.get_fields()));
            }
 else {
              inputDataStream=inputDataStream.global();
            }
          }
 else           if (grouping.is_set_all()) {
            inputDataStream=inputDataStream.broadcast();
          }
 else           if (!grouping.is_set_local_or_shuffle()) {
            throw new UnsupportedOperationException("Flink only supports (local-or-)shuffle, fields, all, and global grouping");
          }
          final TypeInformation<?> outType=declarer.getOutputType();
          final SingleOutputStreamOperator operator=inputDataStream.transform(boltId,outType,new StormBoltWrapper(userBolt,this.outputSchemas.get(producerId)));
          if (outType != null) {
            availableOperators.put(boltId,operator);
          }
          int dop=1;
          if (common.is_set_parallelism_hint()) {
            dop=common.get_parallelism_hint();
            operator.setParallelism(dop);
          }
          env.increaseNumberOfTasks(dop);
          inputStreamsIterator.remove();
        }
      }
      if (unprocessedInputs.size() == 0) {
        boltsIterator.remove();
      }
    }
  }
  return env;
}
