{
  final Random rnd=new Random(236976457234657898l);
  final AbstractInvokable memOwner=new DefaultMemoryManagerTest.DummyInvokable();
  final int NUM_CHANNELS=29;
  final int NUMBERS_TO_BE_WRITTEN=NUM_CHANNELS * 100000;
  final int minSegmentSize=4 * 1024;
  final int maxSegmentSize=SEGMENT_SIZE / NUM_CHANNELS;
  Channel.ID[] ids=new Channel.ID[NUM_CHANNELS];
  Writer[] writers=new Writer[NUM_CHANNELS];
  Reader[] readers=new Reader[NUM_CHANNELS];
  int[] writingCounters=new int[NUM_CHANNELS];
  int[] readingCounters=new int[NUM_CHANNELS];
  for (int i=0; i < NUM_CHANNELS; i++) {
    ids[i]=this.ioManager.createChannel();
    final int segmentSize=rnd.nextInt(maxSegmentSize - minSegmentSize) + minSegmentSize;
    Collection<MemorySegment> memSegs=memoryManager.allocate(memOwner,rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2,segmentSize);
    writers[i]=ioManager.createChannelWriter(ids[i],memSegs);
  }
  Value val=new Value();
  for (int i=0; i < NUMBERS_TO_BE_WRITTEN; i++) {
    int channel=skewedSample(rnd,NUM_CHANNELS - 1);
    val.value=String.valueOf(writingCounters[channel]++);
    writers[channel].write(val);
  }
  for (int i=0; i < NUM_CHANNELS; i++) {
    memoryManager.release(writers[i].close());
  }
  writers=null;
  for (int i=0; i < NUM_CHANNELS; i++) {
    final int segmentSize=rnd.nextInt(maxSegmentSize - minSegmentSize) + minSegmentSize;
    Collection<MemorySegment> memSegs=memoryManager.allocate(memOwner,rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2,segmentSize);
    Reader reader=ioManager.createChannelReader(ids[i],memSegs,false);
    int nextVal=0;
    while (reader.read(val)) {
      int intValue=0;
      try {
        intValue=Integer.parseInt(val.value);
      }
 catch (      NumberFormatException nfex) {
        Assert.fail("Invalid value read from reader. Valid decimal number expected.");
      }
      Assert.assertEquals("Written and read values do not match during sequential read.",nextVal,intValue);
      nextVal++;
    }
    Assert.assertEquals("NUmber of written numbers differs from number of read numbers.",writingCounters[i],nextVal);
    memoryManager.release(reader.close());
  }
  for (int i=0; i < NUM_CHANNELS; i++) {
    final int segmentSize=rnd.nextInt(maxSegmentSize - minSegmentSize) + minSegmentSize;
    Collection<MemorySegment> memSegs=memoryManager.allocate(memOwner,rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2,segmentSize);
    readers[i]=ioManager.createChannelReader(ids[i],memSegs,true);
  }
  for (int i=0; i < NUMBERS_TO_BE_WRITTEN; i++) {
    int channel=skewedSample(rnd,NUM_CHANNELS - 1);
    if (!readers[channel].read(val)) {
      continue;
    }
    int intValue=0;
    try {
      intValue=Integer.parseInt(val.value);
    }
 catch (    NumberFormatException nfex) {
      Assert.fail("Invalid value read from reader. Valid decimal number expected.");
    }
    Assert.assertEquals("Written and read values do not match.",readingCounters[channel]++,intValue);
  }
  for (int i=0; i < NUM_CHANNELS; i++) {
    memoryManager.release(readers[i].close());
  }
  readers=null;
}
