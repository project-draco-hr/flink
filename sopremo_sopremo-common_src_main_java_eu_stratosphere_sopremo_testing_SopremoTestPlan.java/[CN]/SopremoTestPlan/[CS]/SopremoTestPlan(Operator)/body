{
  final List<JsonStream> unconnectedOutputs=new ArrayList<JsonStream>();
  final List<Operator> unconnectedInputs=new ArrayList<Operator>();
  for (  final Operator operator : sinks) {
    unconnectedOutputs.addAll(operator.getOutputs());
    if (operator instanceof Sink)     unconnectedOutputs.add(operator);
  }
  for (  final Operator operator : OneTimeTraverser.INSTANCE.getReachableNodes(sinks,OperatorNavigator.INSTANCE))   if (operator instanceof Source)   unconnectedInputs.add(operator);
 else   for (  final Operator.Output input : operator.getInputs())   if (input == null)   unconnectedInputs.add(operator);
  this.inputs=new Input[unconnectedInputs.size()];
  for (int index=0; index < this.inputs.length; index++) {
    this.inputs[index]=new Input(index);
    final Operator unconnectedNode=unconnectedInputs.get(index);
    if (unconnectedNode instanceof Source)     this.setInputOperator(index,(Source)unconnectedNode);
 else {
      final List<Operator.Output> missingInputs=new ArrayList<Operator.Output>(unconnectedNode.getInputs());
      for (int missingIndex=0; missingIndex < missingInputs.size(); missingIndex++)       if (missingInputs.get(missingIndex) == null) {
        missingInputs.set(missingIndex,this.inputs[index].getOperator().getOutput(0));
        break;
      }
      unconnectedNode.setInputs(missingInputs);
    }
  }
  this.actualOutputs=new ActualOutput[unconnectedOutputs.size()];
  this.expectedOutputs=new ExpectedOutput[unconnectedOutputs.size()];
  for (int index=0; index < this.actualOutputs.length; index++) {
    this.actualOutputs[index]=new ActualOutput(index);
    if (unconnectedOutputs.get(index) instanceof Sink)     this.actualOutputs[index].setOperator((Sink)unconnectedOutputs.get(index));
 else     this.actualOutputs[index].getOperator().setInput(0,unconnectedOutputs.get(index));
    this.expectedOutputs[index]=new ExpectedOutput(index);
  }
}
