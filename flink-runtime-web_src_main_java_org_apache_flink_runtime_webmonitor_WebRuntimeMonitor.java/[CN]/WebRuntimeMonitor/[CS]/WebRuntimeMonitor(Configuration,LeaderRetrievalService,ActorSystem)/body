{
  this.leaderRetrievalService=checkNotNull(leaderRetrievalService);
  final WebMonitorConfig cfg=new WebMonitorConfig(config);
  String fileName=String.format("flink-web-%s",UUID.randomUUID().toString());
  webRootDir=new File(System.getProperty("java.io.tmpdir"),fileName);
  LOG.info("Using directory {} for the web interface files",webRootDir);
  final String flinkRoot=config.getString(ConfigConstants.FLINK_BASE_DIR_PATH_KEY,null);
  final String defaultLogDirectory=flinkRoot + "/log";
  final String logDirectories=config.getString(ConfigConstants.JOB_MANAGER_WEB_LOG_PATH_KEY,defaultLogDirectory);
  final ArrayList<String> logPaths=new ArrayList<>();
  final ArrayList<String> outPaths=new ArrayList<>();
  for (  String paths : logDirectories.split(",")) {
    File dir=new File(paths);
    if (dir.exists() && dir.isDirectory() && dir.canRead()) {
      if (dir.listFiles(LOG_FILE_PATTERN).length == 1) {
        logPaths.add(paths);
      }
      if (dir.listFiles(STDOUT_FILE_PATTERN).length == 1) {
        outPaths.add(paths);
      }
    }
  }
  if (logPaths.size() != 1 || outPaths.size() != 1) {
    throw new IllegalConfigurationException("The path to the log and out files (" + logDirectories + ") is not valid.");
  }
  final File logDir=new File(logPaths.get(0));
  final File outDir=new File(outPaths.get(0));
  LOG.info("Serving job manager logs from {}",logDir.getAbsolutePath());
  LOG.info("Serving job manager stdout from {}",outDir.getAbsolutePath());
  this.configuredPort=cfg.getWebFrontendPort();
  if (this.configuredPort < 0) {
    throw new IllegalArgumentException("Web frontend port is invalid: " + this.configuredPort);
  }
  timeout=AkkaUtils.getTimeout(config);
  FiniteDuration lookupTimeout=AkkaUtils.getTimeout(config);
  retriever=new JobManagerRetriever(this,actorSystem,lookupTimeout,timeout);
  ExecutionGraphHolder currentGraphs=new ExecutionGraphHolder();
  router=new Router().GET("/config",handler(new DashboardConfigHandler(cfg.getRefreshInterval()))).GET("/overview",handler(new ClusterOverviewHandler(DEFAULT_REQUEST_TIMEOUT))).GET("/jobmanager/config",handler(new JobManagerConfigHandler(config))).GET("/joboverview",handler(new CurrentJobsOverviewHandler(DEFAULT_REQUEST_TIMEOUT,true,true))).GET("/joboverview/running",handler(new CurrentJobsOverviewHandler(DEFAULT_REQUEST_TIMEOUT,true,false))).GET("/joboverview/completed",handler(new CurrentJobsOverviewHandler(DEFAULT_REQUEST_TIMEOUT,false,true))).GET("/jobs",handler(new CurrentJobIdsHandler(retriever,DEFAULT_REQUEST_TIMEOUT))).GET("/jobs/:jobid",handler(new JobDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices",handler(new JobDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid",handler(new JobVertexDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasktimes",handler(new SubtasksTimesHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/accumulators",handler(new JobVertexAccumulatorsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/accumulators",handler(new SubtasksAllAccumulatorsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/:subtasknum",handler(new SubtaskCurrentAttemptDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/:subtasknum/attempts/:attempt",handler(new SubtaskExecutionAttemptDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/:subtasknum/attempts/:attempt/accumulators",handler(new SubtaskExecutionAttemptAccumulatorsHandler(currentGraphs))).GET("/jobs/:jobid/plan",handler(new JobPlanHandler(currentGraphs))).GET("/jobs/:jobid/config",handler(new JobConfigHandler(currentGraphs))).GET("/jobs/:jobid/exceptions",handler(new JobExceptionsHandler(currentGraphs))).GET("/jobs/:jobid/accumulators",handler(new JobAccumulatorsHandler(currentGraphs))).GET("/taskmanagers",handler(new TaskManagersHandler(DEFAULT_REQUEST_TIMEOUT))).GET("/taskmanagers/:" + TaskManagersHandler.TASK_MANAGER_ID_KEY,handler(new TaskManagersHandler(DEFAULT_REQUEST_TIMEOUT))).GET("/jobmanager/log",new StaticFileServerHandler(retriever,jobManagerAddressPromise.future(),timeout,logDir)).GET("/jobmanager/stdout",new StaticFileServerHandler(retriever,jobManagerAddressPromise.future(),timeout,outDir)).GET("/:*",new StaticFileServerHandler(retriever,jobManagerAddressPromise.future(),timeout,webRootDir));
synchronized (startupShutdownLock) {
    try {
      Runtime.getRuntime().addShutdownHook(new Thread(){
        @Override public void run(){
          shutdown();
        }
      }
);
    }
 catch (    IllegalStateException e) {
      LOG.debug("Unable to add shutdown hook, shutdown already in progress",e);
    }
catch (    Throwable t) {
      LOG.warn("Error while adding shutdown hook",t);
    }
    ChannelInitializer<SocketChannel> initializer=new ChannelInitializer<SocketChannel>(){
      @Override protected void initChannel(      SocketChannel ch){
        Handler handler=new Handler(router);
        ch.pipeline().addLast(new HttpServerCodec()).addLast(new HttpObjectAggregator(65536)).addLast(new ChunkedWriteHandler()).addLast(handler.name(),handler);
      }
    }
;
    NioEventLoopGroup bossGroup=new NioEventLoopGroup(1);
    NioEventLoopGroup workerGroup=new NioEventLoopGroup();
    this.bootstrap=new ServerBootstrap();
    this.bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(initializer);
    Channel ch=this.bootstrap.bind(configuredPort).sync().channel();
    this.serverChannel=ch;
    InetSocketAddress bindAddress=(InetSocketAddress)ch.localAddress();
    String address=bindAddress.getAddress().getHostAddress();
    int port=bindAddress.getPort();
    LOG.info("Web frontend listening at " + address + ':'+ port);
  }
}
