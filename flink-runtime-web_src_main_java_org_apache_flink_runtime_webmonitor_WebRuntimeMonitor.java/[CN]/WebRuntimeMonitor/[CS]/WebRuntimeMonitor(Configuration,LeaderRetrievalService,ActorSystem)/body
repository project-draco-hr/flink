{
  this.leaderRetrievalService=checkNotNull(leaderRetrievalService);
  final WebMonitorConfig cfg=new WebMonitorConfig(config);
  String fileName=String.format("flink-web-%s",UUID.randomUUID().toString());
  webRootDir=new File(System.getProperty("java.io.tmpdir"),fileName);
  fileName=String.format("flink-web-upload-%s",UUID.randomUUID().toString());
  uploadDir=new File(System.getProperty("java.io.tmpdir"),fileName);
  if (!uploadDir.mkdir() || !uploadDir.canWrite()) {
    throw new IOException("Unable to create temporary directory to support jar uploads.");
  }
  LOG.info("Using directory {} for the web interface files",webRootDir);
  LOG.info("Using directory {} for web frontend JAR file uploads",uploadDir);
  final WebMonitorUtils.LogFileLocation logFiles=WebMonitorUtils.LogFileLocation.find(config);
  final boolean webSubmitAllow=config.getBoolean(ConfigConstants.JOB_MANAGER_WEB_SUBMISSION_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_WEB_SUBMISSION);
  int configuredPort=cfg.getWebFrontendPort();
  if (configuredPort < 0) {
    throw new IllegalArgumentException("Web frontend port is invalid: " + configuredPort);
  }
  timeout=AkkaUtils.getTimeout(config);
  FiniteDuration lookupTimeout=AkkaUtils.getTimeout(config);
  retriever=new JobManagerRetriever(this,actorSystem,lookupTimeout,timeout);
  ExecutionGraphHolder currentGraphs=new ExecutionGraphHolder();
  router=new Router().GET("/config",handler(new DashboardConfigHandler(cfg.getRefreshInterval()))).GET("/overview",handler(new ClusterOverviewHandler(DEFAULT_REQUEST_TIMEOUT))).GET("/jobmanager/config",handler(new JobManagerConfigHandler(config))).GET("/joboverview",handler(new CurrentJobsOverviewHandler(DEFAULT_REQUEST_TIMEOUT,true,true))).GET("/joboverview/running",handler(new CurrentJobsOverviewHandler(DEFAULT_REQUEST_TIMEOUT,true,false))).GET("/joboverview/completed",handler(new CurrentJobsOverviewHandler(DEFAULT_REQUEST_TIMEOUT,false,true))).GET("/jobs",handler(new CurrentJobIdsHandler(retriever,DEFAULT_REQUEST_TIMEOUT))).GET("/jobs/:jobid",handler(new JobDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices",handler(new JobDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid",handler(new JobVertexDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasktimes",handler(new SubtasksTimesHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/accumulators",handler(new JobVertexAccumulatorsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/checkpoints",handler(new JobVertexCheckpointsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/accumulators",handler(new SubtasksAllAccumulatorsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/:subtasknum",handler(new SubtaskCurrentAttemptDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/:subtasknum/attempts/:attempt",handler(new SubtaskExecutionAttemptDetailsHandler(currentGraphs))).GET("/jobs/:jobid/vertices/:vertexid/subtasks/:subtasknum/attempts/:attempt/accumulators",handler(new SubtaskExecutionAttemptAccumulatorsHandler(currentGraphs))).GET("/jobs/:jobid/plan",handler(new JobPlanHandler(currentGraphs))).GET("/jobs/:jobid/config",handler(new JobConfigHandler(currentGraphs))).GET("/jobs/:jobid/exceptions",handler(new JobExceptionsHandler(currentGraphs))).GET("/jobs/:jobid/accumulators",handler(new JobAccumulatorsHandler(currentGraphs))).GET("/jobs/:jobid/checkpoints",handler(new JobCheckpointsHandler(currentGraphs))).GET("/taskmanagers",handler(new TaskManagersHandler(DEFAULT_REQUEST_TIMEOUT))).GET("/taskmanagers/:" + TaskManagersHandler.TASK_MANAGER_ID_KEY,handler(new TaskManagersHandler(DEFAULT_REQUEST_TIMEOUT))).GET("/jobmanager/log",logFiles.logFile == null ? new ConstantTextHandler("(log file unavailable)") : new StaticFileServerHandler(retriever,jobManagerAddressPromise.future(),timeout,logFiles.logFile)).GET("/jobmanager/stdout",logFiles.stdOutFile == null ? new ConstantTextHandler("(stdout file unavailable)") : new StaticFileServerHandler(retriever,jobManagerAddressPromise.future(),timeout,logFiles.stdOutFile)).GET("/jobs/:jobid/yarn-cancel",handler(new JobCancellationHandler())).DELETE("/jobs/:jobid",handler(new JobCancellationHandler()));
  if (webSubmitAllow) {
    router.GET("/jars",handler(new JarListHandler(uploadDir))).GET("/jars/:jarid/plan",handler(new JarPlanHandler(uploadDir))).POST("/jars/:jarid/run",handler(new JarRunHandler(uploadDir,timeout))).POST("/jars/upload",handler(new JarUploadHandler(uploadDir))).DELETE("/jars/:jarid",handler(new JarDeleteHandler(uploadDir)));
  }
 else {
    router.GET("/jars",handler(new JarAccessDeniedHandler()));
  }
  router.GET("/:*",new StaticFileServerHandler(retriever,jobManagerAddressPromise.future(),timeout,webRootDir));
synchronized (startupShutdownLock) {
    try {
      Runtime.getRuntime().addShutdownHook(new Thread(){
        @Override public void run(){
          shutdown();
        }
      }
);
    }
 catch (    IllegalStateException e) {
      LOG.debug("Unable to add shutdown hook, shutdown already in progress",e);
    }
catch (    Throwable t) {
      LOG.warn("Error while adding shutdown hook",t);
    }
    ChannelInitializer<SocketChannel> initializer=new ChannelInitializer<SocketChannel>(){
      @Override protected void initChannel(      SocketChannel ch){
        Handler handler=new Handler(router);
        ch.pipeline().addLast(new HttpServerCodec()).addLast(new HttpRequestHandler(uploadDir)).addLast(handler.name(),handler).addLast(new PipelineErrorHandler());
      }
    }
;
    NioEventLoopGroup bossGroup=new NioEventLoopGroup(1);
    NioEventLoopGroup workerGroup=new NioEventLoopGroup();
    this.bootstrap=new ServerBootstrap();
    this.bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(initializer);
    Channel ch=this.bootstrap.bind(configuredPort).sync().channel();
    this.serverChannel=ch;
    InetSocketAddress bindAddress=(InetSocketAddress)ch.localAddress();
    String address=bindAddress.getAddress().getHostAddress();
    int port=bindAddress.getPort();
    LOG.info("Web frontend listening at " + address + ':'+ port);
  }
}
