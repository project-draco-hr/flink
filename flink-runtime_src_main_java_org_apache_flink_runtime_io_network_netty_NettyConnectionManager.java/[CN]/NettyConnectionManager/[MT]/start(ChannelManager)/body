{
  LOG.info(String.format("Starting with %d incoming and %d outgoing connection threads.",numInThreads,numOutThreads));
  LOG.info(String.format("Setting low water mark to %d and high water mark to %d bytes.",lowWaterMark,highWaterMark));
  final BufferProviderBroker bufferProviderBroker=channelManager;
  final EnvelopeDispatcher envelopeDispatcher=channelManager;
  int numHeapArenas=0;
  int numDirectArenas=numInThreads + numOutThreads;
  int pageSize=bufferSize << 1;
  int chunkSize=16 * 1 << 20;
  int maxOrder=(int)(Math.log(chunkSize / pageSize) / Math.log(2));
  PooledByteBufAllocator pooledByteBufAllocator=new PooledByteBufAllocator(true,numHeapArenas,numDirectArenas,pageSize,maxOrder);
  String msg=String.format("Instantiated PooledByteBufAllocator with direct arenas: %d, heap arenas: %d, " + "page size (bytes): %d, chunk size (bytes): %d.",numDirectArenas,numHeapArenas,pageSize,(pageSize << maxOrder));
  LOG.info(msg);
  in=new ServerBootstrap();
  in.group(new NioEventLoopGroup(numInThreads)).channel(NioServerSocketChannel.class).localAddress(bindAddress,bindPort).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel channel) throws Exception {
      channel.pipeline().addLast(new InboundEnvelopeDecoder(bufferProviderBroker)).addLast(new InboundEnvelopeDispatcher(envelopeDispatcher));
    }
  }
).option(ChannelOption.RCVBUF_ALLOCATOR,new FixedRecvByteBufAllocator(pageSize)).option(ChannelOption.ALLOCATOR,pooledByteBufAllocator);
  out=new Bootstrap();
  out.group(new NioEventLoopGroup(numOutThreads)).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel channel) throws Exception {
      channel.pipeline().addLast(new OutboundEnvelopeEncoder());
    }
  }
).option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK,lowWaterMark).option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK,highWaterMark).option(ChannelOption.ALLOCATOR,pooledByteBufAllocator).option(ChannelOption.TCP_NODELAY,false).option(ChannelOption.SO_KEEPALIVE,true);
  try {
    in.bind().sync();
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (LOG.isDebugEnabled()) {
    debugThread=new Thread(new Runnable(){
      @Override public void run(){
        Date date=new Date();
        while (true) {
          if (Thread.interrupted()) {
            break;
          }
          try {
            Thread.sleep(DEBUG_PRINT_QUEUED_ENVELOPES_EVERY_MS);
            date.setTime(System.currentTimeMillis());
            System.out.println(date);
            System.out.println(getNonZeroNumQueuedEnvelopes());
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
    }
);
    debugThread.start();
  }
}
