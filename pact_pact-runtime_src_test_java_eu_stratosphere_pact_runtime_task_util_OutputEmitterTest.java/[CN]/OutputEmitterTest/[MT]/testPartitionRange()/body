{
  final Random rnd=new Random(SEED);
  final int DISTR_MIN=0;
  final int DISTR_MAX=1000000;
  final int DISTR_RANGE=DISTR_MAX - DISTR_MIN + 1;
  final int NUM_BUCKETS=137;
  final float BUCKET_WIDTH=DISTR_RANGE / ((float)NUM_BUCKETS);
  final int NUM_ELEMENTS=10000000;
  final DataDistribution<PactRecord> distri=new IntegerUniformDistribution(DISTR_MIN,DISTR_MAX);
  @SuppressWarnings("unchecked") final TypeComparator<PactRecord> intComp=new PactRecordComparatorFactory(new int[]{0},new Class[]{PactInteger.class}).createComparator();
  final ChannelSelector<SerializationDelegate<PactRecord>> oe=new OutputEmitter<PactRecord>(ShipStrategyType.PARTITION_RANGE,intComp,distri);
  final SerializationDelegate<PactRecord> delegate=new SerializationDelegate<PactRecord>(new PactRecordSerializerFactory().getSerializer());
  final PactInteger integer=new PactInteger();
  final PactRecord rec=new PactRecord();
  for (int i=0; i < NUM_ELEMENTS; i++) {
    final int nextValue=rnd.nextInt(DISTR_RANGE) + DISTR_MIN;
    integer.setValue(nextValue);
    rec.setField(0,integer);
    delegate.setInstance(rec);
    final int[] channels=oe.selectChannels(delegate,NUM_BUCKETS);
    if (channels.length != 1) {
      Assert.fail("Resulting channels array has more than one channel.");
    }
    final int bucket=channels[0];
    final int shouldBeBucket=(int)((nextValue - DISTR_MIN) / BUCKET_WIDTH);
    if (shouldBeBucket != bucket) {
      final int lowerBoundaryForSelectedBucket=DISTR_MIN + (int)((bucket) * BUCKET_WIDTH);
      final int upperBoundaryForSelectedBucket=DISTR_MIN + (int)((bucket + 1) * BUCKET_WIDTH);
      if (nextValue <= lowerBoundaryForSelectedBucket || nextValue > upperBoundaryForSelectedBucket) {
        Assert.fail("Wrong bucket selected");
      }
    }
  }
}
