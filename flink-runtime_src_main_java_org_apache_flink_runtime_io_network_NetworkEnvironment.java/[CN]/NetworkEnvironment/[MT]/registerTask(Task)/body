{
  final ResultPartition[] producedPartitions=task.getProducedPartitions();
  final ResultPartitionWriter[] writers=task.getWriters();
  if (writers.length != producedPartitions.length) {
    throw new IllegalStateException("Unequal number of writers and partitions.");
  }
  for (int i=0; i < producedPartitions.length; i++) {
    final ResultPartition partition=producedPartitions[i];
    final ResultPartitionWriter writer=writers[i];
    BufferPool bufferPool=null;
    try {
      bufferPool=networkBufferPool.createBufferPool(partition.getNumberOfSubpartitions(),false);
      partition.registerBufferPool(bufferPool);
      partitionManager.registerResultPartition(partition);
    }
 catch (    Throwable t) {
      if (bufferPool != null) {
        bufferPool.lazyDestroy();
      }
      if (t instanceof IOException) {
        throw (IOException)t;
      }
 else {
        throw new IOException(t.getMessage(),t);
      }
    }
    taskEventDispatcher.registerWriterForIncomingTaskEvents(writer.getPartitionId(),writer);
  }
  final SingleInputGate[] inputGates=task.getInputGates();
  for (  SingleInputGate gate : inputGates) {
    BufferPool bufferPool=null;
    try {
      bufferPool=networkBufferPool.createBufferPool(gate.getNumberOfInputChannels(),false);
      gate.setBufferPool(bufferPool);
    }
 catch (    Throwable t) {
      if (bufferPool != null) {
        bufferPool.lazyDestroy();
      }
      if (t instanceof IOException) {
        throw (IOException)t;
      }
 else {
        throw new IOException(t.getMessage(),t);
      }
    }
  }
}
