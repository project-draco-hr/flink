{
  GroupReduceFunction<IN,OUT> function=this.userFunction.getUserCodeObject();
  UnaryOperatorInformation<IN,OUT> operatorInfo=getOperatorInfo();
  TypeInformation<IN> inputType=operatorInfo.getInputType();
  if (!(inputType instanceof CompositeType)) {
    throw new InvalidProgramException("Input type of groupReduce operation must be a composite type.");
  }
  int[] inputColumns=getKeyColumns(0);
  boolean[] inputOrderings=new boolean[inputColumns.length];
  final TypeSerializer<IN> inputSerializer=inputType.createSerializer();
  @SuppressWarnings("unchecked") final TypeComparator<IN> inputComparator=((CompositeType<IN>)inputType).createComparator(inputColumns,inputOrderings);
  FunctionUtils.setFunctionRuntimeContext(function,ctx);
  FunctionUtils.openFunction(function,this.parameters);
  Collections.sort(inputData,new Comparator<IN>(){
    @Override public int compare(    IN o1,    IN o2){
      return inputComparator.compare(o2,o1);
    }
  }
);
  ListKeyGroupedIterator<IN> keyedIterator=new ListKeyGroupedIterator<IN>(inputData,inputSerializer,inputComparator,mutableObjectSafeMode);
  ArrayList<OUT> result=new ArrayList<OUT>();
  if (mutableObjectSafeMode) {
    TypeSerializer<OUT> outSerializer=getOperatorInfo().getOutputType().createSerializer();
    CopyingListCollector<OUT> collector=new CopyingListCollector<OUT>(result,outSerializer);
    while (keyedIterator.nextKey()) {
      function.reduce(keyedIterator.getValues(),collector);
    }
  }
 else {
    ListCollector<OUT> collector=new ListCollector<OUT>(result);
    while (keyedIterator.nextKey()) {
      function.reduce(keyedIterator.getValues(),collector);
    }
  }
  FunctionUtils.closeFunction(function);
  return result;
}
