{
  PactRecordOutputCollector innerOutput=new PactRecordOutputCollector(Arrays.asList(getIterationRecordWriters()));
  PactRecordOutputCollector taskOutput=new PactRecordOutputCollector(Arrays.asList(outputCollector.getWriter(0)));
  OutputGate<? extends Record>[] iterStateGates=getIterationOutputGates();
  LOG.info("Update memory: " + updateBufferSize + ", numSegments: "+ updateBufferSize);
  List<MemorySegment> updateMemory=getEnvironment().getMemoryManager().allocatePages(this,updateBufferSize);
  SerializedUpdateBuffer buffer=new SerializedUpdateBuffer(updateMemory,MEMORY_SEGMENT_SIZE,getEnvironment().getIOManager());
  BackTrafficQueueStore.getInstance().addStructures(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup());
  BackTrafficQueueStore.getInstance().publishUpdateBuffer(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup(),buffer);
  publishState(ChannelState.OPEN,iterStateGates);
  if (LOG.isInfoEnabled()) {
    LOG.info(constructLogString("Starting Iteration: -1",getEnvironment().getTaskName(),this));
  }
  MutableObjectIterator<PactRecord> input=getInput(0);
  processInput(input,innerOutput);
  publishState(ChannelState.CLOSED,iterStateGates);
  int iterationCounter=0;
  SerializedUpdateBuffer updatesBuffer;
  while (true) {
    try {
      updatesBuffer=(SerializedUpdateBuffer)BackTrafficQueueStore.getInstance().receiveIterationEnd(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup());
    }
 catch (    InterruptedException ex) {
      throw new RuntimeException("Internal Error",ex);
    }
    try {
      channelStateListener.waitForUpdate();
      terminationStateListener.waitForUpdate();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException("Internal Error",e);
    }
    if (channelStateListener.isUpdated() && terminationStateListener.isUpdated()) {
      if (terminationStateListener.getState() == ChannelState.TERMINATED) {
        break;
      }
 else {
        if (LOG.isInfoEnabled()) {
          LOG.info(constructLogString("Starting Iteration: " + iterationCounter,getEnvironment().getTaskName(),this));
        }
        input=new DeserializingIterator(updatesBuffer.switchBuffers());
        BackTrafficQueueStore.getInstance().publishUpdateBuffer(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup(),buffer);
        publishState(ChannelState.OPEN,iterStateGates);
        processUpdates(input,innerOutput);
        publishState(ChannelState.CLOSED,iterStateGates);
        updatesBuffer=null;
        iterationCounter++;
      }
    }
 else {
      throw new RuntimeException("isUpdated() returned false even thoug waitForUpate() exited");
    }
  }
  finish(new DeserializingIterator(updatesBuffer.switchBuffers()),taskOutput);
  if (updatesBuffer != null) {
  }
  getEnvironment().getMemoryManager().release(updateMemory);
  finished=true;
}
