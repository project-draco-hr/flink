{
  final List<TaskSubmissionResult> submissionResultList=new SerializableArrayList<TaskSubmissionResult>();
  final List<Task> tasksToStart=new ArrayList<Task>();
  for (  final TaskDeploymentDescriptor tdd : tasks) {
    final JobID jobID=tdd.getJobID();
    final ExecutionVertexID vertexID=tdd.getVertexID();
    RuntimeEnvironment re;
    Map<String,FutureTask<Path>> cpTasks=new HashMap<String,FutureTask<Path>>();
    for (    Entry<String,String> e : DistributedCache.getCachedFile(tdd.getJobConfiguration())) {
      FutureTask<Path> cp=this.fileCache.createTmpFile(e.getKey(),e.getValue(),jobID);
      cpTasks.put(e.getKey(),cp);
    }
    try {
      re=new RuntimeEnvironment(tdd,this.memoryManager,this.ioManager,new TaskInputSplitProvider(jobID,vertexID,this.globalInputSplitProvider),this.accumulatorProtocolProxy,cpTasks);
    }
 catch (    Throwable t) {
      final TaskSubmissionResult result=new TaskSubmissionResult(vertexID,AbstractTaskResult.ReturnCode.DEPLOYMENT_ERROR);
      result.setDescription(StringUtils.stringifyException(t));
      LOG.error(result.getDescription());
      submissionResultList.add(result);
      continue;
    }
    final Configuration jobConfiguration=tdd.getJobConfiguration();
    final Set<ChannelID> activeOutputChannels=null;
    Task task;
    try {
      task=createAndRegisterTask(vertexID,jobConfiguration,re,activeOutputChannels);
    }
 catch (    InsufficientResourcesException e) {
      final TaskSubmissionResult result=new TaskSubmissionResult(vertexID,AbstractTaskResult.ReturnCode.INSUFFICIENT_RESOURCES);
      result.setDescription(e.getMessage());
      LOG.error(result.getDescription());
      submissionResultList.add(result);
      continue;
    }
    if (task == null) {
      final TaskSubmissionResult result=new TaskSubmissionResult(vertexID,AbstractTaskResult.ReturnCode.TASK_NOT_FOUND);
      result.setDescription("Task " + re.getTaskNameWithIndex() + " ("+ vertexID+ ") was already running");
      LOG.error(result.getDescription());
      submissionResultList.add(result);
      continue;
    }
    submissionResultList.add(new TaskSubmissionResult(vertexID,AbstractTaskResult.ReturnCode.SUCCESS));
    tasksToStart.add(task);
  }
  for (  final Task task : tasksToStart) {
    task.startExecution();
  }
  return submissionResultList;
}
