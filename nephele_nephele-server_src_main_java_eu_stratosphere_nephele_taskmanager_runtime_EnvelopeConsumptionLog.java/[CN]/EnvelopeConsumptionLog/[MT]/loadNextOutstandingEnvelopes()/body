{
  System.out.println("++++++++++++ Entering loadNextOutstandingEnvelopes");
  final int pos=this.outstandingEnvelopesAsIntBuffer.position();
  if (pos > 0) {
    final int rem=this.outstandingEnvelopesAsIntBuffer.remaining();
    for (int i=0; i < rem; ++i) {
      this.outstandingEnvelopesAsIntBuffer.put(i,this.outstandingEnvelopesAsIntBuffer.get(i + pos));
    }
    this.outstandingEnvelopesAsIntBuffer.position(0);
    this.outstandingEnvelopesAsIntBuffer.limit(rem);
  }
  if (this.numberOfEntriesReadFromLog == this.numberOfInitialLogEntries) {
    return;
  }
  FileChannel fc=null;
  try {
    this.outstandingEnvelopesAsByteBuffer.position(this.outstandingEnvelopesAsIntBuffer.limit() * SIZE_OF_INTEGER);
    this.outstandingEnvelopesAsByteBuffer.limit(this.outstandingEnvelopesAsByteBuffer.capacity());
    fc=new FileInputStream(this.logFile).getChannel();
    fc.position(this.numberOfEntriesReadFromLog * SIZE_OF_INTEGER);
    int totalBytesRead=0;
    while (this.outstandingEnvelopesAsByteBuffer.hasRemaining()) {
      final int bytesRead=fc.read(this.outstandingEnvelopesAsByteBuffer);
      if (bytesRead == -1) {
        break;
      }
      totalBytesRead+=bytesRead;
    }
    System.out.println("Total bytes read: " + totalBytesRead);
    if (totalBytesRead % SIZE_OF_INTEGER != 0) {
      LOG.error("Read " + totalBytesRead + " from "+ this.logFile.getAbsolutePath()+ ", file may be corrupt");
    }
    final int numberOfNewEntries=totalBytesRead / SIZE_OF_INTEGER;
    this.outstandingEnvelopesAsIntBuffer.limit(this.outstandingEnvelopesAsIntBuffer.limit() + numberOfNewEntries);
    this.numberOfEntriesReadFromLog+=numberOfNewEntries;
    fc.close();
  }
 catch (  IOException ioe) {
    LOG.error(StringUtils.stringifyException(ioe));
  }
 finally {
    if (fc != null) {
      try {
        fc.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}
