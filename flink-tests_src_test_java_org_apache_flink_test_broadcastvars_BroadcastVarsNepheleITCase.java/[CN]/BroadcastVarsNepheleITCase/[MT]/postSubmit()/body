{
  final Random randPoints=new Random();
  final Random randModels=new Random();
  final Pattern p=Pattern.compile("(\\d+) (\\d+) (\\d+)");
  long[][] results=new long[NUM_POINTS][NUM_MODELS];
  boolean[][] occurs=new boolean[NUM_POINTS][NUM_MODELS];
  for (int i=0; i < NUM_POINTS; i++) {
    for (int j=0; j < NUM_MODELS; j++) {
      long actDotProd=0;
      randPoints.setSeed(SEED_POINTS + 1000 * (i + 1));
      randModels.setSeed(SEED_MODELS + 1000 * (j + 1));
      for (int z=1; z <= NUM_FEATURES; z++) {
        actDotProd+=randPoints.nextInt(1000) * randModels.nextInt(100);
      }
      results[i][j]=actDotProd;
      occurs[i][j]=false;
    }
  }
  for (  BufferedReader reader : getResultReader(this.resultPath)) {
    String line=null;
    while (null != (line=reader.readLine())) {
      final Matcher m=p.matcher(line);
      Assert.assertTrue(m.matches());
      int modelId=Integer.parseInt(m.group(1));
      int pointId=Integer.parseInt(m.group(2));
      long expDotProd=Long.parseLong(m.group(3));
      Assert.assertFalse("Dot product for record (" + pointId + ", "+ modelId+ ") occurs more than once",occurs[pointId - 1][modelId - 1]);
      Assert.assertEquals(String.format("Bad product for (%04d, %04d)",pointId,modelId),expDotProd,results[pointId - 1][modelId - 1]);
      occurs[pointId - 1][modelId - 1]=true;
    }
  }
  for (int i=0; i < NUM_POINTS; i++) {
    for (int j=0; j < NUM_MODELS; j++) {
      Assert.assertTrue("Dot product for record (" + (i + 1) + ", "+ (j + 1)+ ") does not occur",occurs[i][j]);
    }
  }
}
