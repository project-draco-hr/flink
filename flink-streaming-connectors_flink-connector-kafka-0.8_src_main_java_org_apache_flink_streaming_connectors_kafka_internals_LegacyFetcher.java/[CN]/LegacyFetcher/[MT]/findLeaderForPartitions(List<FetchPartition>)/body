{
  if (partitionsToAssign.size() == 0) {
    throw new IllegalArgumentException("Leader request for empty partitions list");
  }
  LOG.info("Refreshing leader information for partitions {}",partitionsToAssign);
  PartitionInfoFetcher infoFetcher=new PartitionInfoFetcher(getTopics(partitionsToAssign),config);
  infoFetcher.start();
  KillerWatchDog watchDog=new KillerWatchDog(infoFetcher,60000);
  watchDog.start();
  List<KafkaTopicPartitionLeader> topicPartitionWithLeaderList=infoFetcher.getPartitions();
  List<FetchPartition> unassignedPartitions=new ArrayList<>(partitionsToAssign);
  Map<Node,List<FetchPartition>> leaderToPartitions=new HashMap<>();
  for (  KafkaTopicPartitionLeader partitionLeader : topicPartitionWithLeaderList) {
    if (unassignedPartitions.size() == 0) {
      break;
    }
    Iterator<FetchPartition> unassignedPartitionsIterator=unassignedPartitions.iterator();
    while (unassignedPartitionsIterator.hasNext()) {
      FetchPartition unassignedPartition=unassignedPartitionsIterator.next();
      if (unassignedPartition.topic.equals(partitionLeader.getTopicPartition().getTopic()) && unassignedPartition.partition == partitionLeader.getTopicPartition().getPartition()) {
        Node leader=partitionLeader.getLeader();
        List<FetchPartition> partitionsOfLeader=leaderToPartitions.get(leader);
        if (partitionsOfLeader == null) {
          partitionsOfLeader=new ArrayList<>();
          leaderToPartitions.put(leader,partitionsOfLeader);
        }
        partitionsOfLeader.add(unassignedPartition);
        unassignedPartitionsIterator.remove();
        break;
      }
    }
  }
  if (unassignedPartitions.size() > 0) {
    throw new RuntimeException("Unable to find a leader for partitions: " + unassignedPartitions);
  }
  LOG.debug("Partitions with assigned leaders {}",leaderToPartitions);
  return leaderToPartitions;
}
