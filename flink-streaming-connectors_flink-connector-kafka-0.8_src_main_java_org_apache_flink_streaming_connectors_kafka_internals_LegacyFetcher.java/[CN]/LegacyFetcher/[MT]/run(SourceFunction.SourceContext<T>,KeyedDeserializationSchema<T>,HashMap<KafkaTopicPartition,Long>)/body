{
  this.mainThread=Thread.currentThread();
  final Map<Node,SimpleConsumerThread<T>> brokerToThread=new HashMap<>();
  try {
    while (running && error.get() == null) {
      try {
        List<FetchPartition> partitionsToAssign=unassignedPartitions.getBatchBlocking(5000);
        partitionsToAssign.remove(MARKER);
        if (!partitionsToAssign.isEmpty()) {
          LOG.info("Assigning {} partitions to broker threads",partitionsToAssign.size());
          Map<Node,List<FetchPartition>> partitionsWithLeaders=findLeaderForPartitions(partitionsToAssign);
          for (          Map.Entry<Node,List<FetchPartition>> partitionsWithLeader : partitionsWithLeaders.entrySet()) {
            final Node leader=partitionsWithLeader.getKey();
            final List<FetchPartition> partitions=partitionsWithLeader.getValue();
            SimpleConsumerThread<T> brokerThread=brokerToThread.get(leader);
            if (!running) {
              break;
            }
            if (brokerThread == null || !brokerThread.getNewPartitionsQueue().isOpen()) {
              brokerThread=createAndStartSimpleConsumerThread(sourceContext,deserializer,lastOffsets,partitions,leader);
              brokerToThread.put(leader,brokerThread);
            }
 else {
              ClosableBlockingQueue<FetchPartition> newPartitionsQueue=brokerThread.getNewPartitionsQueue();
              for (              FetchPartition fp : partitions) {
                if (!newPartitionsQueue.addIfOpen(fp)) {
                  List<FetchPartition> seedPartitions=new ArrayList<>();
                  seedPartitions.add(fp);
                  brokerThread=createAndStartSimpleConsumerThread(sourceContext,deserializer,lastOffsets,seedPartitions,leader);
                  brokerToThread.put(leader,brokerThread);
                  newPartitionsQueue=brokerThread.getNewPartitionsQueue();
                }
              }
            }
          }
        }
 else {
          Iterator<SimpleConsumerThread<T>> bttIterator=brokerToThread.values().iterator();
          while (bttIterator.hasNext()) {
            SimpleConsumerThread<T> thread=bttIterator.next();
            if (!thread.getNewPartitionsQueue().isOpen()) {
              LOG.info("Removing stopped consumer thread {}",thread.getName());
              bttIterator.remove();
            }
          }
        }
        if (brokerToThread.size() == 0 && unassignedPartitions.isEmpty()) {
          if (unassignedPartitions.close()) {
            LOG.info("All consumer threads are finished, there are no more unassigned partitions. Stopping fetcher");
            break;
          }
        }
      }
 catch (      InterruptedException e) {
      }
    }
    Throwable error=this.error.get();
    if (error != null) {
      throw new Exception(error.getMessage(),error);
    }
  }
  finally {
    int runningThreads;
    do {
      runningThreads=0;
      for (      SimpleConsumerThread<?> t : brokerToThread.values()) {
        if (t.isAlive()) {
          t.cancel();
          runningThreads++;
        }
      }
      if (runningThreads > 0) {
        Thread.sleep(500);
      }
    }
 while (runningThreads > 0);
  }
}
