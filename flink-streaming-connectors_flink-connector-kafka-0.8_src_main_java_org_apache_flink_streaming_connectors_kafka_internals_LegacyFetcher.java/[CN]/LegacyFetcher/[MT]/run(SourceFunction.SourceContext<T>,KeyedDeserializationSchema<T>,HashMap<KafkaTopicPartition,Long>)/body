{
  this.mainThread=Thread.currentThread();
  List<SimpleConsumerThread<T>> deadBrokerThreads=new ArrayList<>();
  Map<Node,SimpleConsumerThread<T>> brokerToThread=new HashMap<>();
  try {
    while (running && error.get() == null) {
      try {
        List<FetchPartition> partitionsToAssign=unassignedPartitions.getBatchBlocking(5000);
        if (!partitionsToAssign.isEmpty()) {
          LOG.info("Assigning {} partitions to broker threads",partitionsToAssign.size());
          Map<Node,List<FetchPartition>> partitionsWithLeaders=findLeaderForPartitions(partitionsToAssign);
          for (          Map.Entry<Node,List<FetchPartition>> partitionsWithLeader : partitionsWithLeaders.entrySet()) {
            final Node leader=partitionsWithLeader.getKey();
            final List<FetchPartition> partitions=partitionsWithLeader.getValue();
            SimpleConsumerThread<T> brokerThread=brokerToThread.get(leader);
            if (brokerThread == null) {
              brokerThread=createAndStartSimpleConsumerThread(sourceContext,deserializer,lastOffsets,partitions,leader);
              brokerToThread.put(leader,brokerThread);
            }
 else {
              if (brokerThread.isAlive()) {
                ClosableBlockingQueue<FetchPartition> newPartitionsQueue=brokerThread.getNewPartitionsQueue();
                for (                FetchPartition fp : partitions) {
                  if (!newPartitionsQueue.addIfOpen(fp)) {
                    List<FetchPartition> seedPartitions=new ArrayList<>();
                    seedPartitions.add(fp);
                    brokerThread=createAndStartSimpleConsumerThread(sourceContext,deserializer,lastOffsets,seedPartitions,leader);
                    SimpleConsumerThread<T> oldThread=brokerToThread.put(leader,brokerThread);
                    if (oldThread != null) {
                      deadBrokerThreads.add(oldThread);
                    }
                    newPartitionsQueue=brokerThread.getNewPartitionsQueue();
                  }
                }
              }
 else {
                brokerThread=createAndStartSimpleConsumerThread(sourceContext,deserializer,lastOffsets,partitions,leader);
                SimpleConsumerThread<T> oldThread=brokerToThread.put(leader,brokerThread);
                if (oldThread != null) {
                  deadBrokerThreads.add(oldThread);
                }
              }
            }
          }
        }
 else {
          Iterator<Map.Entry<Node,SimpleConsumerThread<T>>> bttIterator=brokerToThread.entrySet().iterator();
          while (bttIterator.hasNext()) {
            Map.Entry<Node,SimpleConsumerThread<T>> brokerAndThread=bttIterator.next();
            if (!brokerAndThread.getValue().isAlive()) {
              LOG.info("Removing stopped consumer thread {}",brokerAndThread.getValue().getName());
              bttIterator.remove();
            }
          }
        }
        if (deadBrokerThreads.size() > 0) {
          Iterator<SimpleConsumerThread<T>> deadBrokerThreadsIterator=deadBrokerThreads.iterator();
          while (deadBrokerThreadsIterator.hasNext()) {
            if (!deadBrokerThreadsIterator.next().isAlive()) {
              deadBrokerThreadsIterator.remove();
            }
          }
        }
        if (brokerToThread.size() == 0 && unassignedPartitions.peek() == null) {
          if (unassignedPartitions.close()) {
            LOG.info("All consumer threads are finished, there are no more unassigned partitions. Stopping fetcher");
            break;
          }
        }
      }
 catch (      InterruptedException e) {
      }
    }
    Throwable error=this.error.get();
    if (error != null) {
      throw new Exception(error.getMessage(),error);
    }
  }
  finally {
    int runningThreads;
    do {
      runningThreads=0;
      for (      SimpleConsumerThread<?> t : brokerToThread.values()) {
        if (t.isAlive()) {
          t.cancel();
          runningThreads++;
        }
      }
      if (deadBrokerThreads.size() > 0) {
        for (        SimpleConsumerThread<T> thread : deadBrokerThreads) {
          if (thread.isAlive()) {
            thread.cancel();
            runningThreads++;
          }
        }
      }
      if (runningThreads > 0) {
        Thread.sleep(500);
      }
    }
 while (runningThreads > 0);
  }
}
