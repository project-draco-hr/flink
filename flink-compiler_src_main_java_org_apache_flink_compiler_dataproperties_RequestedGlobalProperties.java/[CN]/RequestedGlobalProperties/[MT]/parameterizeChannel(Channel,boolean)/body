{
  if (isTrivial()) {
    channel.setShipStrategy(globalDopChange ? ShipStrategyType.PARTITION_RANDOM : ShipStrategyType.FORWARD);
    return;
  }
  final GlobalProperties inGlobals=channel.getSource().getGlobalProperties();
  if (!globalDopChange && isMetBy(inGlobals)) {
    channel.setShipStrategy(ShipStrategyType.FORWARD);
    return;
  }
switch (this.partitioning) {
case FULL_REPLICATION:
    channel.setShipStrategy(ShipStrategyType.BROADCAST);
  break;
case ANY_PARTITIONING:
case HASH_PARTITIONED:
channel.setShipStrategy(ShipStrategyType.PARTITION_HASH,Utils.createOrderedFromSet(this.partitioningFields));
break;
case RANGE_PARTITIONED:
channel.setShipStrategy(ShipStrategyType.PARTITION_RANGE,this.ordering.getInvolvedIndexes(),this.ordering.getFieldSortDirections());
if (this.dataDistribution != null) {
channel.setDataDistribution(this.dataDistribution);
}
break;
case FORCED_REBALANCED:
channel.setShipStrategy(ShipStrategyType.PARTITION_FORCED_REBALANCE);
break;
case CUSTOM_PARTITIONING:
channel.setShipStrategy(ShipStrategyType.PARTITION_CUSTOM,Utils.createOrderedFromSet(this.partitioningFields),this.customPartitioner);
break;
default :
throw new CompilerException("Invalid partitioning to create through a data exchange: " + this.partitioning.name());
}
}
