{
  final int allPredsSize=allPreds.size();
  PactConnection connToProcess=this.input.get(allPredsSize);
  List<? extends OptimizerNode> inPlans=connToProcess.getSourcePact().getAlternativePlans(estimator);
  for (  OptimizerNode pred : inPlans) {
    allPreds.add(pred);
    Order go=getPactContract().getGlobalOrder();
    Order lo=getPactContract().getLocalOrder();
    GlobalProperties gp=pred.getGlobalProperties().createCopy();
    LocalProperties lp=pred.getLocalProperties().createCopy();
    ShipStrategy ss=null;
    LocalStrategy ls=null;
    if (go != Order.NONE && go != gp.getKeyOrder()) {
      if (connToProcess.getShipStrategy() == ShipStrategy.NONE || connToProcess.getShipStrategy() == ShipStrategy.PARTITION_RANGE) {
        ss=ShipStrategy.PARTITION_RANGE;
      }
 else {
        continue;
      }
      if (this.localStrategy == LocalStrategy.NONE || this.localStrategy == LocalStrategy.SORT) {
        ls=LocalStrategy.SORT;
      }
 else {
        continue;
      }
      gp.setPartitioning(PartitionProperty.RANGE_PARTITIONED);
      gp.setKeyOrder(go);
      lp.setKeyOrder(go);
    }
 else     if (lo != Order.NONE && lo != lp.getKeyOrder()) {
      if (this.localStrategy == LocalStrategy.NONE || this.localStrategy == LocalStrategy.SORT) {
        ls=LocalStrategy.SORT;
      }
 else {
        continue;
      }
      ls=LocalStrategy.SORT;
      lp.setKeyOrder(lo);
    }
    if (allPredsSize + 1 == this.input.size()) {
      DataSinkNode ns=new DataSinkNode(this,allPreds,this.input,gp,lp);
      if (ss == null) {
        ss=ShipStrategy.FORWARD;
      }
      for (      PactConnection cc : ns.getInputConnections()) {
        cc.setShipStrategy(ss);
      }
      if (ls == null) {
        ls=LocalStrategy.NONE;
      }
      ns.setLocalStrategy(ls);
      estimator.costOperator(ns);
      outputPlans.add(ns);
    }
 else {
      getAlternativePlansRecursively(allPreds,estimator,outputPlans);
    }
    allPreds.remove(allPredsSize);
  }
}
