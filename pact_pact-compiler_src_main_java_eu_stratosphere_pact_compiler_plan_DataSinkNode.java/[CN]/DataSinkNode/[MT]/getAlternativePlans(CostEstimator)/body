{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  List<? extends PlanNode> subPlans=getPredecessorNode().getAlternativePlans(estimator);
  List<PlanNode> outputPlans=new ArrayList<PlanNode>();
  final int dop=getDegreeOfParallelism();
  final int subPerInstance=getSubtasksPerInstance();
  final int inDop=getPredecessorNode().getDegreeOfParallelism();
  final int inSubPerInstance=getPredecessorNode().getSubtasksPerInstance();
  final int numInstances=dop / subPerInstance + (dop % subPerInstance == 0 ? 0 : 1);
  final int inNumInstances=inDop / inSubPerInstance + (inDop % inSubPerInstance == 0 ? 0 : 1);
  final boolean globalDopChange=numInstances != inNumInstances;
  final boolean localDopChange=numInstances == inNumInstances & subPerInstance != inSubPerInstance;
  InterestingProperties ips=this.input.getInterestingProperties();
  for (  PlanNode p : subPlans) {
    for (    RequestedGlobalProperties gp : ips.getGlobalProperties()) {
      for (      RequestedLocalProperties lp : ips.getLocalProperties()) {
        Channel c=new Channel(p);
        gp.parameterizeChannel(c,globalDopChange,localDopChange);
        if (lp.isMetBy(c.getLocalPropertiesAfterShippingOnly())) {
          c.setLocalStrategy(LocalStrategy.NONE);
        }
 else {
          lp.parameterizeChannel(c);
        }
        outputPlans.add(new SinkPlanNode(this,c));
      }
    }
  }
  for (  PlanNode node : outputPlans) {
    estimator.costOperator(node);
  }
  prunePlanAlternatives(outputPlans);
  if (isBranching()) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
