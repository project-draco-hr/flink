{
  List<? extends OptimizerNode> inPlans=input.getSourcePact().getAlternativePlans(estimator);
  List<DataSinkNode> plans=new ArrayList<DataSinkNode>(inPlans.size());
  for (  OptimizerNode pred : inPlans) {
    Ordering go=getPactContract().getGlobalOrder();
    Ordering lo=getPactContract().getLocalOrder();
    GlobalProperties gp=pred.getGlobalProperties().createCopy();
    LocalProperties lp=pred.getLocalProperties().createCopy();
    ShipStrategy ss=null;
    LocalStrategy ls=null;
    if (go != null && go != null) {
      if (input.getShipStrategy() == ShipStrategy.NONE || input.getShipStrategy() == ShipStrategy.PARTITION_RANGE) {
        ss=ShipStrategy.PARTITION_RANGE;
      }
 else {
        continue;
      }
      if (localStrategy == LocalStrategy.NONE || localStrategy == LocalStrategy.SORT) {
        ls=LocalStrategy.SORT;
      }
 else {
        continue;
      }
      FieldSet fieldSet=new FieldSet();
      for (      Integer field : go.getInvolvedIndexes()) {
        fieldSet.add(field);
      }
      gp.setPartitioning(PartitionProperty.RANGE_PARTITIONED,fieldSet);
      gp.setOrdering(go);
      lp.setOrdering(go);
    }
 else     if (lo != null && lo.isMetBy(lp.getOrdering())) {
      if (localStrategy == LocalStrategy.NONE || localStrategy == LocalStrategy.SORT) {
        ls=LocalStrategy.SORT;
      }
 else {
        continue;
      }
      ls=LocalStrategy.SORT;
      lp.setOrdering(lo);
    }
    DataSinkNode ns=new DataSinkNode(this,pred,input,gp,lp);
    if (ss == null) {
      ss=ShipStrategy.FORWARD;
    }
    ns.input.setShipStrategy(ss);
    if (ls == null) {
      ls=LocalStrategy.NONE;
    }
    ns.setLocalStrategy(ls);
    estimator.costOperator(ns);
    plans.add(ns);
  }
  prunePlanAlternatives(plans);
  if (plans.isEmpty()) {
    throw new CompilerException("Could not create a valid plan for the DataSource contract '" + getPactContract().getName() + "'. The compiler hints specified incompatible shipping strategies.");
  }
  return plans;
}
