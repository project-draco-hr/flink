{
  List<OptimizerNode> outputPlans=new ArrayList<OptimizerNode>();
  final int inputSize=this.input.size();
  @SuppressWarnings("unchecked") List<? extends OptimizerNode>[] inPlans=new List[inputSize];
  for (int i=0; i < inputSize; ++i) {
    inPlans[i]=this.input.get(i).getSourcePact().getAlternativePlans(estimator);
  }
  List<List<OptimizerNode>> alternativeSubPlanCominations=new ArrayList<List<OptimizerNode>>();
  getAlternativeSubPlanCombinationsRecursively(inPlans,new ArrayList<OptimizerNode>(0),alternativeSubPlanCominations);
  for (  List<OptimizerNode> predList : alternativeSubPlanCominations) {
    if (!areBranchCompatible(predList,null)) {
      continue;
    }
    Order go=getPactContract().getGlobalOrder();
    Order lo=getPactContract().getLocalOrder();
    GlobalProperties gp;
    LocalProperties lp;
    if (predList.size() == 1) {
      gp=predList.get(0).getGlobalProperties().createCopy();
      lp=predList.get(0).getLocalProperties().createCopy();
    }
 else {
      gp=new GlobalProperties();
      lp=new LocalProperties();
    }
    ShipStrategy ss=null;
    LocalStrategy ls=null;
    if (go != Order.NONE && go != gp.getKeyOrder()) {
      for (      PactConnection c : this.input) {
        ShipStrategy s=c.getShipStrategy();
        if (s == ShipStrategy.NONE || s == ShipStrategy.PARTITION_RANGE) {
          ss=ShipStrategy.PARTITION_RANGE;
        }
 else {
          continue;
        }
      }
      if (this.localStrategy == LocalStrategy.NONE || this.localStrategy == LocalStrategy.SORT) {
        ls=LocalStrategy.SORT;
      }
 else {
        continue;
      }
      gp.setPartitioning(PartitionProperty.RANGE_PARTITIONED);
      gp.setKeyOrder(go);
      lp.setKeyOrder(go);
    }
 else     if (lo != Order.NONE && lo != lp.getKeyOrder()) {
      if (this.localStrategy == LocalStrategy.NONE || this.localStrategy == LocalStrategy.SORT) {
        ls=LocalStrategy.SORT;
      }
 else {
        continue;
      }
      ls=LocalStrategy.SORT;
      lp.setKeyOrder(lo);
    }
    if (ss == null) {
      ss=ShipStrategy.FORWARD;
    }
    DataSinkNode ns=new DataSinkNode(this,predList,this.input,gp,lp);
    for (    PactConnection cc : ns.getInputConnections()) {
      cc.setShipStrategy(ss);
    }
    if (ls == null) {
      ls=LocalStrategy.NONE;
    }
    ns.setLocalStrategy(ls);
    estimator.costOperator(ns);
    outputPlans.add(ns);
  }
  prunePlanAlternatives(outputPlans);
  if (outputPlans.isEmpty()) {
    throw new CompilerException("Could not create a valid plan for the DataSource contract '" + getPactContract().getName() + "'. The compiler hints specified incompatible shipping strategies.");
  }
  return outputPlans;
}
