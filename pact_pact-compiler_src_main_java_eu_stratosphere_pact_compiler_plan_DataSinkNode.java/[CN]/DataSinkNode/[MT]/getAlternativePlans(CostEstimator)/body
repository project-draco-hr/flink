{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  List<? extends PlanNode> subPlans=getPredecessorNode().getAlternativePlans(estimator);
  List<PlanNode> outputPlans=new ArrayList<PlanNode>();
  InterestingProperties ips=this.input.getInterestingProperties();
  for (  PlanNode p : subPlans) {
    for (    RequestedGlobalProperties gp : ips.getGlobalProperties()) {
      for (      RequestedLocalProperties lp : ips.getLocalProperties()) {
        Channel c=new Channel(p);
        if (gp.isMetBy(p.getGlobalProperties())) {
          c.setShipStrategy(ShipStrategyType.FORWARD);
        }
 else {
          gp.parameterizeChannel(c);
        }
        if (lp.isMetBy(c.getLocalPropertiesAfterShippingOnly())) {
          c.setLocalStrategy(LocalStrategy.NONE);
        }
 else {
          lp.parameterizeChannel(c);
        }
        outputPlans.add(new SinkPlanNode(this,c));
      }
    }
  }
  for (  PlanNode node : outputPlans) {
    estimator.costOperator(node);
  }
  prunePlanAlternatives(outputPlans);
  if (isBranching()) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
