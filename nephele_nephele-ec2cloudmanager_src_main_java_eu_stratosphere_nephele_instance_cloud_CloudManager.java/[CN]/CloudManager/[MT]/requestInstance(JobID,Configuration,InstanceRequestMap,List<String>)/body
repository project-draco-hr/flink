{
  if (conf == null) {
    throw new InstanceException("No job configuration provided, unable to acquire credentials");
  }
  final String awsAccessId=conf.getString("job.cloud.awsaccessid",null);
  LOG.info("found AWS access ID from Job Conf: " + awsAccessId);
  if (awsAccessId == null) {
    throw new InstanceException("Unable to allocate cloud instance: Cannot find AWS access ID");
  }
  final String awsSecretKey=conf.getString("job.cloud.awssecretkey",null);
  if (awsSecretKey == null) {
    throw new InstanceException("Unable to allocate cloud instance: Cannot find AWS secret key");
  }
  checkAndConvertOrphanedInstances(conf);
  JobToInstancesMapping jobToInstanceMapping=null;
synchronized (this.jobToInstancesAssignmentMap) {
    jobToInstanceMapping=this.jobToInstancesAssignmentMap.get(jobID);
    if (jobToInstanceMapping == null) {
      LOG.debug("Creating new mapping for job " + jobID);
      jobToInstanceMapping=new JobToInstancesMapping(awsAccessId,awsSecretKey);
      this.jobToInstancesAssignmentMap.put(jobID,jobToInstanceMapping);
    }
  }
  final LinkedList<FloatingInstance> floatinginstances=new LinkedList<FloatingInstance>();
  final LinkedList<String> requestedinstances=new LinkedList<String>();
  final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMaximumIterator();
  while (it.hasNext()) {
    Map.Entry<InstanceType,Integer> e=it.next();
    final InstanceType actualtype=e.getKey();
    final int maxcount=e.getValue();
    final int mincount=instanceRequestMap.getMinimumNumberOfInstances(actualtype);
    LinkedList<FloatingInstance> actualfloatinginstances=new LinkedList<FloatingInstance>();
    LinkedList<String> actualrequestedinstances=new LinkedList<String>();
    actualfloatinginstances=anyFloatingInstancesAvailable(awsAccessId,awsSecretKey,actualtype,maxcount);
    if (actualfloatinginstances.size() < maxcount) {
      int minimumrequestcount=Math.max(mincount - actualfloatinginstances.size(),1);
      int maximumrequestcount=maxcount - actualfloatinginstances.size();
      actualrequestedinstances=allocateCloudInstance(conf,actualtype,minimumrequestcount,maximumrequestcount);
    }
    floatinginstances.addAll(actualfloatinginstances);
    requestedinstances.addAll(actualrequestedinstances);
    if (actualrequestedinstances.size() + actualfloatinginstances.size() < mincount) {
      LOG.error("Requested: " + mincount + " to "+ maxcount+ " instanes of type "+ actualtype.getIdentifier()+ ". Could only provide "+ (actualrequestedinstances.size() + actualfloatinginstances.size())+ ".");
synchronized (this.floatingInstances) {
        for (        FloatingInstance i : floatinginstances) {
          this.floatingInstances.put(i.getInstanceConnectionInfo(),i);
        }
      }
      throw new InstanceException("Cloud not allocate enough cloud instances");
    }
  }
  final List<AllocatedResource> allocatedResources=new ArrayList<AllocatedResource>();
  for (  FloatingInstance fi : floatinginstances) {
    CloudInstance ci=fi.asCloudInstance();
    jobToInstanceMapping.assignInstanceToJob(ci);
    allocatedResources.add(ci.asAllocatedResource());
  }
  final CloudInstanceNotifier notifier=new CloudInstanceNotifier(this.instanceListener,jobID,allocatedResources);
  notifier.start();
  for (  String i : requestedinstances) {
    this.reservedInstancesToJobMapping.put(i,jobID);
  }
}
