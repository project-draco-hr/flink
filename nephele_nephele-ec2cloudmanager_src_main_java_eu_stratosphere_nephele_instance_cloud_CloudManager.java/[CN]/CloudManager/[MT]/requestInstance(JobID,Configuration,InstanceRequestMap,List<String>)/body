{
  if (conf == null) {
    throw new IllegalArgumentException("No job configuration provided, unable to acquire credentials");
  }
  final String awsAccessId=conf.getString("job.cloud.awsaccessid",null);
  LOG.info("found AWS access ID from Job Conf: " + awsAccessId);
  if (awsAccessId == null) {
    throw new InstanceException("Unable to allocate cloud instance: Cannot find AWS access ID");
  }
  final String awsSecretKey=conf.getString("job.cloud.awssecretkey",null);
  if (awsSecretKey == null) {
    throw new InstanceException("Unable to allocate cloud instance: Cannot find AWS secret key");
  }
  checkAndConvertOrphanedInstances(conf);
  JobToInstancesMapping jobToInstanceMapping=null;
synchronized (this.jobToInstancesAssignmentMap) {
    jobToInstanceMapping=this.jobToInstancesAssignmentMap.get(jobID);
    if (jobToInstanceMapping == null) {
      LOG.debug("Creating new mapping for job " + jobID);
      jobToInstanceMapping=new JobToInstancesMapping(awsAccessId,awsSecretKey);
      this.jobToInstancesAssignmentMap.put(jobID,jobToInstanceMapping);
    }
  }
  final LinkedList<FloatingInstance> floatingInstances=new LinkedList<FloatingInstance>();
  final LinkedList<String> requestedInstances=new LinkedList<String>();
  final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMaximumIterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> e=it.next();
    final InstanceType actualtype=e.getKey();
    final int maxcount=e.getValue();
    final int mincount=instanceRequestMap.getMinimumNumberOfInstances(actualtype);
    LinkedList<FloatingInstance> actualFloatingInstances=new LinkedList<FloatingInstance>();
    LinkedList<String> actualRequestedInstances=new LinkedList<String>();
    actualFloatingInstances=anyFloatingInstancesAvailable(awsAccessId,awsSecretKey,actualtype,maxcount);
    if (actualFloatingInstances.size() < maxcount) {
      int minimumrequestcount=Math.max(mincount - actualFloatingInstances.size(),1);
      int maximumrequestcount=maxcount - actualFloatingInstances.size();
      actualRequestedInstances=allocateCloudInstance(conf,actualtype,minimumrequestcount,maximumrequestcount);
    }
    floatingInstances.addAll(actualFloatingInstances);
    requestedInstances.addAll(actualRequestedInstances);
    if (actualRequestedInstances.size() + actualFloatingInstances.size() < mincount) {
      LOG.error("Requested: " + mincount + " to "+ maxcount+ " instanes of type "+ actualtype.getIdentifier()+ ". Could only provide "+ (actualRequestedInstances.size() + actualFloatingInstances.size())+ ".");
synchronized (this.floatingInstances) {
        for (        FloatingInstance i : floatingInstances) {
          this.floatingInstances.put(i.getInstanceConnectionInfo(),i);
        }
      }
      throw new InstanceException("Could not allocate enough cloud instances");
    }
  }
  final List<AllocatedResource> allocatedResources=new ArrayList<AllocatedResource>();
  for (  final FloatingInstance fi : floatingInstances) {
    final CloudInstance ci=fi.asCloudInstance();
    jobToInstanceMapping.assignInstanceToJob(ci);
    allocatedResources.add(ci.asAllocatedResource());
  }
  final CloudInstanceNotifier notifier=new CloudInstanceNotifier(this.instanceListener,jobID,allocatedResources);
  notifier.start();
  for (  final String i : requestedInstances) {
    this.reservedInstancesToJobMapping.put(i,jobID);
  }
}
