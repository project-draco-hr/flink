{
  if (!parseParameters(args)) {
    return;
  }
  final StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  DataStream<StockPrice> socketStockStream=env.socketTextStream(hostName,port).map(new MapFunction<String,StockPrice>(){
    private String[] tokens;
    @Override public StockPrice map(    String value) throws Exception {
      tokens=value.split(",");
      return new StockPrice(tokens[0],Double.parseDouble(tokens[1]));
    }
  }
);
  DataStream<StockPrice> SPX_stream=env.addSource(new StockSource("SPX",10));
  DataStream<StockPrice> FTSE_stream=env.addSource(new StockSource("FTSE",20));
  DataStream<StockPrice> DJI_stream=env.addSource(new StockSource("DJI",30));
  DataStream<StockPrice> BUX_stream=env.addSource(new StockSource("BUX",40));
  @SuppressWarnings("unchecked") DataStream<StockPrice> stockStream=socketStockStream.merge(SPX_stream,FTSE_stream,DJI_stream,BUX_stream);
  WindowedDataStream<StockPrice> windowedStream=stockStream.window(Time.of(10,TimeUnit.SECONDS)).every(Time.of(5,TimeUnit.SECONDS));
  DataStream<StockPrice> lowest=windowedStream.minBy("price").flatten();
  DataStream<StockPrice> maxByStock=windowedStream.groupBy("symbol").maxBy("price").flatten();
  DataStream<StockPrice> rollingMean=windowedStream.groupBy("symbol").mapWindow(new MeanReduce()).flatten();
  DataStream<String> priceWarnings=stockStream.groupBy("symbol").window(Delta.of(0.05,new DeltaFunction<StockPrice>(){
    @Override public double getDelta(    StockPrice oldDataPoint,    StockPrice newDataPoint){
      return Math.abs(oldDataPoint.price - newDataPoint.price);
    }
  }
,DEFAULT_STOCK_PRICE)).mapWindow(new SendWarning()).flatten();
  DataStream<Count> warningsPerStock=priceWarnings.map(new MapFunction<String,Count>(){
    @Override public Count map(    String value) throws Exception {
      return new Count(value,1);
    }
  }
).groupBy("symbol").window(Time.of(30,TimeUnit.SECONDS)).sum("count").flatten();
  DataStream<String> tweetStream=env.addSource(new TweetSource());
  DataStream<String> mentionedSymbols=tweetStream.flatMap(new FlatMapFunction<String,String>(){
    @Override public void flatMap(    String value,    Collector<String> out) throws Exception {
      String[] words=value.split(" ");
      for (      String word : words) {
        out.collect(word.toUpperCase());
      }
    }
  }
).filter(new FilterFunction<String>(){
    @Override public boolean filter(    String value) throws Exception {
      return SYMBOLS.contains(value);
    }
  }
);
  DataStream<Count> tweetsPerStock=mentionedSymbols.map(new MapFunction<String,Count>(){
    @Override public Count map(    String value) throws Exception {
      return new Count(value,1);
    }
  }
).groupBy("symbol").window(Time.of(30,TimeUnit.SECONDS)).sum("count").flatten();
  DataStream<Tuple2<Integer,Integer>> tweetsAndWarning=warningsPerStock.join(tweetsPerStock).onWindow(30,TimeUnit.SECONDS).where("symbol").equalTo("symbol").with(new JoinFunction<Count,Count,Tuple2<Integer,Integer>>(){
    @Override public Tuple2<Integer,Integer> join(    Count first,    Count second) throws Exception {
      return new Tuple2<Integer,Integer>(first.count,second.count);
    }
  }
);
  DataStream<Double> rollingCorrelation=tweetsAndWarning.window(Time.of(30,TimeUnit.SECONDS)).mapWindow(new CorrelationReduce()).flatten();
  if (fileOutput) {
    rollingCorrelation.writeAsText(outputPath,1);
  }
 else {
    rollingCorrelation.print();
  }
  env.execute("Stock stream");
}
