{
  OutputSelectorWrapper<?> outputSelectorWrapper=chainedTaskConfig.getOutputSelectorWrapper(cl);
  CollectorWrapper wrapper=new CollectorWrapper(outputSelectorWrapper);
  for (  StreamEdge outputEdge : chainedTaskConfig.getNonChainedOutputs(cl)) {
    Output<?> output=outputMap.get(outputEdge);
    wrapper.addCollector(output,outputEdge);
  }
  for (  StreamEdge outputEdge : chainedTaskConfig.getChainedOutputs(cl)) {
    Integer outputId=outputEdge.getTargetId();
    Output<?> output=createChainedCollector(chainedConfigs.get(outputId),accumulatorMap);
    wrapper.addCollector(output,outputEdge);
  }
  if (chainedTaskConfig.isChainStart()) {
    return (Output<StreamRecord<X>>)wrapper;
  }
 else {
    OneInputStreamOperator chainableOperator=chainedTaskConfig.getStreamOperator(vertex.getUserCodeClassLoader());
    StreamingRuntimeContext chainedContext=vertex.createRuntimeContext(chainedTaskConfig,accumulatorMap);
    vertex.contexts.add(chainedContext);
    chainableOperator.setup(wrapper,chainedContext);
    chainedOperators.add(chainableOperator);
    if (vertex.getExecutionConfig().isObjectReuseEnabled() || chainableOperator.isInputCopyingDisabled()) {
      return new ChainingOutput<X>(chainableOperator);
    }
 else {
      StreamRecordSerializer serializerIn1;
      if (vertex.getExecutionConfig().areTimestampsEnabled()) {
        serializerIn1=new MultiplexingStreamRecordSerializer(chainedTaskConfig.getTypeSerializerIn1(vertex.getUserCodeClassLoader()));
      }
 else {
        serializerIn1=new StreamRecordSerializer(chainedTaskConfig.getTypeSerializerIn1(vertex.getUserCodeClassLoader()));
      }
      return new CopyingChainingOutput<X>(chainableOperator,(TypeSerializer<StreamRecord<X>>)serializerIn1);
    }
  }
}
