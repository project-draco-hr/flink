{
  OutputSelectorWrapper<?> outputSelectorWrapper=chainedTaskConfig.getOutputSelectorWrapper(userCodeClassloader);
  CollectorWrapper wrapper=new CollectorWrapper(outputSelectorWrapper);
  for (  StreamEdge outputEdge : chainedTaskConfig.getNonChainedOutputs(userCodeClassloader)) {
    Output<?> output=outputMap.get(outputEdge);
    wrapper.addCollector(output,outputEdge);
  }
  for (  StreamEdge outputEdge : chainedTaskConfig.getChainedOutputs(userCodeClassloader)) {
    Integer outputId=outputEdge.getTargetId();
    Output<?> output=createChainedCollector(chainedConfigs.get(outputId),accumulatorMap);
    wrapper.addCollector(output,outputEdge);
  }
  if (chainedTaskConfig.isChainStart()) {
    return (Output<StreamRecord<X>>)wrapper;
  }
 else {
    OneInputStreamOperator chainableOperator=chainedTaskConfig.getStreamOperator(userCodeClassloader);
    StreamingRuntimeContext chainedContext=vertex.createRuntimeContext(chainedTaskConfig,accumulatorMap);
    vertex.contexts.add(chainedContext);
    chainableOperator.setup(wrapper,chainedContext);
    chainedOperators.add(chainableOperator);
    if (vertex.getExecutionConfig().isObjectReuseEnabled() || chainableOperator.isInputCopyingDisabled()) {
      return new ChainingOutput<X>(chainableOperator);
    }
 else {
      TypeSerializer<X> typeSer=chainedTaskConfig.getTypeSerializerIn1(userCodeClassloader);
      TypeSerializer<StreamRecord<X>> inSerializer;
      if (vertex.getExecutionConfig().areTimestampsEnabled()) {
        inSerializer=(TypeSerializer<StreamRecord<X>>)(TypeSerializer<?>)new MultiplexingStreamRecordSerializer<X>(typeSer);
      }
 else {
        inSerializer=new StreamRecordSerializer<X>(typeSer);
      }
      return new CopyingChainingOutput<X>(chainableOperator,inSerializer);
    }
  }
}
