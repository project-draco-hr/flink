{
  if (LOG.isDebugEnabled()) {
    LOG.debug(this.taskContext.formatLogString("Running Cross with Block-Nested-Loops: " + "First input is outer (blocking) side, second input is inner (spilling) side."));
  }
  final MutableObjectIterator<T1> in1=this.taskContext.getInput(0);
  final MutableObjectIterator<T2> in2=this.taskContext.getInput(1);
  final TypeSerializer<T1> serializer1=this.taskContext.<T1>getInputSerializer(0).getSerializer();
  final TypeSerializer<T2> serializer2=this.taskContext.<T2>getInputSerializer(1).getSerializer();
  final BlockResettableMutableObjectIterator<T1> blockVals=new BlockResettableMutableObjectIterator<T1>(this.memManager,in1,serializer1,this.memPagesForBlockSide,this.taskContext.getOwningNepheleTask());
  this.blockIter=blockVals;
  final SpillingResettableMutableObjectIterator<T2> spillVals=new SpillingResettableMutableObjectIterator<T2>(in2,serializer2,this.memManager,this.taskContext.getIOManager(),this.memPagesForSpillingSide,this.taskContext.getOwningNepheleTask());
  this.spillIter=spillVals;
  T1 val1;
  final T1 val1Reuse=serializer1.createInstance();
  T2 val2;
  final T2 val2Reuse=serializer2.createInstance();
  T2 val2Copy=serializer2.createInstance();
  final CrossFunction<T1,T2,OT> crosser=this.taskContext.getStub();
  final Collector<OT> collector=this.taskContext.getOutputCollector();
  do {
    while (this.running && ((val2=spillVals.next(val2Reuse)) != null)) {
      while ((val1=blockVals.next(val1Reuse)) != null) {
        val2Copy=serializer2.copy(val2,val2Copy);
        collector.collect(crosser.cross(val1,val2Copy));
      }
      blockVals.reset();
    }
    spillVals.reset();
  }
 while (this.running && blockVals.nextBlock());
}
