{
  Ordering order=new Ordering(0,PactInteger.class,Order.ASCENDING);
  DataDistribution<PactRecord> dd=new PactRecordDataDistribution(order,new Key[][]{{new PactInteger(1)},{new PactInteger(2)},{new PactInteger(3)}});
  Assert.assertTrue(dd != null);
  int[] keyPos=dd.getBoundaryKeyPositions();
  Assert.assertTrue(keyPos.length == 1);
  Assert.assertTrue(keyPos[0] == 0);
  Class<? extends Key>[] keyTypes=dd.getBoundaryKeyTypes();
  Assert.assertTrue(keyTypes.length == 1);
  Assert.assertTrue(keyTypes[0].equals(PactInteger.class));
  Order[] keyOrders=dd.getBoundaryKeyOrders();
  Assert.assertTrue(keyOrders.length == 1);
  Assert.assertTrue(keyOrders[0].equals(Order.ASCENDING));
  try {
    dd=new PactRecordDataDistribution(order,new Key[][]{{new PactInteger(1)},{new PactString("ABC")},{new PactInteger(3)}});
    Assert.fail("Data distribution accepts incorrect key types");
  }
 catch (  IllegalArgumentException iae) {
  }
  try {
    dd=new PactRecordDataDistribution(order,new Key[][]{{new PactInteger(1)},{new PactInteger(2),new PactInteger(2)},{new PactInteger(3)}});
    Assert.fail("Data distribution accepts bucket boundaries with inconsistent many keys");
  }
 catch (  IllegalArgumentException iae) {
  }
  try {
    dd=new PactRecordDataDistribution(order,new Key[][]{{new PactInteger(1)},{new PactInteger(4)},{new PactInteger(3)}});
    Assert.fail("Data distribution accepts bucket boundaries in incorrect order");
  }
 catch (  IllegalArgumentException iae) {
  }
}
