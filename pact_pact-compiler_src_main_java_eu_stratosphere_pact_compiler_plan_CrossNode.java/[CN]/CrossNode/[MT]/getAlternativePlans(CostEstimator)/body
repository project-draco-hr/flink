{
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<CrossNode> outputPlans=new ArrayList<CrossNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      if (ss1 != ShipStrategy.NONE) {
        createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
      }
 else {
        createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
        createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
      }
    }
  }
  if (outputPlans.isEmpty()) {
    throw new CompilerException("Could not create a valid plan for the cross contract '" + getPactContract().getName() + "'. The compiler hints specified incompatible shipping strategies.");
  }
  prunePlanAlternatives(outputPlans);
  if (isBranching()) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
