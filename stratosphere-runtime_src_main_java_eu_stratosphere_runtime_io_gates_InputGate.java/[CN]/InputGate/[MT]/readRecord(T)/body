{
  if (this.channelToReadFrom == -1) {
    if (this.isClosed()) {
      return InputChannelResult.END_OF_STREAM;
    }
    if (Thread.interrupted()) {
      throw new InterruptedException();
    }
    this.channelToReadFrom=waitForAnyChannelToBecomeAvailable();
  }
  InputChannelResult result=this.getInputChannel(this.channelToReadFrom).readRecord(target);
switch (result) {
case INTERMEDIATE_RECORD_FROM_BUFFER:
    return InputChannelResult.INTERMEDIATE_RECORD_FROM_BUFFER;
case LAST_RECORD_FROM_BUFFER:
  this.channelToReadFrom=-1;
return InputChannelResult.LAST_RECORD_FROM_BUFFER;
case END_OF_SUPERSTEP:
this.channelToReadFrom=-1;
return InputChannelResult.END_OF_SUPERSTEP;
case TASK_EVENT:
this.currentEvent=this.getInputChannel(this.channelToReadFrom).getCurrentEvent();
this.channelToReadFrom=-1;
return InputChannelResult.TASK_EVENT;
case NONE:
this.channelToReadFrom=-1;
return InputChannelResult.NONE;
case END_OF_STREAM:
this.channelToReadFrom=-1;
return isClosed() ? InputChannelResult.END_OF_STREAM : InputChannelResult.NONE;
default :
throw new RuntimeException();
}
}
