{
  final SocketChannel socketChannel=(SocketChannel)this.selectionKey.channel();
  if (this.currentEnvelope != null) {
    LOG.error("The connection between " + socketChannel.socket().getLocalAddress() + " and "+ socketChannel.socket().getRemoteSocketAddress()+ " experienced an IOException for transfer envelope "+ this.currentEnvelope.getSequenceNumber());
  }
 else {
    LOG.error("The connection between " + socketChannel.socket().getLocalAddress() + " and "+ socketChannel.socket().getRemoteSocketAddress()+ " experienced an IOException");
  }
synchronized (this.queuedEnvelopes) {
    try {
      LOG.debug("Closing connection to " + socketChannel.socket().getRemoteSocketAddress());
      socketChannel.close();
    }
 catch (    IOException e) {
      LOG.debug("An error occurred while responding to an IOException");
      LOG.debug(e);
    }
    this.selectionKey.cancel();
    LOG.error(ioe);
    if (this.queuedEnvelopes.isEmpty()) {
      this.isConnected=false;
      this.isSubscribedToWriteEvent=false;
    }
 else {
      this.connectionThread.triggerConnect(this);
      this.isConnected=true;
      this.isSubscribedToWriteEvent=true;
    }
    if (this.currentEnvelope != null) {
      this.byteBufferedChannelManager.reportIOExceptionForOutputChannel(this.currentEnvelope.getSource(),ioe);
      if (this.currentEnvelope.getBuffer() != null) {
        this.currentEnvelope.getBuffer().recycleBuffer();
        this.currentEnvelope=null;
      }
    }
  }
}
