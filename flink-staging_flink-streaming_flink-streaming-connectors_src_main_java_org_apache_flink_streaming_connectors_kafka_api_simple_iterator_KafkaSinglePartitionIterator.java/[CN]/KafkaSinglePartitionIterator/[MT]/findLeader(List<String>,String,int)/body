{
  PartitionMetadata returnMetaData=null;
  loop:   for (  String address : addresses) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Trying to find leader via broker: {}",address);
    }
    String[] split=address.split(":");
    String host=split[0];
    int port=Integer.parseInt(split[1]);
    SimpleConsumer consumer=null;
    try {
      consumer=new SimpleConsumer(host,port,consumerConfig.socketTimeoutMs(),consumerConfig.socketReceiveBufferBytes(),"leaderLookup");
      List<String> topics=Collections.singletonList(topic);
      TopicMetadataRequest req=new TopicMetadataRequest(topics);
      kafka.javaapi.TopicMetadataResponse resp=consumer.send(req);
      List<TopicMetadata> metaData=resp.topicsMetadata();
      for (      TopicMetadata item : metaData) {
        for (        PartitionMetadata part : item.partitionsMetadata()) {
          if (part.partitionId() == partition) {
            returnMetaData=part;
            break loop;
          }
        }
      }
    }
 catch (    Exception e) {
      if (e instanceof ClosedChannelException) {
        LOG.warn("Got ClosedChannelException while trying to communicate with Broker" + "[{}] to find Leader for [{}, {}]. Trying other replicas.",address,topic,partition);
      }
 else {
        throw new RuntimeException("Error communicating with Broker [" + address + "] to find Leader for ["+ topic+ ", "+ partition+ "]",e);
      }
    }
 finally {
      if (consumer != null) {
        consumer.close();
      }
    }
  }
  if (returnMetaData != null) {
    replicaBrokers.clear();
    for (    kafka.cluster.Broker replica : returnMetaData.replicas()) {
      replicaBrokers.add(replica.host() + ":" + replica.port());
    }
  }
  return returnMetaData;
}
