{
  super.configure(parameters);
  int configNumFields=parameters.getInteger(NUM_FIELDS_PARAMETER,-1);
  if (ctorInstantiation) {
    if (configNumFields > 0) {
      throw new IllegalStateException("CsvOutputFormat instantiated via both parameters and config.");
    }
    return;
  }
  if (configNumFields < 1) {
    throw new IllegalStateException("CsvOutputFormat not configured via parameters or config.");
  }
  this.numFields=configNumFields;
  @SuppressWarnings("unchecked") Class<Value>[] arr=new Class[this.numFields];
  this.classes=arr;
  try {
    ClassLoader cl=Thread.currentThread().getContextClassLoader();
    for (int i=0; i < this.numFields; i++) {
      Class<? extends Value> clazz=parameters.<Value>getClass(FIELD_TYPE_PARAMETER_PREFIX + i,null,cl);
      if (clazz == null) {
        throw new IllegalArgumentException("Invalid configuration for CsvOutputFormat: " + "No type class for parameter " + i);
      }
      this.classes[i]=clazz;
    }
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException("Could not resolve type classes",e);
  }
  this.recordPositions=new int[this.numFields];
  boolean anyRecordPosDefined=false;
  boolean allRecordPosDefined=true;
  for (int i=0; i < this.numFields; i++) {
    int pos=parameters.getInteger(RECORD_POSITION_PARAMETER_PREFIX + i,Integer.MIN_VALUE);
    if (pos != Integer.MIN_VALUE) {
      anyRecordPosDefined=true;
      if (pos < 0) {
        throw new IllegalArgumentException("Invalid configuration for CsvOutputFormat: " + "Invalid record position for parameter " + i);
      }
      this.recordPositions[i]=pos;
    }
 else {
      allRecordPosDefined=false;
      this.recordPositions[i]=i;
    }
  }
  if (anyRecordPosDefined && !allRecordPosDefined) {
    throw new IllegalArgumentException("Invalid configuration for CsvOutputFormat: " + "Either none or all record positions must be defined.");
  }
  this.recordDelimiter=parameters.getString(RECORD_DELIMITER_PARAMETER,AbstractConfigBuilder.NEWLINE_DELIMITER);
  if (this.recordDelimiter == null) {
    throw new IllegalArgumentException("The delimiter in the DelimitedOutputFormat must not be null.");
  }
  this.charsetName=parameters.getString(RECORD_DELIMITER_ENCODING,null);
  this.fieldDelimiter=parameters.getString(FIELD_DELIMITER_PARAMETER,",");
  this.lenient=parameters.getBoolean(LENIENT_PARSING,false);
}
