{
  ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  DataSet<Tuple3<String,String,Integer>> triplets=env.readCsvFile(args[0]).lineDelimiter("\n").fieldDelimiter('\t').types(String.class,String.class,Integer.class);
  DataSet<Tuple1<String>> mismatches=env.readTextFile(args[1]).map(new MapFunction<String,Tuple1<String>>(){
    public Tuple1<String> map(    String value){
      return null;
    }
  }
);
  DataSet<Tuple3<String,String,Integer>> validTriplets=triplets.coGroup(mismatches).where(1).equalTo(0).with(new CoGroupFunction<Tuple3<String,String,Integer>,Tuple1<String>,Tuple3<String,String,Integer>>(){
    public void coGroup(    Iterable<Tuple3<String,String,Integer>> triplets,    Iterable<Tuple1<String>> invalidSongs,    Collector<Tuple3<String,String,Integer>> out){
      if (!invalidSongs.iterator().hasNext()) {
        out.collect(triplets.iterator().next());
      }
    }
  }
);
  DataSet<Edge<String,Integer>> userSongEdges=validTriplets.map(new Tuple3ToEdgeMap<String,Integer>());
  Graph<String,NullValue,Integer> userSongGraph=Graph.create(userSongEdges,env);
  DataSet<Tuple2<String,String>> usersWithTopTrack=userSongGraph.reduceOnEdges(new EdgesFunction<String,Integer,String>(){
    public Tuple2<String,String> iterateEdges(    Iterable<Tuple2<String,Edge<String,Integer>>> edges){
      int maxPlaycount=0;
      String userId="";
      String topSong="";
      final Iterator<Tuple2<String,Edge<String,Integer>>> edgesIterator=edges.iterator();
      if (edgesIterator.hasNext()) {
        Tuple2<String,Edge<String,Integer>> first=edgesIterator.next();
        userId=first.f0;
        topSong=first.f1.getTarget();
      }
      while (edgesIterator.hasNext()) {
        Tuple2<String,Edge<String,Integer>> edge=edgesIterator.next();
        if (edge.f1.getValue() > maxPlaycount) {
          maxPlaycount=edge.f1.getValue();
          topSong=edge.f1.getTarget();
        }
      }
      return new Tuple2<String,String>(userId,topSong);
    }
  }
,EdgeDirection.OUT);
}
