{
  super.read(in);
  final int numInputChannels=in.readInt();
  for (int i=0; i < numInputChannels; i++) {
    final ChannelID channelID=new ChannelID();
    channelID.read(in);
    final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
    final String className=StringRecord.readString(in);
    Class<? extends IOReadableWritable> c=null;
    try {
      c=ClassUtils.getRecordByName(className);
    }
 catch (    ClassNotFoundException e) {
      LOG.error(e);
    }
    if (c == null) {
      throw new IOException("Class is null!");
    }
    AbstractInputChannel<T> eic=null;
    try {
      final Constructor<AbstractInputChannel<T>> constructor=(Constructor<AbstractInputChannel<T>>)c.getDeclaredConstructor(this.getClass(),int.class,RecordDeserializer.class,ChannelID.class,CompressionLevel.class);
      if (constructor == null) {
        throw new IOException("Constructor is null!");
      }
      constructor.setAccessible(true);
      eic=constructor.newInstance(this,i,deserializer,channelID,compressionLevel);
    }
 catch (    SecurityException e) {
      LOG.error(e);
    }
catch (    NoSuchMethodException e) {
      LOG.error(e);
    }
catch (    IllegalArgumentException e) {
      LOG.error(e);
    }
catch (    InstantiationException e) {
      LOG.error(e);
    }
catch (    IllegalAccessException e) {
      LOG.error(e);
    }
catch (    InvocationTargetException e) {
      LOG.error(e);
    }
    if (eic == null) {
      throw new IOException("Created input channel is null!");
    }
    eic.read(in);
    addInputChannel(eic);
  }
}
