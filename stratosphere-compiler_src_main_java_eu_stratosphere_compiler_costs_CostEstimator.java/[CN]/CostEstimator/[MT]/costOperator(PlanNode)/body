{
  final Costs totalCosts=new Costs();
  final long availableMemory=n.getGuaranteedAvailableMemory();
  for (Iterator<Channel> channels=n.getInputs(); channels.hasNext(); ) {
    final Channel channel=channels.next();
    final Costs costs=new Costs();
switch (channel.getShipStrategy()) {
case NONE:
      throw new CompilerException("Cannot determine costs: Shipping strategy has not been set for an input.");
case FORWARD:
    break;
case PARTITION_LOCAL_HASH:
  break;
case PARTITION_RANDOM:
addRandomPartitioningCost(channel,costs);
break;
case PARTITION_HASH:
addHashPartitioningCost(channel,costs);
break;
case PARTITION_RANGE:
addRangePartitionCost(channel,costs);
break;
case BROADCAST:
addBroadcastCost(channel,channel.getReplicationFactor(),costs);
break;
default :
throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy());
}
switch (channel.getLocalStrategy()) {
case NONE:
break;
case SORT:
case COMBININGSORT:
addLocalSortCost(channel,availableMemory,costs);
break;
default :
throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy());
}
if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {
addArtificialDamCost(channel,0,costs);
}
if (channel.isOnDynamicPath()) {
costs.multiplyWith(channel.getCostWeight());
}
totalCosts.addCosts(costs);
}
Channel firstInput=null;
Channel secondInput=null;
Costs driverCosts=new Costs();
{
Iterator<Channel> channels=n.getInputs();
if (channels.hasNext()) {
firstInput=channels.next();
}
if (channels.hasNext()) {
secondInput=channels.next();
}
}
switch (n.getDriverStrategy()) {
case NONE:
case UNARY_NO_OP:
case BINARY_NO_OP:
case COLLECTOR_MAP:
case MAP:
case FLAT_MAP:
case ALL_GROUP:
case CO_GROUP:
case SORTED_GROUP:
case PARTIAL_GROUP:
case UNION:
break;
case MERGE:
addLocalMergeCost(firstInput,secondInput,availableMemory,driverCosts);
break;
case HYBRIDHASH_BUILD_FIRST:
addHybridHashCosts(firstInput,secondInput,availableMemory,driverCosts);
break;
case HYBRIDHASH_BUILD_SECOND:
addHybridHashCosts(secondInput,firstInput,availableMemory,driverCosts);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
addBlockNestedLoopsCosts(firstInput,secondInput,availableMemory,driverCosts);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
addBlockNestedLoopsCosts(secondInput,firstInput,availableMemory,driverCosts);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
addStreamedNestedLoopsCosts(firstInput,secondInput,availableMemory,driverCosts);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
addStreamedNestedLoopsCosts(secondInput,firstInput,availableMemory,driverCosts);
break;
case GROUP_SELF_NESTEDLOOP:
default :
throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name());
}
if (n.isOnDynamicPath()) {
driverCosts.multiplyWith(n.getCostWeight());
}
totalCosts.addCosts(driverCosts);
n.setCosts(totalCosts);
}
