{
  org.junit.Assume.assumeTrue(mode != TestExecutionMode.COLLECTION);
  final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  DataSet<Tuple3<Integer,Long,String>> ds=CollectionDataSets.get3TupleDataSet(env);
  UnsortedGrouping<Tuple3<Integer,Long,String>> partitionedDS=ds.partitionByHash(0).groupBy(1);
  partitionedDS.combineGroup(new FlatCombineFunction<Tuple3<Integer,Long,String>,Tuple2<Long,Integer>>(){
    @Override public void combine(    Iterable<Tuple3<Integer,Long,String>> values,    Collector<Tuple2<Long,Integer>> out) throws Exception {
      int count=0;
      long key=0;
      for (      Tuple3<Integer,Long,String> value : values) {
        key=value.f1;
        count++;
      }
      out.collect(new Tuple2(key,count));
    }
  }
).writeAsCsv(resultPath);
  env.execute();
  String notExpected="6,6\n" + "5,5\n" + "4,4\n"+ "3,3\n"+ "2,2\n"+ "1,1\n";
  ArrayList<String> list=new ArrayList<String>();
  readAllResultLines(list,resultPath);
  String[] result=list.toArray(new String[list.size()]);
  Arrays.sort(result);
  String[] expected=notExpected.split("\n");
  Arrays.sort(expected);
  Assert.assertEquals("The two arrays were identical.",false,Arrays.equals(expected,result));
}
