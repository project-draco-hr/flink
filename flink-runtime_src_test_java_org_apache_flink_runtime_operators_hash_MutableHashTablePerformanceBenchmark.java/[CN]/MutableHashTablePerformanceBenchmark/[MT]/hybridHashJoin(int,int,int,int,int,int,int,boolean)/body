{
  InputIterator buildIterator=new InputIterator(buildSize,buildStep,buildScope);
  InputIterator probeIterator=new InputIterator(probeSize,probeStep,probeScope);
  List<MemorySegment> memSegments;
  try {
    memSegments=this.memManager.allocatePages(MEM_OWNER,(int)(this.memManager.getMemorySize() / this.memManager.getPageSize()));
  }
 catch (  MemoryAllocationException maex) {
    fail("Memory for the Join could not be provided.");
    return -1;
  }
  long start=System.currentTimeMillis();
  final MutableHashTable<StringPair,StringPair> join=new MutableHashTable<StringPair,StringPair>(this.pairBuildSideAccesssor,this.pairProbeSideAccesssor,this.pairBuildSideComparator,this.pairProbeSideComparator,this.pairComparator,memSegments,ioManager,enableBloomFilter);
  join.open(buildIterator,probeIterator);
  final StringPair recordReuse=new StringPair();
  int numRecordsInJoinResult=0;
  while (join.nextRecord()) {
    MutableHashTable.HashBucketIterator<StringPair,StringPair> buildSide=join.getBuildSideIterator();
    while (buildSide.next(recordReuse) != null) {
      numRecordsInJoinResult++;
    }
  }
  Assert.assertEquals("Wrong number of records in join result.",expectedResultSize,numRecordsInJoinResult);
  join.close();
  long cost=System.currentTimeMillis() - start;
  this.memManager.release(join.getFreedMemory());
  return cost;
}
