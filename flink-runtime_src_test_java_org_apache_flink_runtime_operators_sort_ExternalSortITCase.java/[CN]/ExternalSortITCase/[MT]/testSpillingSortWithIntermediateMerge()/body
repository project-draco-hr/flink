{
  try {
    final int PAIRS=10000000;
    final Comparator<TestData.Key> keyComparator=new TestData.KeyComparator();
    final TestData.Generator generator=new TestData.Generator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
    final MutableObjectIterator<Record> source=new TestData.GeneratorIterator(generator,PAIRS);
    LOG.debug("Initializing sortmerger...");
    Sorter<Record> merger=new UnilateralSortMerger<Record>(this.memoryManager,this.ioManager,source,this.parentTask,this.pactRecordSerializer,this.pactRecordComparator,(double)64 / 78,16,0.7f,false);
    LOG.debug("Emitting data...");
    MutableObjectIterator<Record> iterator=merger.getIterator();
    LOG.debug("Checking results...");
    int pairsRead=1;
    int nextStep=PAIRS / 20;
    Record rec1=new Record();
    Record rec2=new Record();
    Assert.assertTrue((rec1=iterator.next(rec1)) != null);
    while ((rec2=iterator.next(rec2)) != null) {
      final Key k1=rec1.getField(0,TestData.Key.class);
      final Key k2=rec2.getField(0,TestData.Key.class);
      pairsRead++;
      Assert.assertTrue(keyComparator.compare(k1,k2) <= 0);
      Record tmp=rec1;
      rec1=rec2;
      k1.setKey(k2.getKey());
      rec2=tmp;
      if (pairsRead == nextStep) {
        nextStep+=PAIRS / 20;
      }
    }
    Assert.assertEquals("Not all pairs were read back in.",PAIRS,pairsRead);
    merger.close();
    testSuccess=true;
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}
