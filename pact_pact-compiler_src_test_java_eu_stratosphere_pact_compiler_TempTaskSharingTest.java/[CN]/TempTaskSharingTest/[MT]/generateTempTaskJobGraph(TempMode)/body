{
  FileDataSourceContract<PactInteger,PactInteger> source=new FileDataSourceContract<PactInteger,PactInteger>(DummyInputFormat.class,IN_FILE_1,"Source");
  source.setDegreeOfParallelism(defaultParallelism);
  MapContract<PactInteger,PactInteger,PactInteger,PactInteger> map1=new MapContract<PactInteger,PactInteger,PactInteger,PactInteger>(IdentityMap.class,"Map1");
  map1.setDegreeOfParallelism(defaultParallelism);
  map1.setInput(source);
  FileDataSinkContract<PactInteger,PactInteger> sink=new FileDataSinkContract<PactInteger,PactInteger>(DummyOutputFormat.class,OUT_FILE_1,"Sink");
  sink.setDegreeOfParallelism(defaultParallelism);
  sink.setInput(map1);
  Plan plan=new Plan(sink,"Test Temp Task");
  OptimizedPlan oPlan=this.compiler.compile(plan,this.instanceType);
  oPlan.accept(new Visitor<OptimizerNode>(){
    @Override public boolean preVisit(    OptimizerNode visitable){
      if (visitable instanceof MapNode) {
        visitable.getIncomingConnections().get(0).setTempMode(mode);
        return false;
      }
      return true;
    }
    @Override public void postVisit(    OptimizerNode visitable){
    }
  }
);
  JobGraphGenerator jobGen=new JobGraphGenerator();
  return jobGen.compileJobGraph(oPlan);
}
