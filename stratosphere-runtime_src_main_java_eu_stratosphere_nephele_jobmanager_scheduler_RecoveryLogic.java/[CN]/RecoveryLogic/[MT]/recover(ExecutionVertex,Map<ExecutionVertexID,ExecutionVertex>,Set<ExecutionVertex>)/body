{
  if (failedVertex.getExecutionState() != ExecutionState.FAILED) {
    LOG.error("Vertex " + failedVertex + " is requested to be recovered, but is not failed");
    return false;
  }
  final ExecutionGraph eg=failedVertex.getExecutionGraph();
synchronized (eg) {
    LOG.info("Starting recovery for failed vertex " + failedVertex);
    final Set<ExecutionVertex> verticesToBeCanceled=new HashSet<ExecutionVertex>();
    findVerticesToRestart(failedVertex,verticesToBeCanceled);
    final Iterator<ExecutionVertex> cancelIterator=verticesToBeCanceled.iterator();
    while (cancelIterator.hasNext()) {
      final ExecutionVertex vertex=cancelIterator.next();
      if (vertex.compareAndUpdateExecutionState(ExecutionState.FINISHED,getStateToUpdate(vertex))) {
        LOG.info("Vertex " + vertex + " has already finished and will not be canceled");
        if (vertex.getExecutionState() == ExecutionState.ASSIGNED) {
          assignedVertices.add(vertex);
        }
        continue;
      }
      LOG.info(vertex + " is canceled by recovery logic");
      verticesToBeRestarted.put(vertex.getID(),vertex);
      final TaskCancelResult cancelResult=vertex.cancelTask();
      if (cancelResult.getReturnCode() != ReturnCode.SUCCESS && cancelResult.getReturnCode() != ReturnCode.TASK_NOT_FOUND) {
        verticesToBeRestarted.remove(vertex.getID());
        LOG.error("Unable to cancel vertex" + cancelResult.getDescription());
        return false;
      }
    }
    LOG.info("Starting cache invalidation");
    if (!invalidateReceiverLookupCaches(failedVertex,verticesToBeCanceled)) {
      return false;
    }
    LOG.info("Cache invalidation complete");
    failedVertex.updateExecutionState(getStateToUpdate(failedVertex));
    if (failedVertex.getExecutionState() == ExecutionState.ASSIGNED) {
      assignedVertices.add(failedVertex);
    }
  }
  return true;
}
