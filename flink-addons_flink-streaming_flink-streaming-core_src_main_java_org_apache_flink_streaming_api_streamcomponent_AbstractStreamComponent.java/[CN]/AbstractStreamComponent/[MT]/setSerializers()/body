{
  byte[] operatorBytes=configuration.getBytes("operator",null);
  String operatorName=configuration.getString("operatorName","");
  Object function=null;
  try {
    ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(operatorBytes));
    function=in.readObject();
    if (operatorName.equals("flatMap")) {
      setSerializerDeserializer(function,FlatMapFunction.class);
    }
 else     if (operatorName.equals("map")) {
      setSerializerDeserializer(function,MapFunction.class);
    }
 else     if (operatorName.equals("batchReduce")) {
      setSerializerDeserializer(function,GroupReduceFunction.class);
    }
 else     if (operatorName.equals("filter")) {
      setSerializerDeserializer(function,FilterFunction.class);
    }
 else     if (operatorName.equals("sink")) {
      setDeserializer(function,SinkFunction.class);
    }
 else     if (operatorName.equals("source")) {
      setSerializer(function,UserSourceInvokable.class,0);
    }
 else     if (operatorName.equals("elements")) {
      outTupleTypeInfo=new TupleTypeInfo<OUT>(TypeExtractor.getForObject(function));
      outTupleSerializer=outTupleTypeInfo.createSerializer();
      outSerializationDelegate=new SerializationDelegate<OUT>(outTupleSerializer);
    }
 else {
      throw new Exception("Wrong operator name!");
    }
  }
 catch (  Exception e) {
    throw new StreamComponentException("Nonsupported object (named " + operatorName + ") passed as operator");
  }
}
