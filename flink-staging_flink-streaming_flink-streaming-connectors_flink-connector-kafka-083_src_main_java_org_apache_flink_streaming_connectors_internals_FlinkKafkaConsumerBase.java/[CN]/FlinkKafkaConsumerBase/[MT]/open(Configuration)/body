{
  super.open(parameters);
  props.setProperty("enable.auto.commit","false");
switch (fetcherType) {
case INCLUDED:
    fetcher=new IncludedFetcher(props);
  break;
case LEGACY:
fetcher=new LegacyFetcher(topic,props);
break;
default :
throw new RuntimeException("Requested unknown fetcher " + fetcher);
}
List<TopicPartition> partitionsToSub=assignPartitions(this.partitions);
LOG.info("This instance (id={}) is going to subscribe to partitions {}",getRuntimeContext().getIndexOfThisSubtask(),partitionsToSub);
if (partitionsToSub.size() == 0) {
LOG.info("This instance is a no-op instance.");
isNoOp=true;
return;
}
fetcher.partitionsToRead(partitionsToSub);
lastOffsets=new long[partitions.length];
Arrays.fill(lastOffsets,OFFSET_NOT_SET);
if (offsetStore == OffsetStore.FLINK_ZOOKEEPER) {
String zkConnect=props.getProperty("zookeeper.connect");
if (zkConnect == null) {
throw new IllegalArgumentException("Required property 'zookeeper.connect' has not been set");
}
zkClient=new ZkClient(zkConnect,Integer.valueOf(props.getProperty("zookeeper.session.timeout.ms","6000")),Integer.valueOf(props.getProperty("zookeeper.connection.timeout.ms","6000")),new KafkaZKStringSerializer());
}
commitedOffsets=new long[partitions.length];
if (restoreToOffset != null) {
LOG.info("Found offsets to restore to: " + Arrays.toString(restoreToOffset));
for (int i=0; i < restoreToOffset.length; i++) {
if (restoreToOffset[i] != OFFSET_NOT_SET) {
fetcher.seek(new TopicPartition(topic,i),restoreToOffset[i] + 1);
}
}
}
 else {
if (offsetStore == OffsetStore.FLINK_ZOOKEEPER) {
for (TopicPartition tp : partitionsToSub) {
long offset=getOffset(zkClient,props.getProperty(ConsumerConfig.GROUP_ID_CONFIG),topic,tp.partition());
if (offset != OFFSET_NOT_SET) {
LOG.info("Offset for partition {} was set to {} in ZK. Seeking consumer to that position",tp.partition(),offset);
fetcher.seek(tp,offset + 1);
}
}
}
}
}
