{
  try {
    AlgorithmResults ar=this.results.addAlgorithmResultsForCompressionLevel(cl,getAlgorithmNameByCompressionLevel(cl));
    FileSystem fs=pathToTrainingFiles.getFileSystem();
    final FileStatus[] dir=fs.listStatus(pathToTrainingFiles);
    byte[] tmpBuffer=new byte[this.dataBlockSize];
    ByteBuffer tmpByteBuffer=ByteBuffer.allocate(dataBlockSize);
    int fileCounter=0;
    int blockCounterSum=0;
    int blockcounterPerFile=0;
    for (int i=0; i < dir.length; i++) {
      if (!dir[i].isDir()) {
        FileInfo fi=this.results.getFileInfo(fileCounter);
        long compressionTimePerFile=0;
        long decompressionTimePerFile=0;
        long compressedFileSize=0;
        for (int r=0; r < this.numberOfRounds; r++) {
          blockcounterPerFile=0;
          FSDataInputStream fdis=fs.open(dir[i].getPath());
          int readBytes=0;
          while ((readBytes=fdis.read(tmpBuffer,0,dataBlockSize)) != -1) {
            tmpByteBuffer.clear();
            tmpByteBuffer.put(tmpBuffer,0,readBytes);
            tmpByteBuffer.flip();
            this.uncompressed=BufferFactory.createFromMemory(dataBlockSize,ByteBuffer.allocateDirect(dataBlockSize),null);
            this.uncompressed2=BufferFactory.createFromMemory(dataBlockSize,ByteBuffer.allocateDirect(dataBlockSize),null);
            this.compressed=BufferFactory.createFromMemory(dataBlockSize + (dataBlockSize / 2),ByteBuffer.allocateDirect(dataBlockSize + (dataBlockSize / 2)),null);
            this.uncompressed.write(tmpByteBuffer);
            compressor.setUncompressedDataBuffer(uncompressed);
            compressor.setCompressedDataBuffer(compressed);
            long startTime=System.nanoTime();
            compressor.compress();
            long endTime=System.nanoTime();
            compressed.finishWritePhase();
            int compressedBytes=this.compressed.size();
            long time=Math.abs(endTime) - Math.abs(startTime);
            ar.compressionTimePerBlockPerRound[blockCounterSum + blockcounterPerFile][r]=time;
            compressionTimePerFile+=time;
            if (r == 0) {
              compressedFileSize+=compressedBytes;
              ar.compressionRatios[blockCounterSum + blockcounterPerFile]=(double)compressedBytes / (double)readBytes;
              ar.averageCompressionRatio+=ar.compressionRatios[blockCounterSum + blockcounterPerFile];
            }
            decompressor.setCompressedDataBuffer(compressed);
            decompressor.setUncompressedDataBuffer(uncompressed2);
            startTime=System.nanoTime();
            decompressor.decompress();
            endTime=System.nanoTime();
            time=Math.abs(endTime) - Math.abs(startTime);
            decompressionTimePerFile+=time;
            ar.decompressionTimePerBlockPerRound[blockCounterSum + blockcounterPerFile][r]=time;
            if (this.uncompressed2.size() != readBytes)             System.err.println("Error " + ar.algorithmName + " Expected "+ readBytes+ " Bytes - got "+ this.uncompressed2.size()+ " Bytes");
            ar.averageCompressionTimeOverRounds[blockCounterSum + blockcounterPerFile]+=ar.compressionTimePerBlockPerRound[blockCounterSum + blockcounterPerFile][r];
            ar.averageDecompressionTimeOverRounds[blockCounterSum + blockcounterPerFile]+=ar.decompressionTimePerBlockPerRound[blockCounterSum + blockcounterPerFile][r];
            ar.averageSysCpuloadOverRoundsCompression[blockCounterSum + blockcounterPerFile]+=ar.sysCpuloadPerBlockPerRoundCompression[blockCounterSum + blockcounterPerFile][r];
            ar.averageSysCpuloadOverRoundsDecompression[blockCounterSum + blockcounterPerFile]+=ar.sysCpuloadPerBlockPerRoundDecompression[blockCounterSum + blockcounterPerFile][r];
            ar.averageUserCpuloadOverRoundsCompression[blockCounterSum + blockcounterPerFile]+=ar.userCpuloadPerBlockPerRoundCompression[blockCounterSum + blockcounterPerFile][r];
            ar.averageUserCpuloadOverRoundsDecompression[blockCounterSum + blockcounterPerFile]+=ar.userCpuloadPerBlockPerRoundDecompression[blockCounterSum + blockcounterPerFile][r];
            ar.averageIdleCpuOverRoundsCompression[blockCounterSum + blockcounterPerFile]+=ar.idleCpuPerBlockPerRoundCompression[blockCounterSum + blockcounterPerFile][r];
            ar.averageIdleCpuOverRoundsDecompression[blockCounterSum + blockcounterPerFile]+=ar.idleCpuPerBlockPerRoundDecompression[blockCounterSum + blockcounterPerFile][r];
            ar.averageIOWaitCpuOverRoundsCompression[blockCounterSum + blockcounterPerFile]+=ar.ioWaitCpuPerBlockPerRoundCompression[blockCounterSum + blockcounterPerFile][r];
            ar.averageIOWaitCpuOverRoundsDecompression[blockCounterSum + blockcounterPerFile]+=ar.ioWaitCpuPerBlockPerRoundDecompression[blockCounterSum + blockcounterPerFile][r];
            blockcounterPerFile++;
          }
          fdis.close();
        }
        double averageCPULoadCompression=0.0, averageCPULoadDecompression=0.0;
        for (int b=blockCounterSum; b < (blockCounterSum + blockcounterPerFile); b++) {
          ar.averageCompressionTimeOverRounds[b]/=this.numberOfRounds;
          ar.averageDecompressionTimeOverRounds[b]/=this.numberOfRounds;
          ar.averageSysCpuloadOverRoundsCompression[b]/=(double)this.numberOfRounds;
          ar.averageSysCpuloadOverRoundsDecompression[b]/=(double)this.numberOfRounds;
          ar.averageUserCpuloadOverRoundsCompression[b]/=(double)this.numberOfRounds;
          ar.averageUserCpuloadOverRoundsDecompression[b]/=(double)this.numberOfRounds;
          ar.averageIdleCpuOverRoundsCompression[b]/=(double)this.numberOfRounds;
          ar.averageIdleCpuOverRoundsDecompression[b]/=(double)this.numberOfRounds;
          ar.averageIOWaitCpuOverRoundsCompression[b]/=(double)this.numberOfRounds;
          ar.averageIOWaitCpuOverRoundsDecompression[b]/=(double)this.numberOfRounds;
          averageCPULoadCompression+=(ar.averageSysCpuloadOverRoundsCompression[b] + ar.averageUserCpuloadOverRoundsCompression[b]);
          averageCPULoadDecompression+=(ar.averageSysCpuloadOverRoundsDecompression[b] + ar.averageUserCpuloadOverRoundsDecompression[b]);
          ar.averageCompressionTime+=ar.averageCompressionTimeOverRounds[b];
          ar.averageDecompressionTime+=ar.averageDecompressionTimeOverRounds[b];
        }
        averageCPULoadCompression/=(double)blockcounterPerFile;
        averageCPULoadDecompression/=(double)blockcounterPerFile;
        blockCounterSum+=blockcounterPerFile;
        fi.addAlgorithmResultsForCompressionLevel(cl,getAlgorithmNameByCompressionLevel(cl),compressionTimePerFile / numberOfRounds,decompressionTimePerFile / numberOfRounds,compressedFileSize,averageCPULoadCompression,averageCPULoadDecompression);
        fileCounter++;
        if (progress != null) {
          final int blocks=progress.getValue() + fi.dataBlocks;
          SwingUtilities.invokeLater(new Runnable(){
            @Override public void run(){
              progress.setValue(blocks);
            }
          }
);
        }
      }
    }
    ar.averageCompressionRatio/=(double)this.numberOfDataBlocks;
    ar.averageCompressionTime/=(double)this.numberOfDataBlocks;
    ar.averageDecompressionTime/=(double)this.numberOfDataBlocks;
  }
 catch (  IOException e) {
    print("An Error occured during computation of TrainingData!",true);
    e.printStackTrace();
  }
  return true;
}
