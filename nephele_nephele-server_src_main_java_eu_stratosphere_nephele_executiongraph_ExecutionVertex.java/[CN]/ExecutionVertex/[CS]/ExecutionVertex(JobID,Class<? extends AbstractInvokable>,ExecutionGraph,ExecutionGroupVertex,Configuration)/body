{
  this(new ExecutionVertexID(),invokableClass,executionGraph,groupVertex,new RuntimeEnvironment(jobID,groupVertex.getName(),invokableClass,groupVertex.getConfiguration(),jobConfiguration));
  this.groupVertex.addInitialSubtask(this);
  if (invokableClass == null) {
    LOG.error("Vertex " + groupVertex.getName() + " does not specify a task");
  }
  this.environment.instantiateInvokable();
  CheckpointState ics=CheckpointState.UNDECIDED;
  boolean hasFileChannels=false;
  for (int i=0; i < this.environment.getNumberOfOutputGates(); ++i) {
    if (this.environment.getOutputGate(i).getChannelType() == ChannelType.FILE) {
      hasFileChannels=true;
      break;
    }
  }
  if (hasFileChannels) {
    ics=CheckpointState.PARTIAL;
  }
 else {
    ForceCheckpoint forcedCheckpoint=this.environment.getInvokable().getClass().getAnnotation(ForceCheckpoint.class);
    if (forcedCheckpoint != null) {
      ics=forcedCheckpoint.checkpoint() ? CheckpointState.PARTIAL : CheckpointState.NONE;
    }
  }
  groupVertex.setInitialCheckpointState(ics);
  this.checkpointState.set(ics);
}
