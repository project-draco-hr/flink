{
  final ExecutionGraph executionGraph=executionStage.getExecutionGraph();
  final Map<InstanceType,Integer> requiredInstances=new HashMap<InstanceType,Integer>();
  executionStage.collectRequiredInstanceTypes(requiredInstances,ExecutionState.SCHEDULED);
  if (requiredInstances.isEmpty()) {
    return;
  }
  final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstances.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    for (int i=0; i < entry.getValue().intValue(); i++) {
      LOG.info("Trying to allocate instance of type " + entry.getKey().getIdentifier());
      this.instanceManager.requestInstance(executionGraph.getJobID(),executionGraph.getJobConfiguration(),entry.getKey());
    }
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,executionGraph.getIndexOfCurrentExecutionStage(),true,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.setExecutionState(ExecutionState.ASSIGNING);
    }
  }
}
