{
  if (allocatedResources == null) {
    LOG.error("Resource to lock is null!");
    return;
  }
  for (  final AllocatedResource allocatedResource : allocatedResources) {
    if (allocatedResource.getInstance() instanceof DummyInstance) {
      LOG.debug("Available instance is of type DummyInstance!");
      return;
    }
  }
  final ExecutionGraph eg=getExecutionGraphByID(jobID);
  if (eg == null) {
    try {
      for (      final AllocatedResource allocatedResource : allocatedResources) {
        getInstanceManager().releaseAllocatedResource(jobID,null,allocatedResource);
      }
    }
 catch (    InstanceException e) {
      LOG.error(e);
    }
    return;
  }
  final ExecutionStage stage=eg.getCurrentExecutionStage();
synchronized (stage) {
    for (    final AllocatedResource allocatedResource : allocatedResources) {
      AllocatedResource resourceToBeReplaced=null;
      final Iterator<ExecutionGroupVertex> groupIterator=new ExecutionGroupVertexIterator(eg,true,stage.getStageNumber());
      while (groupIterator.hasNext()) {
        final ExecutionGroupVertex groupVertex=groupIterator.next();
        for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); ++i) {
          final ExecutionVertex vertex=groupVertex.getGroupMember(i);
          if (vertex.getExecutionState() == ExecutionState.SCHEDULED && vertex.getAllocatedResource() != null) {
            if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
              resourceToBeReplaced=vertex.getAllocatedResource();
              break;
            }
          }
        }
        if (resourceToBeReplaced != null) {
          break;
        }
      }
      if (resourceToBeReplaced == null) {
        LOG.error("Instance " + allocatedResource.getInstance() + " is not required for job"+ eg.getJobID());
        try {
          getInstanceManager().releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
        }
 catch (        InstanceException e) {
          LOG.error(e);
        }
        return;
      }
      final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,true);
      while (it.hasNext()) {
        final ExecutionVertex vertex=it.next();
        if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
          vertex.setAllocatedResource(allocatedResource);
          vertex.updateExecutionState(ExecutionState.ASSIGNED);
        }
      }
    }
  }
  deployAssignedInputVertices(eg);
}
