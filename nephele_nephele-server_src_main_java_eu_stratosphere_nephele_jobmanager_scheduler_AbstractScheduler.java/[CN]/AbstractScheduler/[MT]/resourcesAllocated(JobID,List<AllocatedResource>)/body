{
  for (  final AllocatedResource allocatedResource : allocatedResources) {
    if (allocatedResources == null) {
      LOG.error("Resource to lock is null!");
      return;
    }
    if (allocatedResource.getInstance() instanceof DummyInstance) {
      LOG.debug("Available instance is of type DummyInstance!");
      return;
    }
    try {
      allocatedResource.getInstance().checkLibraryAvailability(jobID);
    }
 catch (    IOException ioe) {
      LOG.error("Cannot check library availability: " + StringUtils.stringifyException(ioe));
    }
  }
  final ExecutionGraph eg=getExecutionGraphByID(jobID);
  if (eg == null) {
    try {
      for (      final AllocatedResource allocatedResource : allocatedResources) {
        getInstanceManager().releaseAllocatedResource(jobID,null,allocatedResource);
      }
    }
 catch (    InstanceException e) {
      LOG.error(e);
    }
    return;
  }
synchronized (eg) {
    final int indexOfCurrentStage=eg.getIndexOfCurrentExecutionStage();
    for (    final AllocatedResource allocatedResource : allocatedResources) {
      AllocatedResource resourceToBeReplaced=null;
      ExecutionGraphIterator it=new ExecutionGraphIterator(eg,indexOfCurrentStage,true,true);
      while (it.hasNext()) {
        final ExecutionVertex vertex=it.next();
        if (vertex.getExecutionState() == ExecutionState.SCHEDULED && vertex.getAllocatedResource() != null) {
          if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
            resourceToBeReplaced=vertex.getAllocatedResource();
            break;
          }
        }
      }
      if (resourceToBeReplaced == null) {
        LOG.error("Instance " + allocatedResource.getInstance() + " is not required for job"+ eg.getJobID());
        try {
          getInstanceManager().releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
        }
 catch (        InstanceException e) {
          LOG.error(e);
        }
        return;
      }
      it=new ExecutionGraphIterator(eg,true);
      while (it.hasNext()) {
        final ExecutionVertex vertex=it.next();
        if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
          vertex.setAllocatedResource(allocatedResource);
          vertex.setExecutionState(ExecutionState.READY);
        }
      }
    }
    deployAssignedVertices(eg);
  }
}
