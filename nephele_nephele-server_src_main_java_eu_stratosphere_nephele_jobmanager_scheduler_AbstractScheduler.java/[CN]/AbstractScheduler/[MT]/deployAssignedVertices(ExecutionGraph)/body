{
  final Map<AbstractInstance,List<ExecutionVertex>> verticesToBeDeployed=new HashMap<AbstractInstance,List<ExecutionVertex>>();
  final int indexOfCurrentExecutionStage=executionGraph.getIndexOfCurrentExecutionStage();
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(executionGraph,indexOfCurrentExecutionStage,true,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    if (vertex.getExecutionState() == ExecutionState.ASSIGNED) {
      final AbstractInstance instance=vertex.getAllocatedResource().getInstance();
      if (instance instanceof DummyInstance) {
        LOG.error("Inconsistency: Vertex " + vertex.getName() + "("+ vertex.getEnvironment().getIndexInSubtaskGroup()+ "/"+ vertex.getEnvironment().getCurrentNumberOfSubtasks()+ ") is about to be deployed on a DummyInstance");
      }
      List<ExecutionVertex> verticesForInstance=verticesToBeDeployed.get(instance);
      if (verticesForInstance == null) {
        verticesForInstance=new ArrayList<ExecutionVertex>();
        verticesToBeDeployed.put(instance,verticesForInstance);
      }
      verticesForInstance.add(vertex);
      vertex.setExecutionState(ExecutionState.READY);
    }
  }
  if (!verticesToBeDeployed.isEmpty()) {
    final Iterator<Map.Entry<AbstractInstance,List<ExecutionVertex>>> it2=verticesToBeDeployed.entrySet().iterator();
    while (it2.hasNext()) {
      final Map.Entry<AbstractInstance,List<ExecutionVertex>> entry=it2.next();
      this.deploymentManager.deploy(executionGraph.getJobID(),entry.getKey(),entry.getValue());
    }
  }
}
