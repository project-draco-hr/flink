{
  Preconditions.checkNotNull(uf);
  Preconditions.checkNotNull(mf);
  Preconditions.checkNotNull(edgesWithoutValue);
  Preconditions.checkArgument(maximumNumberOfIterations > 0,"The maximum number of iterations must be at least one.");
  TypeInformation<Tuple2<VertexKey,VertexKey>> edgesType=edgesWithoutValue.getType();
  Preconditions.checkArgument(edgesType.isTupleType() && edgesType.getArity() == 2,"The edges data set (for edges without edge values) must consist of 2-tuples.");
  TupleTypeInfo<?> tupleInfo=(TupleTypeInfo<?>)edgesType;
  Preconditions.checkArgument(tupleInfo.getTypeAt(0).equals(tupleInfo.getTypeAt(1)) && Comparable.class.isAssignableFrom(tupleInfo.getTypeAt(0).getTypeClass()),"Both tuple fields (source and target vertex id) must be of the data type that represents the vertex key and implement the java.lang.Comparable interface.");
  this.updateFunction=uf;
  this.messagingFunction=mf;
  this.edgesWithoutValue=edgesWithoutValue;
  this.edgesWithValue=null;
  this.maximumNumberOfIterations=maximumNumberOfIterations;
  this.aggregators=new HashMap<String,Aggregator<?>>();
  this.messageType=getMessageType(mf);
}
