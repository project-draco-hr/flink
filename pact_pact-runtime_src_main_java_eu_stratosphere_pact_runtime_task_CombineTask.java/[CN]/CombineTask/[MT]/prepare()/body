{
  final long availableMemory=this.config.getMemorySize();
  LocalStrategy ls=config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case COMBININGSORT:
    strategyMinMem=MIN_REQUIRED_MEMORY;
  break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException("The Combine task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ strategyMinMem+ " bytes.");
}
final MemoryManager memoryManager=getEnvironment().getMemoryManager();
final IOManager ioManager=getEnvironment().getIOManager();
this.keyPositions=this.config.getLocalStrategyKeyPositions(0);
this.keyClasses=this.config.getLocalStrategyKeyClasses(this.userCodeClassLoader);
if (this.keyPositions == null || this.keyClasses == null) {
throw new Exception("The key positions and types are not specified for the CombineTask.");
}
@SuppressWarnings("unchecked") final Comparator<Key>[] comparators=new Comparator[keyPositions.length];
final KeyComparator kk=new KeyComparator();
for (int i=0; i < comparators.length; i++) {
comparators[i]=kk;
}
switch (ls) {
case COMBININGSORT:
input=new AsynchronousPartialSorter(memoryManager,ioManager,availableMemory,comparators,keyPositions,keyClasses,inputs[0],this);
break;
default :
throw new RuntimeException("Invalid local strategy provided for CombineTask.");
}
}
