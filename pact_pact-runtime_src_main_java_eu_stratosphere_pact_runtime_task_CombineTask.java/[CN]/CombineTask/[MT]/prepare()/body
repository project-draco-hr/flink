{
  final long availableMemory=this.config.getMemorySize();
  LocalStrategy ls=config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case COMBININGSORT:
    strategyMinMem=MIN_REQUIRED_MEMORY;
  break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException("The Combine task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ strategyMinMem+ " bytes.");
}
final MemoryManager memoryManager=getEnvironment().getMemoryManager();
final MutableObjectIterator<T> in=getInput(0);
this.serializer=getInputSerializer(0);
this.comparator=getInputComparator(0);
switch (ls) {
case COMBININGSORT:
input=new AsynchronousPartialSorter<T>(memoryManager,in,this,this.serializer,this.comparator.duplicate(),availableMemory);
break;
default :
throw new RuntimeException("Invalid local strategy provided for CombineTask.");
}
}
