{
  if (args == null || args.length != 4) {
    LOGGER.warn("number of arguments do not match!");
    this.ordersInputPath="";
    this.lineItemInputPath="";
    this.outputPath="";
  }
 else {
    setArgs(args);
  }
  FileDataSource orders=new FileDataSource(IntTupleDataInFormat.class,this.ordersInputPath,"Orders");
  orders.setDegreeOfParallelism(this.degreeOfParallelism);
  FileDataSource lineItems=new FileDataSource(IntTupleDataInFormat.class,this.lineItemInputPath,"LineItems");
  lineItems.setDegreeOfParallelism(this.degreeOfParallelism);
  FileDataSink result=new FileDataSink(StringTupleDataOutFormat.class,this.outputPath,"Output");
  result.setDegreeOfParallelism(degreeOfParallelism);
  MapContract lineFilter=new MapContract(LiFilter.class,"LineItemFilter");
  lineFilter.setDegreeOfParallelism(degreeOfParallelism);
  MapContract ordersFilter=new MapContract(OFilter.class,"OrdersFilter");
  ordersFilter.setDegreeOfParallelism(degreeOfParallelism);
  MatchContract join=new MatchContract(JoinLiO.class,PactInteger.class,0,0,"OrdersLineitemsJoin");
  join.setDegreeOfParallelism(degreeOfParallelism);
  ReduceContract aggregation=new ReduceContract(CountAgg.class,PactString.class,0,"AggregateGroupBy");
  aggregation.setDegreeOfParallelism(this.degreeOfParallelism);
  lineFilter.setInput(lineItems);
  ordersFilter.setInput(orders);
  join.setFirstInput(ordersFilter);
  join.setSecondInput(lineFilter);
  aggregation.setInput(join);
  result.setInput(aggregation);
  return new Plan(result,"TPC-H 4");
}
