{
  final int NUM_ELEMENTS=10;
  StreamExecutionEnvironment env=StreamExecutionEnvironment.createRemoteEnvironment("localhost",cluster.getLeaderRPCPort());
  env.setParallelism(1);
  env.getConfig().disableSysoutLogging();
  env.getConfig().enableTimestamps();
  env.getConfig().setAutoWatermarkInterval(1);
  DataStream<Integer> source1=env.addSource(new SourceFunction<Integer>(){
    @Override public void run(    SourceContext<Integer> ctx) throws Exception {
      int index=0;
      while (index < NUM_ELEMENTS) {
        ctx.collect(index);
        Thread.sleep(100);
        ctx.collect(index - 1);
        latch.await();
        index++;
      }
    }
    @Override public void cancel(){
    }
  }
);
  source1.assignTimestamps(new TimestampExtractor<Integer>(){
    @Override public long extractTimestamp(    Integer element,    long currentTimestamp){
      return element;
    }
    @Override public long extractWatermark(    Integer element,    long currentTimestamp){
      return element - 1;
    }
    @Override public long getCurrentWatermark(){
      return Long.MIN_VALUE;
    }
  }
).transform("Watermark Check",BasicTypeInfo.INT_TYPE_INFO,new CustomOperator(true)).transform("Timestamp Check",BasicTypeInfo.INT_TYPE_INFO,new TimestampCheckingOperator());
  env.execute();
  for (int j=0; j < NUM_ELEMENTS; j++) {
    if (!CustomOperator.finalWatermarks[0].get(j).equals(new Watermark(j - 1))) {
      Assert.fail("Wrong watermark.");
    }
  }
  if (!CustomOperator.finalWatermarks[0].get(NUM_ELEMENTS).equals(new Watermark(Long.MAX_VALUE))) {
    Assert.fail("Wrong watermark.");
  }
}
