{
  final EvaluationExpression similarityFunction=this.getSimilarityFunction();
  final RecordLinkage recordLinkage=new RecordLinkage(new DisjunctPartitioning(this.leftBlockingKeys,this.leftBlockingKeys),similarityFunction,this.threshold,(JsonStream)null);
  final SopremoTestPlan sopremoTestPlan=this.createTestPlan(recordLinkage,this.useId,this.projection);
  EvaluationExpression duplicateProjection=this.projection;
  if (duplicateProjection == null)   duplicateProjection=new ArrayCreation(new PathExpression(new InputSelection(0),recordLinkage.getIdProjection(0)),new PathExpression(new InputSelection(1),recordLinkage.getIdProjection(0)));
  final EvaluationContext context=sopremoTestPlan.getEvaluationContext();
  for (  final KeyValuePair<Key,PactJsonObject> left : sopremoTestPlan.getInput(0)) {
    boolean skipPairs=true;
    for (    final KeyValuePair<Key,PactJsonObject> right : sopremoTestPlan.getInput(0)) {
      if (left == right) {
        skipPairs=false;
        continue;
      }
 else       if (skipPairs)       continue;
      boolean inSameBlockingBin=false;
      for (int index=0; index < this.leftBlockingKeys.length && !inSameBlockingBin; index++)       if (this.leftBlockingKeys[index].evaluate(left.getValue().getValue(),context).equals(this.leftBlockingKeys[index].evaluate(right.getValue().getValue(),context)))       inSameBlockingBin=true;
      if (!inSameBlockingBin)       continue;
      final CompactArrayNode pair=JsonUtil.asArray(left.getValue().getValue(),right.getValue().getValue());
      if (similarityFunction.evaluate(pair,context).getDoubleValue() > this.threshold)       sopremoTestPlan.getExpectedOutput(0).add(new PactJsonObject(duplicateProjection.evaluate(pair,context)));
    }
  }
  try {
    sopremoTestPlan.run();
  }
 catch (  final AssertionError error) {
    throw new AssertionError(String.format("For test %s: %s",this,error.getMessage()));
  }
}
