{
  final TypeSerializerFactory<?> serializer=RecordSerializerFactory.get();
  @SuppressWarnings("unchecked") final TypeComparatorFactory<?> int0Comparator=new RecordComparatorFactory(new int[]{0},new Class[]{IntValue.class});
  JobGraph jobGraph=new JobGraph("KMeans Iterative");
  InputFormatVertex points=createPointsInput(jobGraph,pointsPath,numSubTasks,serializer);
  InputFormatVertex centers=createCentersInput(jobGraph,centersPath,numSubTasks,serializer);
  AbstractJobVertex head=createIterationHead(jobGraph,numSubTasks,serializer);
  AbstractJobVertex mapper=createMapper(jobGraph,numSubTasks,serializer,serializer,serializer,int0Comparator);
  AbstractJobVertex reducer=createReducer(jobGraph,numSubTasks,serializer,int0Comparator,serializer);
  AbstractJobVertex fakeTailOutput=JobGraphUtils.createFakeOutput(jobGraph,"FakeTailOutput",numSubTasks);
  AbstractJobVertex sync=createSync(jobGraph,numIterations,numSubTasks);
  OutputFormatVertex output=createOutput(jobGraph,resultPath,numSubTasks,serializer);
  JobGraphUtils.connect(points,mapper,ChannelType.NETWORK,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(centers,head,ChannelType.NETWORK,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(head,mapper,ChannelType.NETWORK,DistributionPattern.BIPARTITE);
  new TaskConfig(mapper.getConfiguration()).setBroadcastGateIterativeWithNumberOfEventsUntilInterrupt(0,numSubTasks);
  new TaskConfig(mapper.getConfiguration()).setInputCached(0,true);
  new TaskConfig(mapper.getConfiguration()).setRelativeInputMaterializationMemory(0,MEMORY_FRACTION_PER_CONSUMER);
  JobGraphUtils.connect(mapper,reducer,ChannelType.NETWORK,DistributionPattern.BIPARTITE);
  new TaskConfig(reducer.getConfiguration()).setGateIterativeWithNumberOfEventsUntilInterrupt(0,numSubTasks);
  JobGraphUtils.connect(reducer,fakeTailOutput,ChannelType.NETWORK,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(head,output,ChannelType.NETWORK,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(head,sync,ChannelType.NETWORK,DistributionPattern.BIPARTITE);
  SlotSharingGroup sharingGroup=new SlotSharingGroup();
  points.setSlotSharingGroup(sharingGroup);
  centers.setSlotSharingGroup(sharingGroup);
  head.setSlotSharingGroup(sharingGroup);
  mapper.setSlotSharingGroup(sharingGroup);
  reducer.setSlotSharingGroup(sharingGroup);
  fakeTailOutput.setSlotSharingGroup(sharingGroup);
  sync.setSlotSharingGroup(sharingGroup);
  output.setSlotSharingGroup(sharingGroup);
  mapper.setStrictlyCoLocatedWith(head);
  reducer.setStrictlyCoLocatedWith(head);
  fakeTailOutput.setStrictlyCoLocatedWith(reducer);
  return jobGraph;
}
