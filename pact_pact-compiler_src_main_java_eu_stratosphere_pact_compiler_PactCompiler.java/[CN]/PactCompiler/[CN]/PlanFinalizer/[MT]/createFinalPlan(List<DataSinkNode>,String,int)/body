{
  if (LOG.isDebugEnabled())   LOG.debug("Available memory per instance: " + memoryPerInstance);
  this.memoryPerInstance=memoryPerInstance;
  this.memoryConsumers=0;
  for (  DataSinkNode node : sinks) {
    node.accept(this);
  }
  if (this.memoryConsumers > 0) {
    int memoryPerTask=this.memoryPerInstance / this.memoryConsumers;
    LOG.debug("Memory per consumer: " + memoryPerTask);
    for (    OptimizerNode node : this.allNodes) {
      int consumerCount=node.getMemoryConsumerCount();
      if (consumerCount > 0) {
        node.setMemoryPerTask(memoryPerTask * consumerCount);
        LOG.debug("Assigned " + (memoryPerTask * consumerCount) + " MB to "+ node.getPactContract().getName());
      }
      for (      PactConnection conn : node.getOutConns()) {
        if (conn.getShipStrategy() == ShipStrategy.PARTITION_RANGE) {
          throw new RuntimeException("Range Partitioning currently not implemented.");
        }
      }
    }
  }
  return new OptimizedPlan(this.sources,this.sinks,this.allNodes,jobName);
}
