{
  if (this.con2node.containsKey(c)) {
    return false;
  }
  final OptimizerNode n;
  if (c instanceof GenericDataSink) {
    DataSinkNode dsn=new DataSinkNode((GenericDataSink)c);
    this.sinks.add(dsn);
    n=dsn;
  }
 else   if (c instanceof GenericDataSource) {
    DataSourceNode dsn=new DataSourceNode((GenericDataSource<?>)c);
    this.sources.add(dsn);
    n=dsn;
  }
 else   if (c instanceof GenericMapContract) {
    n=new MapNode((GenericMapContract<?>)c);
  }
 else   if (c instanceof GenericReduceContract) {
    n=new ReduceNode((GenericReduceContract<?>)c);
  }
 else   if (c instanceof GenericMatchContract) {
    n=new MatchNode((GenericMatchContract<?>)c);
  }
 else   if (c instanceof GenericCoGroupContract) {
    n=new CoGroupNode((GenericCoGroupContract<?>)c);
  }
 else   if (c instanceof GenericCrossContract) {
    n=new CrossNode((GenericCrossContract<?>)c);
  }
 else   if (c instanceof BulkIteration) {
    n=new BulkIterationNode((BulkIteration)c);
  }
 else   if (c instanceof WorksetIteration) {
    n=new WorksetIterationNode((WorksetIteration)c);
  }
 else   if (c instanceof PartialSolutionPlaceHolder) {
    final PartialSolutionPlaceHolder holder=(PartialSolutionPlaceHolder)c;
    final BulkIteration enclosingIteration=holder.getContainingBulkIteration();
    final BulkIterationNode containingIterationNode=(BulkIterationNode)this.parent.con2node.get(enclosingIteration);
    BulkPartialSolutionNode p=new BulkPartialSolutionNode(holder,containingIterationNode);
    p.setDegreeOfParallelism(containingIterationNode.getDegreeOfParallelism());
    p.setSubtasksPerInstance(containingIterationNode.getSubtasksPerInstance());
    p.copyEstimates(containingIterationNode);
    n=p;
  }
 else   if (c instanceof WorksetPlaceHolder) {
    final WorksetPlaceHolder holder=(WorksetPlaceHolder)c;
    final WorksetIteration enclosingIteration=holder.getContainingWorksetIteration();
    final WorksetIterationNode containingIterationNode=(WorksetIterationNode)this.parent.con2node.get(enclosingIteration);
    WorksetNode p=new WorksetNode(holder,containingIterationNode);
    p.setDegreeOfParallelism(containingIterationNode.getDegreeOfParallelism());
    p.setSubtasksPerInstance(containingIterationNode.getSubtasksPerInstance());
    p.copyEstimates(containingIterationNode);
    n=p;
  }
 else   if (c instanceof SolutionSetPlaceHolder) {
    final SolutionSetPlaceHolder holder=(SolutionSetPlaceHolder)c;
    final WorksetIteration enclosingIteration=holder.getContainingWorksetIteration();
    final WorksetIterationNode containingIterationNode=(WorksetIterationNode)this.parent.con2node.get(enclosingIteration);
    SolutionSetNode p=new SolutionSetNode(holder,containingIterationNode);
    p.setDegreeOfParallelism(containingIterationNode.getDegreeOfParallelism());
    p.setSubtasksPerInstance(containingIterationNode.getSubtasksPerInstance());
    p.copyEstimates(containingIterationNode);
    n=p;
  }
 else {
    throw new IllegalArgumentException("Unknown contract type.");
  }
  this.con2node.put(c,n);
  this.numMemoryConsumers+=n.isMemoryConsumer() ? 1 : 0;
  if (n.getDegreeOfParallelism() < 1) {
    int par=c.getDegreeOfParallelism();
    if (par > 0) {
      if (this.forceDOP && par != this.defaultParallelism) {
        par=this.defaultParallelism;
        LOG.warn("The degree-of-parallelism of nested Dataflows (such as step functions in iterations) is " + "currently fixed to the degree-of-parallelism of the surrounding operator (the iteration).");
      }
    }
 else {
      par=this.defaultParallelism;
    }
    n.setDegreeOfParallelism(par);
  }
  if (n.getSubtasksPerInstance() < 1) {
    int tasksPerInstance=1;
    if (this.maxMachines > 0) {
      int p=n.getDegreeOfParallelism();
      tasksPerInstance=(p / this.maxMachines) + (p % this.maxMachines == 0 ? 0 : 1);
    }
    n.setSubtasksPerInstance(tasksPerInstance);
  }
  return true;
}
