{
  if (con2node.containsKey(c)) {
    return false;
  }
  OptimizerNode n=null;
  if (c instanceof DataSinkContract<?,?>) {
    DataSinkNode dsn=new DataSinkNode((DataSinkContract<?,?>)c);
    sinks.add(dsn);
    n=dsn;
  }
 else   if (c instanceof DataSourceContract<?,?>) {
    DataSourceNode dsn=new DataSourceNode((DataSourceContract<?,?>)c);
    sources.add(dsn);
    n=dsn;
  }
 else   if (c instanceof MapContract<?,?,?,?>) {
    n=new MapNode((MapContract<?,?,?,?>)c);
  }
 else   if (c instanceof ReduceContract<?,?,?,?>) {
    n=new ReduceNode((ReduceContract<?,?,?,?>)c);
  }
 else   if (c instanceof MatchContract<?,?,?,?,?>) {
    n=new MatchNode((MatchContract<?,?,?,?,?>)c);
  }
 else   if (c instanceof CoGroupContract<?,?,?,?,?>) {
    n=new CoGroupNode((CoGroupContract<?,?,?,?,?>)c);
  }
 else   if (c instanceof CrossContract<?,?,?,?,?,?>) {
    n=new CrossNode((CrossContract<?,?,?,?,?,?>)c);
  }
 else {
    throw new IllegalArgumentException("Unknown contract type.");
  }
  con2node.put(c,n);
  int par=c.getDegreeOfParallelism();
  par=par >= 1 ? par : this.defaultParallelism;
  if (n.getDegreeOfParallelism() < 1) {
    n.setDegreeOfParallelism(par);
  }
  int tasksPerInstance=1;
  if (maxMachines > 0) {
    int p=n.getDegreeOfParallelism();
    int mpi=p / maxMachines;
    mpi+=p % maxMachines == 0 ? 0 : 1;
    tasksPerInstance=Math.max(mpi,this.defaultParallelism);
  }
  n.setInstancesPerMachine(tasksPerInstance);
  return true;
}
