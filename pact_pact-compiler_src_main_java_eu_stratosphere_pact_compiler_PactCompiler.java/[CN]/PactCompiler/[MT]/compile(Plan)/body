{
  if (LOG.isDebugEnabled()) {
    LOG.debug("Beginning compilation of PACT program '" + pactPlan.getJobName() + '\'');
  }
  Configuration config=GlobalConfiguration.getConfiguration();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Connecting compiler to JobManager.");
  }
  List<InstanceTypeDescription> instances=null;
  ExtendedManagementProtocol jobManagerConnection=null;
  try {
    final String address=config.getString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY,null);
    if (address == null) {
      throw new CompilerException("Cannot find address to job manager's RPC service in configuration");
    }
    final int port=GlobalConfiguration.getInteger(ConfigConstants.JOB_MANAGER_IPC_PORT_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_PORT);
    if (port < 0) {
      throw new CompilerException("Cannot find port to job manager's RPC service in configuration");
    }
    final InetSocketAddress inetaddr=new InetSocketAddress(address,port);
    jobManagerConnection=(ExtendedManagementProtocol)RPC.getProxy(ExtendedManagementProtocol.class,inetaddr,NetUtils.getSocketFactory());
    instances=jobManagerConnection.getListOfAvailableInstanceTypes();
    if (instances == null) {
      throw new IOException();
    }
  }
 catch (  IOException ioex) {
    throw new CompilerException("Could not instantiate the connection to the job-manager",ioex);
  }
 finally {
    if (jobManagerConnection != null) {
      try {
        RPC.stopProxy(jobManagerConnection);
      }
 catch (      Throwable t) {
        LOG.error("Could not cleanly shut down connection from compiler to job manager,",t);
      }
    }
    jobManagerConnection=null;
  }
  int maxMachinesJob=pactPlan.getMaxNumberMachines();
  if (maxMachinesJob < 1) {
    maxMachinesJob=this.maxMachines;
  }
 else   if (this.maxMachines >= 1) {
    if (maxMachinesJob > this.maxMachines && LOG.isWarnEnabled()) {
      LOG.warn("Maximal number of machines specified in PACT program (" + maxMachinesJob + ") exceeds the maximum number in the global configuration ("+ this.maxMachines+ "). Using the value given in the global configuration.");
    }
    maxMachinesJob=Math.min(maxMachinesJob,this.maxMachines);
  }
  InstanceTypeDescription type=getType(instances);
  String instanceName=type.getInstanceType().getIdentifier();
  long memoryPerInstance=type.getHardwareDescription().getSizeOfFreeMemory();
  int memoryMegabytes=(int)(memoryPerInstance >>> 20);
  int numInstances=type.getMaximumNumberOfAvailableInstances();
  if (maxMachinesJob < 1 || maxMachinesJob > numInstances) {
    maxMachinesJob=numInstances;
    if (LOG.isInfoEnabled()) {
      LOG.info("Maximal number of machines decreased to " + maxMachinesJob + " because no more instances are available.");
    }
  }
  int defaultParallelism=this.defaultDegreeOfParallelism;
  if (defaultParallelism < 1) {
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
  }
 else   if (defaultParallelism > maxMachinesJob * defaultIntraNodeParallelism) {
    int oldParallelism=defaultParallelism;
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
    if (LOG.isInfoEnabled()) {
      LOG.info("Decreasing default degree of parallelism from " + oldParallelism + " to "+ defaultParallelism+ " to fit a maximum number of "+ maxMachinesJob+ " instances with a intra-parallelism of "+ defaultIntraNodeParallelism);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Using a default degree of parallelism of " + defaultParallelism + ", a default intra-node parallelism of "+ this.defaultIntraNodeParallelism+ '.');
    if (maxMachines > 0) {
      LOG.debug("The execution is limited to a maximum number of " + maxMachines + " machines.");
    }
  }
  GraphCreatingVisitor graphCreator=new GraphCreatingVisitor(this.statistics,maxMachinesJob,defaultParallelism,true);
  pactPlan.accept(graphCreator);
  OptimizedPlan plan=new OptimizedPlan(graphCreator.sources,graphCreator.sinks,graphCreator.con2node.values(),pactPlan.getJobName());
  InterestingPropertyAndBranchesVisitor propsVisitor=new InterestingPropertyAndBranchesVisitor(this.costEstimator);
  plan.accept(propsVisitor);
  if (plan.getDataSinks().size() != 1) {
    throw new CompilerException("In the current version, plans must have exactly one data sink.");
  }
  List<DataSinkNode> bestPlan=plan.getDataSinks().iterator().next().getAlternativePlans(this.costEstimator);
  if (bestPlan.size() != 1) {
    throw new CompilerException("Error in compiler: more than one best plan was created!");
  }
  plan=new PlanFinalizer().createFinalPlan(bestPlan,pactPlan.getJobName(),memoryMegabytes);
  plan.setInstanceTypeName(instanceName);
  insertTempConnection(plan);
  return plan;
}
