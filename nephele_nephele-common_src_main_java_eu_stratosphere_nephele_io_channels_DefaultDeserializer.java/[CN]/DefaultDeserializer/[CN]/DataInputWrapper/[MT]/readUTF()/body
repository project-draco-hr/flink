{
  final int utflen=readUnsignedShort();
  final int utfLimit=this.position + utflen;
  if (utfLimit > this.limit) {
    throw new EOFException();
  }
  final byte[] bytearr=this.source;
  final char[] chararr;
  if (this.utfCharBuffer == null || this.utfCharBuffer.length < utflen) {
    chararr=new char[utflen];
    this.utfCharBuffer=chararr;
  }
 else {
    chararr=this.utfCharBuffer;
  }
  int c, char2, char3;
  int count=this.position;
  int chararr_count=0;
  while (count < utfLimit) {
    c=(int)bytearr[count] & 0xff;
    if (c > 127)     break;
    count++;
    chararr[chararr_count++]=(char)c;
  }
  while (count < utfLimit) {
    c=(int)bytearr[count] & 0xff;
switch (c >> 4) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
      count++;
    chararr[chararr_count++]=(char)c;
  break;
case 12:
case 13:
count+=2;
if (count > utfLimit) throw new UTFDataFormatException("Malformed input: partial character at end");
char2=(int)bytearr[count - 1];
if ((char2 & 0xC0) != 0x80) throw new UTFDataFormatException("Malformed input around byte " + count);
chararr[chararr_count++]=(char)(((c & 0x1F) << 6) | (char2 & 0x3F));
break;
case 14:
count+=3;
if (count > utfLimit) throw new UTFDataFormatException("Malformed input: partial character at end");
char2=(int)bytearr[count - 2];
char3=(int)bytearr[count - 1];
if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) throw new UTFDataFormatException("Malformed input around byte " + (count - 1));
chararr[chararr_count++]=(char)(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
break;
default :
throw new UTFDataFormatException("Malformed input around byte " + count);
}
}
this.position+=utflen;
return new String(chararr,0,chararr_count);
}
