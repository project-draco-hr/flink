{
  if (task == null) {
    throw new IllegalArgumentException();
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Scheduling task " + task);
  }
  final ExecutionVertex vertex=task.getTaskToExecute().getVertex();
synchronized (globalLock) {
    CoLocationConstraint locationConstraint=task.getLocationConstraint();
    if (locationConstraint != null) {
      if (queueIfNoResource) {
        throw new IllegalArgumentException("A task with a location constraint was scheduled in a queued fashion.");
      }
      if (locationConstraint.isUnassigned()) {
        AllocatedSlot newSlot=getFreeSlotForTask(vertex);
        if (newSlot == null) {
          throw new NoResourceAvailableException();
        }
        SharedSlot sl=locationConstraint.swapInNewSlot(newSlot);
        SubSlot slot=sl.allocateSubSlot(vertex.getJobvertexId());
        updateLocalityCounters(newSlot.getLocality());
        return slot;
      }
 else {
        SubSlot slot=locationConstraint.allocateSubSlot(vertex.getJobvertexId());
        if (slot == null) {
          Instance location=locationConstraint.getSlot().getAllocatedSlot().getInstance();
          AllocatedSlot newSlot;
          try {
            newSlot=location.allocateSlot(vertex.getJobId());
          }
 catch (          InstanceDiedException e) {
            throw new NoResourceAvailableException("The instance of the required location died.");
          }
          if (newSlot == null) {
            throw new NoResourceAvailableException();
          }
          SharedSlot sharedSlot=locationConstraint.swapInNewSlot(newSlot);
          slot=sharedSlot.allocateSubSlot(vertex.getJobvertexId());
        }
        updateLocalityCounters(Locality.LOCAL);
        return slot;
      }
    }
    SlotSharingGroup sharingUnit=task.getSlotSharingGroup();
    if (sharingUnit != null) {
      if (queueIfNoResource) {
        throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.");
      }
      final SlotSharingGroupAssignment assignment=sharingUnit.getTaskAssignment();
      AllocatedSlot newSlot=null;
      AllocatedSlot slotFromGroup=assignment.getSlotForTask(vertex.getJobvertexId(),vertex,true);
      try {
        if (slotFromGroup != null) {
          if (slotFromGroup.getLocality() != Locality.NON_LOCAL) {
            updateLocalityCounters(slotFromGroup.getLocality());
            return slotFromGroup;
          }
        }
        newSlot=getFreeSlotForTask(vertex);
        AllocatedSlot toUse;
        if (newSlot == null) {
          if (slotFromGroup == null) {
            throw new NoResourceAvailableException();
          }
 else {
            toUse=slotFromGroup;
          }
        }
 else         if (slotFromGroup == null || newSlot.getLocality() == Locality.LOCAL) {
          toUse=sharingUnit.getTaskAssignment().addSlotWithTask(newSlot,task.getJobVertexId());
        }
 else {
          toUse=slotFromGroup;
        }
        updateLocalityCounters(toUse.getLocality());
        return toUse;
      }
 catch (      Throwable t) {
        if (slotFromGroup != null) {
          slotFromGroup.releaseSlot();
        }
        if (newSlot != null) {
          newSlot.releaseSlot();
        }
      }
    }
    AllocatedSlot slot=getFreeSlotForTask(vertex);
    if (slot != null) {
      updateLocalityCounters(slot.getLocality());
      return slot;
    }
 else {
      if (queueIfNoResource) {
        SlotAllocationFuture future=new SlotAllocationFuture();
        this.taskQueue.add(new QueuedTask(task,future));
        return future;
      }
 else {
        throw new NoResourceAvailableException(task);
      }
    }
  }
}
