{
synchronized (globalLock) {
    Instance instance=this.newlyAvailableInstances.poll();
    if (instance == null || !instance.hasResourcesAvailable()) {
      return;
    }
    QueuedTask queued=taskQueue.peek();
    if (queued != null) {
      ScheduledUnit task=queued.getTask();
      ExecutionVertex vertex=task.getTaskToExecute().getVertex();
      try {
        AllocatedSlot newSlot=instance.allocateSlot(vertex.getJobId());
        if (newSlot != null) {
          taskQueue.poll();
          if (queued.getFuture() != null) {
            try {
              queued.getFuture().setSlot(newSlot);
            }
 catch (            Throwable t) {
              LOG.error("Error calling allocation future for task " + vertex.getSimpleName(),t);
              task.getTaskToExecute().fail(t);
            }
          }
        }
      }
 catch (      InstanceDiedException e) {
        this.allInstances.remove(instance);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Instance " + instance + " was marked dead asynchronously.");
        }
      }
    }
 else {
      this.instancesWithAvailableResources.add(instance);
    }
  }
}
