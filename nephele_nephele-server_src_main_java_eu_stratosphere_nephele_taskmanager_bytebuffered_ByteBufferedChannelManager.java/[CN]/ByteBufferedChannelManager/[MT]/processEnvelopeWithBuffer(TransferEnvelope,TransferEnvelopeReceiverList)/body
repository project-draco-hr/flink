{
  final Buffer buffer=transferEnvelope.getBuffer();
  if (buffer.isReadBuffer()) {
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      final Buffer writeBuffer=this.bufferProvider.requestEmptyWriteBuffer(buffer.size());
      if (writeBuffer == null) {
        return false;
      }
      transferEnvelope.getBuffer().copyToBuffer(writeBuffer);
      final TransferEnvelope remoteEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      remoteEnvelope.setBuffer(writeBuffer);
      TransferEnvelope[] duplicatedEnvelopes=new TransferEnvelope[remoteReceivers.size() - 1];
      for (int i=0; i < duplicatedEnvelopes.length; ++i) {
        duplicatedEnvelopes[i]=remoteEnvelope.duplicate();
      }
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),duplicatedEnvelopes[i - 1]);
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),remoteEnvelope);
    }
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        if (localReceivers.size() > 1) {
          TransferEnvelope[] duplicatedEnvelopes=new TransferEnvelope[localReceivers.size() - 1];
          for (int i=0; i < duplicatedEnvelopes.length; ++i) {
            duplicatedEnvelopes[i]=transferEnvelope.duplicate();
          }
          for (int i=1; i < localReceivers.size(); ++i) {
            channelWrapper=this.registeredChannels.get(localReceivers.get(i));
            if (channelWrapper == null) {
              LOG.error("Cannot find local receiver " + localReceivers.get(i) + " for job "+ transferEnvelope.getJobID());
              continue;
            }
            channelWrapper.queueTransferEnvelope(duplicatedEnvelopes[i - 1]);
          }
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error("Cannot find local receiver " + localReceivers.get(0) + " for job "+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(transferEnvelope);
        }
      }
    }
 else {
      buffer.recycleBuffer();
    }
  }
 else {
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
      final Buffer readBuffer=this.bufferProvider.requestEmptyReadBufferAndWait(buffer.size(),localReceivers.get(0));
      transferEnvelope.getBuffer().copyToBuffer(readBuffer);
      final TransferEnvelope localEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      localEnvelope.setBuffer(readBuffer);
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        for (int i=1; i < localReceivers.size(); ++i) {
          channelWrapper=this.registeredChannels.get(localReceivers.get(i));
          if (channelWrapper == null) {
            LOG.error("Cannot find local receiver " + localReceivers.get(i) + " for job "+ transferEnvelope.getJobID());
            continue;
          }
          channelWrapper.queueTransferEnvelope(localEnvelope.duplicate());
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error("Cannot find local receiver " + localReceivers.get(0) + " for job "+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(localEnvelope);
        }
      }
    }
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),transferEnvelope.duplicate());
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),transferEnvelope);
    }
 else {
      buffer.recycleBuffer();
    }
  }
  return true;
}
