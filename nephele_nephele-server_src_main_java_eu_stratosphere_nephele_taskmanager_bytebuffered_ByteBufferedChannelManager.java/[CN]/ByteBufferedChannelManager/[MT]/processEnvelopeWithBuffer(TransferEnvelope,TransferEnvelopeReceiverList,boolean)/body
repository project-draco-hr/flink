{
  final int val=this.envelopeCounter.incrementAndGet();
  if ((val % LOG_INTERVAL) == 0) {
    final long timestamp=System.currentTimeMillis();
    final int availableBuffers=this.transitBufferPool.getNumberOfAvailableBuffers();
    final int requestedBuffers=this.transitBufferPool.getRequestedNumberOfBuffers();
    final int designatedBuffers=this.transitBufferPool.getDesignatedNumberOfBuffers();
    final StringBuilder sb=new StringBuilder();
    sb.append(timestamp);
    sb.append(' ');
    sb.append(val);
    sb.append(' ');
    sb.append(availableBuffers);
    sb.append(' ');
    sb.append(requestedBuffers);
    sb.append(' ');
    sb.append(designatedBuffers);
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      final int ql=this.networkConnectionManager.getQueueLength(remoteReceiver);
      sb.append(' ');
      sb.append(remoteReceiver.getHostName());
      sb.append(' ');
      sb.append(ql);
    }
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        LOG.error("Cannot find channel context for " + localReceiver);
        continue;
      }
      final InputChannelContext icc=(InputChannelContext)cc;
      final int ql=icc.getNumberOfQueuedEnvelopes();
      sb.append(' ');
      sb.append(ql);
    }
    sb.append('\n');
    this.bufferedWriter.write(sb.toString());
    this.bufferedWriter.flush();
  }
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      throw new IOException("Expected receiver list to have exactly one element");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      throw new IOException("Cannot find channel context for local receiver " + localReceiver);
    }
    if (!cc.isInputChannel()) {
      throw new IOException("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        throw new IOException("Cannot find channel context for local receiver " + localReceiver);
      }
      if (!cc.isInputChannel()) {
        throw new IOException("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      final Buffer destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
      srcBuffer.copyToBuffer(destBuffer);
      final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
      dup.setBuffer(destBuffer);
      inputChannelContext.queueTransferEnvelope(dup);
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope.duplicate());
    }
  }
  srcBuffer.recycleBuffer();
}
