{
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      LOG.error("Expected receiver list to have exactly one element");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      if (!this.recentlyRemovedChannelIDSet.contains(localReceiver)) {
        sendReceiverNotFoundEvent(transferEnvelope.getSource(),localReceiver);
      }
      recycleBuffer(transferEnvelope);
      return;
    }
    if (!cc.isInputChannel()) {
      LOG.error("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        if (!this.recentlyRemovedChannelIDSet.contains(localReceiver)) {
          sendReceiverNotFoundEvent(transferEnvelope.getSource(),localReceiver);
        }
        continue;
      }
      if (!cc.isInputChannel()) {
        LOG.error("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
        continue;
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      Buffer destBuffer=null;
      try {
        destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        srcBuffer.copyToBuffer(destBuffer);
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (destBuffer != null) {
          destBuffer.recycleBuffer();
        }
        continue;
      }
      final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
      dup.setBuffer(destBuffer);
      inputChannelContext.queueTransferEnvelope(dup);
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      TransferEnvelope dup=null;
      try {
        dup=transferEnvelope.duplicate();
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (dup != null) {
          recycleBuffer(dup);
          continue;
        }
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,dup);
    }
  }
  srcBuffer.recycleBuffer();
}
