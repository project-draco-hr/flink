{
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      throw new IOException("Expected receiver list to have exactly one element");
    }
    final ChannelID localReceiver=localReceivers.get(0);
synchronized (this.registeredChannels) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        throw new IOException("Cannot find channel context for local receiver " + localReceiver);
      }
      if (!cc.isInputChannel()) {
        throw new IOException("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
      }
      cc.queueTransferEnvelope(transferEnvelope);
    }
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
      for (      final ChannelID localReceiver : localReceivers) {
        final ChannelContext cc=this.registeredChannels.get(localReceiver);
        if (cc == null) {
          throw new IOException("Cannot find channel context for local receiver " + localReceiver);
        }
        if (!cc.isInputChannel()) {
          throw new IOException("Local receiver " + localReceiver + " is not an input channel, but is supposed to accept a buffer");
        }
        final InputChannelContext inputChannelContext=(InputChannelContext)cc;
        final Buffer destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        srcBuffer.copyToBuffer(destBuffer);
        final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
        dup.setBuffer(destBuffer);
        inputChannelContext.queueTransferEnvelope(dup);
      }
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope.duplicate());
    }
  }
  srcBuffer.recycleBuffer();
}
