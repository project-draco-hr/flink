{
  final TaskContext taskContext=new TaskContext(vertexID,environment,this);
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    final OutputGate<?> outputGate=environment.getOutputGate(i);
    final OutputGateContext outputGateContext=new OutputGateContext(taskContext,outputGate.getIndex());
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<?> outputChannel=outputGate.getOutputChannel(j);
      if (!(outputChannel instanceof AbstractByteBufferedOutputChannel)) {
        LOG.error("Output channel " + outputChannel.getID() + "of job "+ environment.getJobID()+ " is not a byte buffered output channel, skipping...");
        continue;
      }
      final AbstractByteBufferedOutputChannel<?> bboc=(AbstractByteBufferedOutputChannel<?>)outputChannel;
      if (this.registeredChannels.containsKey(bboc.getID())) {
        LOG.error("Byte buffered output channel " + bboc.getID() + " is already registered");
        continue;
      }
      if (bboc.getType() == ChannelType.INMEMORY) {
        addReceiverListHint(bboc);
      }
      final boolean isActive=activeOutputChannels.contains(bboc.getID());
      LOG.info("Registering byte buffered output channel " + bboc.getID() + " ("+ (isActive ? "active" : "inactive")+ ")");
      final OutputChannelContext outputChannelContext=new OutputChannelContext(outputGateContext,bboc,isActive);
      this.registeredChannels.put(bboc.getID(),outputChannelContext);
    }
  }
  for (int i=0; i < environment.getNumberOfInputGates(); ++i) {
    final InputGate<?> inputGate=environment.getInputGate(i);
    final InputGateContext inputGateContext=new InputGateContext(inputGate.getNumberOfInputChannels());
    for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
      final AbstractInputChannel<?> inputChannel=inputGate.getInputChannel(j);
      if (!(inputChannel instanceof AbstractByteBufferedInputChannel)) {
        LOG.error("Input channel " + inputChannel.getID() + "of job "+ environment.getJobID()+ " is not a byte buffered input channel, skipping...");
        continue;
      }
      final AbstractByteBufferedInputChannel<?> bbic=(AbstractByteBufferedInputChannel<?>)inputChannel;
      if (this.registeredChannels.containsKey(bbic.getID())) {
        LOG.error("Byte buffered input channel " + bbic.getID() + " is already registered");
        continue;
      }
      if (bbic.getType() == ChannelType.INMEMORY) {
        addReceiverListHint(bbic);
      }
      LOG.info("Registering byte buffered input channel " + bbic.getID());
      final InputChannelContext inputChannelContext=new InputChannelContext(inputGateContext,this,bbic);
      this.registeredChannels.put(bbic.getID(),inputChannelContext);
    }
    this.localBufferPoolOwner.put(inputGate.getGateID(),inputGateContext);
  }
  this.localBufferPoolOwner.put(vertexID,taskContext);
  redistributeGlobalBuffers();
}
