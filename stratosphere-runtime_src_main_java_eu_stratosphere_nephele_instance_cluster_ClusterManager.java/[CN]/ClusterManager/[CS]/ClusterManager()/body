{
  this.registeredHosts=new HashMap<InstanceConnectionInfo,ClusterInstance>();
  this.slicesOfJobs=new HashMap<JobID,List<AllocatedSlice>>();
  this.defaultInstanceType=InstanceTypeFactory.constructFromDescription(ConfigConstants.DEFAULT_INSTANCE_TYPE);
  this.availableInstanceTypes=new InstanceType[]{this.defaultInstanceType};
  this.instanceAccommodationMatrix=calculateInstanceAccommodationMatrix();
  this.instanceTypeDescriptionMap=new SerializableHashMap<InstanceType,InstanceTypeDescription>();
  long tmpCleanUpInterval=(long)GlobalConfiguration.getInteger(CLEANUP_INTERVAL_KEY,DEFAULT_CLEANUP_INTERVAL) * 1000;
  if (tmpCleanUpInterval < 10) {
    LOG.warn("Invalid clean up interval. Reverting to default cleanup interval of " + DEFAULT_CLEANUP_INTERVAL + " secs.");
    tmpCleanUpInterval=DEFAULT_CLEANUP_INTERVAL;
  }
  this.cleanUpInterval=tmpCleanUpInterval;
  sortAvailableInstancesByNumberOfCPUCores();
  this.networkTopology=NetworkTopology.createEmptyTopology();
  final boolean runTimerAsDaemon=true;
  new Timer(runTimerAsDaemon).schedule(cleanupStaleMachines,1000,1000);
  updateInstaceTypeDescriptionMap();
}
