{
  final List<ManagementGroupVertex> topologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noIncomingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> indegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    indegrees.put(groupVertex,Integer.valueOf(groupVertex.getNumberOfBackwardEdges()));
    if (groupVertex.getNumberOfBackwardEdges() == 0) {
      noIncomingEdges.add(groupVertex);
    }
  }
  while (!noIncomingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noIncomingEdges.removeFirst();
    topologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=groupVertex.getForwardEdge(i).getTarget();
      Integer indegree=indegrees.get(targetVertex);
      indegree=Integer.valueOf(indegree.intValue() - 1);
      indegrees.put(targetVertex,indegree);
      if (indegree.intValue() == 0) {
        noIncomingEdges.add(targetVertex);
      }
    }
  }
  return topologicalSort;
}
