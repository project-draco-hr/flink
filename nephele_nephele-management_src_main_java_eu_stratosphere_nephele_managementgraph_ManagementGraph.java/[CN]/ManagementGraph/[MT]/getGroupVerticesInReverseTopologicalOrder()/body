{
  final List<ManagementGroupVertex> reverseTopologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noOutgoingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> outdegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    outdegrees.put(groupVertex,Integer.valueOf(groupVertex.getNumberOfForwardEdges()));
    if (groupVertex.getNumberOfForwardEdges() == 0) {
      noOutgoingEdges.add(groupVertex);
    }
  }
  while (!noOutgoingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noOutgoingEdges.removeFirst();
    reverseTopologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardEdges(); i++) {
      final ManagementGroupVertex sourceVertex=groupVertex.getBackwardEdge(i).getSource();
      Integer outdegree=outdegrees.get(sourceVertex);
      outdegree=Integer.valueOf(outdegree.intValue() - 1);
      outdegrees.put(sourceVertex,outdegree);
      if (outdegree.intValue() == 0) {
        noOutgoingEdges.add(sourceVertex);
      }
    }
  }
  return reverseTopologicalSort;
}
