{
  Object tmpType;
switch (identifier) {
case SOURCE_CSV:
    setID=(Integer)receiver.getRecord(true);
  path=(String)receiver.getRecord();
fieldDelimiter=(String)receiver.getRecord();
lineDelimiter=(String)receiver.getRecord();
tmpType=(Tuple)receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
return;
case SOURCE_TEXT:
setID=(Integer)receiver.getRecord(true);
path=(String)receiver.getRecord();
return;
case SOURCE_VALUE:
setID=(Integer)receiver.getRecord(true);
int valueCount=(Integer)receiver.getRecord(true);
values=new Object[valueCount];
for (int x=0; x < valueCount; x++) {
values[x]=receiver.getRecord();
}
return;
case SOURCE_SEQ:
setID=(Integer)receiver.getRecord(true);
from=(Long)receiver.getRecord();
to=(Long)receiver.getRecord();
return;
case SINK_CSV:
parentID=(Integer)receiver.getRecord(true);
path=(String)receiver.getRecord();
fieldDelimiter=(String)receiver.getRecord();
lineDelimiter=(String)receiver.getRecord();
writeMode=((Integer)receiver.getRecord(true)) == 1 ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE;
return;
case SINK_TEXT:
parentID=(Integer)receiver.getRecord(true);
path=(String)receiver.getRecord();
writeMode=((Integer)receiver.getRecord(true)) == 1 ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE;
return;
case SINK_PRINT:
parentID=(Integer)receiver.getRecord(true);
toError=(Boolean)receiver.getRecord();
return;
case BROADCAST:
parentID=(Integer)receiver.getRecord(true);
otherID=(Integer)receiver.getRecord(true);
name=(String)receiver.getRecord();
return;
}
setID=(Integer)receiver.getRecord(true);
parentID=(Integer)receiver.getRecord(true);
switch (identifier) {
case AGGREGATE:
count=(Integer)receiver.getRecord(true);
aggregates=new AggregationEntry[count];
for (int x=0; x < count; x++) {
int encodedAgg=(Integer)receiver.getRecord(true);
int field=(Integer)receiver.getRecord(true);
aggregates[x]=new AggregationEntry(encodedAgg,field);
}
return;
case FIRST:
count=(Integer)receiver.getRecord(true);
return;
case DISTINCT:
case GROUPBY:
case PARTITION_HASH:
keys=normalizeKeys(receiver.getRecord(true));
return;
case PROJECTION:
fields=toIntArray(receiver.getRecord(true));
return;
case REBALANCE:
return;
case SORT:
field=(Integer)receiver.getRecord(true);
int encodedOrder=(Integer)receiver.getRecord(true);
switch (encodedOrder) {
case 0:
order=Order.NONE;
break;
case 1:
order=Order.ASCENDING;
break;
case 2:
order=Order.DESCENDING;
break;
case 3:
order=Order.ANY;
break;
default :
order=Order.NONE;
break;
}
return;
case UNION:
otherID=(Integer)receiver.getRecord(true);
return;
case COGROUP:
otherID=(Integer)receiver.getRecord(true);
keys1=normalizeKeys(receiver.getRecord(true));
keys2=normalizeKeys(receiver.getRecord(true));
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)receiver.getRecord();
return;
case CROSS:
case CROSS_H:
case CROSS_T:
otherID=(Integer)receiver.getRecord(true);
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
int cProjectCount=(Integer)receiver.getRecord(true);
projections=new ProjectionEntry[cProjectCount];
for (int x=0; x < cProjectCount; x++) {
String side=(String)receiver.getRecord();
int[] keys=toIntArray((Tuple)receiver.getRecord(true));
projections[x]=new ProjectionEntry(ProjectionSide.valueOf(side.toUpperCase()),keys);
}
name=(String)receiver.getRecord();
return;
case REDUCE:
case GROUPREDUCE:
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
combine=(Boolean)receiver.getRecord();
name=(String)receiver.getRecord();
return;
case JOIN:
case JOIN_H:
case JOIN_T:
keys1=normalizeKeys(receiver.getRecord(true));
keys2=normalizeKeys(receiver.getRecord(true));
otherID=(Integer)receiver.getRecord(true);
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
int jProjectCount=(Integer)receiver.getRecord(true);
projections=new ProjectionEntry[jProjectCount];
for (int x=0; x < jProjectCount; x++) {
String side=(String)receiver.getRecord();
int[] keys=toIntArray((Tuple)receiver.getRecord(true));
projections[x]=new ProjectionEntry(ProjectionSide.valueOf(side.toUpperCase()),keys);
}
name=(String)receiver.getRecord();
return;
case MAPPARTITION:
case FLATMAP:
case MAP:
case FILTER:
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)receiver.getRecord();
return;
default :
throw new UnsupportedOperationException("This operation is not implemented in the Python API: " + identifier);
}
}
