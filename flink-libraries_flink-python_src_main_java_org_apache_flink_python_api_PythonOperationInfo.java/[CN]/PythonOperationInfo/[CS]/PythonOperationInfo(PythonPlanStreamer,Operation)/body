{
  Object tmpType;
switch (identifier) {
case SOURCE_CSV:
    setID=(Integer)streamer.getRecord(true);
  path=(String)streamer.getRecord();
fieldDelimiter=(String)streamer.getRecord();
lineDelimiter=(String)streamer.getRecord();
tmpType=(Tuple)streamer.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
return;
case SOURCE_TEXT:
setID=(Integer)streamer.getRecord(true);
path=(String)streamer.getRecord();
return;
case SOURCE_VALUE:
setID=(Integer)streamer.getRecord(true);
int valueCount=(Integer)streamer.getRecord(true);
values=new Object[valueCount];
for (int x=0; x < valueCount; x++) {
values[x]=streamer.getRecord();
}
return;
case SOURCE_SEQ:
setID=(Integer)streamer.getRecord(true);
from=(Long)streamer.getRecord();
to=(Long)streamer.getRecord();
return;
case SINK_CSV:
parentID=(Integer)streamer.getRecord(true);
path=(String)streamer.getRecord();
fieldDelimiter=(String)streamer.getRecord();
lineDelimiter=(String)streamer.getRecord();
writeMode=((Integer)streamer.getRecord(true)) == 1 ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE;
return;
case SINK_TEXT:
parentID=(Integer)streamer.getRecord(true);
path=(String)streamer.getRecord();
writeMode=((Integer)streamer.getRecord(true)) == 1 ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE;
return;
case SINK_PRINT:
parentID=(Integer)streamer.getRecord(true);
toError=(Boolean)streamer.getRecord();
return;
case BROADCAST:
parentID=(Integer)streamer.getRecord(true);
otherID=(Integer)streamer.getRecord(true);
name=(String)streamer.getRecord();
return;
}
setID=(Integer)streamer.getRecord(true);
parentID=(Integer)streamer.getRecord(true);
switch (identifier) {
case AGGREGATE:
count=(Integer)streamer.getRecord(true);
aggregates=new AggregationEntry[count];
for (int x=0; x < count; x++) {
int encodedAgg=(Integer)streamer.getRecord(true);
int field=(Integer)streamer.getRecord(true);
aggregates[x]=new AggregationEntry(encodedAgg,field);
}
return;
case FIRST:
count=(Integer)streamer.getRecord(true);
return;
case DISTINCT:
case GROUPBY:
case PARTITION_HASH:
keys=normalizeKeys(streamer.getRecord(true));
return;
case PROJECTION:
fields=toIntArray(streamer.getRecord(true));
return;
case REBALANCE:
return;
case SORT:
field="f0.f" + (Integer)streamer.getRecord(true);
int encodedOrder=(Integer)streamer.getRecord(true);
switch (encodedOrder) {
case 0:
order=Order.NONE;
break;
case 1:
order=Order.ASCENDING;
break;
case 2:
order=Order.DESCENDING;
break;
case 3:
order=Order.ANY;
break;
default :
order=Order.NONE;
break;
}
return;
case UNION:
otherID=(Integer)streamer.getRecord(true);
return;
case COGROUP:
otherID=(Integer)streamer.getRecord(true);
keys1=normalizeKeys(streamer.getRecord(true));
keys2=normalizeKeys(streamer.getRecord(true));
tmpType=streamer.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)streamer.getRecord();
return;
case CROSS:
case CROSS_H:
case CROSS_T:
otherID=(Integer)streamer.getRecord(true);
usesUDF=(Boolean)streamer.getRecord();
tmpType=streamer.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)streamer.getRecord();
return;
case REDUCE:
case GROUPREDUCE:
tmpType=streamer.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)streamer.getRecord();
return;
case JOIN:
case JOIN_H:
case JOIN_T:
keys1=normalizeKeys(streamer.getRecord(true));
keys2=normalizeKeys(streamer.getRecord(true));
otherID=(Integer)streamer.getRecord(true);
usesUDF=(Boolean)streamer.getRecord();
tmpType=streamer.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)streamer.getRecord();
return;
case MAPPARTITION:
case FLATMAP:
case MAP:
case FILTER:
tmpType=streamer.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)streamer.getRecord();
return;
default :
throw new UnsupportedOperationException("This operation is not implemented in the Python API: " + identifier);
}
}
