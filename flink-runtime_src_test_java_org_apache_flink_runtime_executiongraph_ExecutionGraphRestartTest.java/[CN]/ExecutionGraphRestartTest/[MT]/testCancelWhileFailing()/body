{
  Scheduler scheduler=new Scheduler(TestingUtils.defaultExecutionContext());
  Instance instance=ExecutionGraphTestUtils.getInstance(new SimpleActorGateway(TestingUtils.directExecutionContext()),NUM_TASKS);
  scheduler.newInstanceAvailable(instance);
  ExecutionGraph executionGraph=new ExecutionGraph(TestingUtils.defaultExecutionContext(),new JobID(),"TestJob",new Configuration(),AkkaUtils.getDefaultTimeout(),new FixedDelayRestartStrategy(Integer.MAX_VALUE,Long.MAX_VALUE));
  executionGraph=spy(executionGraph);
  doNothing().when(executionGraph).jobVertexInFinalState();
  JobVertex jobVertex=new JobVertex("NoOpInvokable");
  jobVertex.setInvokableClass(Tasks.NoOpInvokable.class);
  jobVertex.setParallelism(NUM_TASKS);
  JobGraph jobGraph=new JobGraph("TestJob",jobVertex);
  executionGraph.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources());
  assertEquals(JobStatus.CREATED,executionGraph.getState());
  executionGraph.scheduleForExecution(scheduler);
  assertEquals(JobStatus.RUNNING,executionGraph.getState());
  instance.markDead();
  Deadline deadline=TestingUtils.TESTING_DURATION().fromNow();
  boolean success=false;
  while (deadline.hasTimeLeft() && !success) {
    success=true;
    for (    ExecutionVertex vertex : executionGraph.getAllExecutionVertices()) {
      ExecutionState state=vertex.getExecutionState();
      if (state != ExecutionState.FAILED && state != ExecutionState.CANCELED) {
        success=false;
        Thread.sleep(100);
        break;
      }
    }
  }
  assertEquals(JobStatus.FAILING,executionGraph.getState());
  executionGraph.cancel();
  assertEquals(JobStatus.CANCELLING,executionGraph.getState());
  doCallRealMethod().when(executionGraph).jobVertexInFinalState();
  executionGraph.jobVertexInFinalState();
  assertEquals(JobStatus.CANCELED,executionGraph.getState());
}
