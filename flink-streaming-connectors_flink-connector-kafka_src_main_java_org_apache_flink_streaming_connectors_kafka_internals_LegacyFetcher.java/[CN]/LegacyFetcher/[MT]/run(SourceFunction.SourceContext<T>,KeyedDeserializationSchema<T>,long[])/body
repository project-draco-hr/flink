{
  if (partitionsToRead == null || partitionsToRead.size() == 0) {
    throw new IllegalArgumentException("No partitions set");
  }
  this.mainThread=Thread.currentThread();
  LOG.info("Reading from partitions " + partitionsToRead + " using the legacy fetcher");
  PartitionInfoFetcher infoFetcher=new PartitionInfoFetcher(topic,config);
  infoFetcher.start();
  KillerWatchDog watchDog=new KillerWatchDog(infoFetcher,60000);
  watchDog.start();
  final List<PartitionInfo> allPartitionsInTopic=infoFetcher.getPartitions();
  int fetchPartitionsCount=0;
  Map<Node,List<FetchPartition>> fetchBrokers=new HashMap<>();
  for (  PartitionInfo partitionInfo : allPartitionsInTopic) {
    if (partitionInfo.leader() == null) {
      throw new RuntimeException("Unable to consume partition " + partitionInfo.partition() + " from topic "+ partitionInfo.topic()+ " because it does not have a leader");
    }
    for (    Map.Entry<TopicPartition,Long> entry : partitionsToRead.entrySet()) {
      final TopicPartition topicPartition=entry.getKey();
      final long offset=entry.getValue();
      if (topicPartition.partition() == partitionInfo.partition()) {
        List<FetchPartition> partitions=fetchBrokers.get(partitionInfo.leader());
        if (partitions == null) {
          partitions=new ArrayList<>();
          fetchBrokers.put(partitionInfo.leader(),partitions);
        }
        partitions.add(new FetchPartition(topicPartition.partition(),offset));
        fetchPartitionsCount++;
      }
    }
  }
  if (partitionsToRead.size() != fetchPartitionsCount) {
    throw new RuntimeException(partitionsToRead.size() + " partitions to read, but got only " + fetchPartitionsCount+ " partition infos with lead brokers.");
  }
  ArrayList<SimpleConsumerThread<?>> consumers=new ArrayList<>(fetchBrokers.size());
  for (  Map.Entry<Node,List<FetchPartition>> brokerInfo : fetchBrokers.entrySet()) {
    final Node broker=brokerInfo.getKey();
    final List<FetchPartition> partitionsList=brokerInfo.getValue();
    FetchPartition[] partitions=partitionsList.toArray(new FetchPartition[partitionsList.size()]);
    SimpleConsumerThread<T> thread=new SimpleConsumerThread<>(this,config,topic,broker,partitions,sourceContext,deserializer,lastOffsets);
    thread.setName(String.format("SimpleConsumer - %s - broker-%s (%s:%d)",taskName,broker.id(),broker.host(),broker.port()));
    thread.setDaemon(true);
    consumers.add(thread);
  }
  if (!running) {
    return;
  }
  for (  SimpleConsumerThread<?> t : consumers) {
    LOG.info("Starting thread {}",t.getName());
    t.start();
  }
  try {
    boolean someConsumersRunning=true;
    while (running && error.get() == null && someConsumersRunning) {
      try {
        for (        SimpleConsumerThread<?> t : consumers) {
          t.join();
        }
        someConsumersRunning=false;
        for (        SimpleConsumerThread<?> t : consumers) {
          someConsumersRunning|=t.isAlive();
        }
      }
 catch (      InterruptedException e) {
      }
    }
    Throwable error=this.error.get();
    if (error != null) {
      throw new Exception(error.getMessage(),error);
    }
  }
  finally {
    for (    SimpleConsumerThread<?> t : consumers) {
      if (t.isAlive()) {
        t.cancel();
      }
    }
  }
}
