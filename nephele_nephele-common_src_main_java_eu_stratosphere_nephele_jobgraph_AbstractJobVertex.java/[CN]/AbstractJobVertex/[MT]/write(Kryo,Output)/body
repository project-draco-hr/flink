{
  output.writeString(this.instanceType);
  output.writeInt(this.numberOfSubtasks);
  output.writeInt(this.numberOfSubtasksPerInstance);
  output.writeInt(this.numberOfExecutionRetries);
  if (this.vertexToShareInstancesWith != null) {
    output.writeBoolean(true);
    kryo.writeObject(output,this.vertexToShareInstancesWith.getID());
  }
 else {
    output.writeBoolean(false);
  }
  this.configuration.write(kryo,output);
  output.writeInt(this.forwardEdges.size());
  for (int i=0; i < this.forwardEdges.size(); i++) {
    final JobEdge edge=this.forwardEdges.get(i);
    if (edge == null) {
      output.writeBoolean(false);
    }
 else {
      output.writeBoolean(true);
      kryo.writeObject(output,edge.getConnectedVertex().getID());
      EnumUtils.writeEnum(output,edge.getChannelType());
      EnumUtils.writeEnum(output,edge.getCompressionLevel());
      EnumUtils.writeEnum(output,edge.getDistributionPattern());
      output.writeInt(edge.getIndexOfInputGate());
      output.writeBoolean(edge.spanningRecordsAllowed());
    }
  }
  output.writeString(this.invokableClassName);
}
