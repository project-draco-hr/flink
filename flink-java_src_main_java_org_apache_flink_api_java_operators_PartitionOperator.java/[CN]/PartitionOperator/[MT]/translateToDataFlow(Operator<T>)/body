{
  String name="Partition at " + partitionLocationName;
  if (pMethod == PartitionMethod.REBALANCE) {
    UnaryOperatorInformation<T,T> operatorInfo=new UnaryOperatorInformation<T,T>(getType(),getType());
    PartitionOperatorBase<T> noop=new PartitionOperatorBase<T>(operatorInfo,pMethod,name);
    noop.setInput(input);
    noop.setDegreeOfParallelism(getParallelism());
    return noop;
  }
 else   if (pMethod == PartitionMethod.HASH || pMethod == PartitionMethod.CUSTOM) {
    if (pKeys instanceof Keys.ExpressionKeys) {
      int[] logicalKeyPositions=pKeys.computeLogicalKeyPositions();
      UnaryOperatorInformation<T,T> operatorInfo=new UnaryOperatorInformation<T,T>(getType(),getType());
      PartitionOperatorBase<T> noop=new PartitionOperatorBase<T>(operatorInfo,pMethod,logicalKeyPositions,name);
      noop.setInput(input);
      noop.setDegreeOfParallelism(getParallelism());
      noop.setCustomPartitioner(customPartitioner);
      return noop;
    }
 else     if (pKeys instanceof Keys.SelectorFunctionKeys) {
      @SuppressWarnings("unchecked") Keys.SelectorFunctionKeys<T,?> selectorKeys=(Keys.SelectorFunctionKeys<T,?>)pKeys;
      MapOperatorBase<?,T,?> po=translateSelectorFunctionPartitioner(selectorKeys,pMethod,getType(),name,input,getParallelism(),customPartitioner);
      return po;
    }
 else {
      throw new UnsupportedOperationException("Unrecognized key type.");
    }
  }
 else   if (pMethod == PartitionMethod.RANGE) {
    throw new UnsupportedOperationException("Range partitioning not yet supported");
  }
 else {
    throw new UnsupportedOperationException("Unsupported partitioning method: " + pMethod.name());
  }
}
