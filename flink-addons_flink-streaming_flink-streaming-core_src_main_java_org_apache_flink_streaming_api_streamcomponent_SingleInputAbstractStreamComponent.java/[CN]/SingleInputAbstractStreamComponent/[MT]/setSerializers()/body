{
  String operatorName=configuration.getFunctionName();
  Object function=configuration.getFunction();
  try {
    if (operatorName.equals("flatMap")) {
      setSerializerDeserializer(function,FlatMapFunction.class);
    }
 else     if (operatorName.equals("map")) {
      setSerializerDeserializer(function,MapFunction.class);
    }
 else     if (operatorName.equals("batchReduce")) {
      setSerializerDeserializer(function,GroupReduceFunction.class);
    }
 else     if (operatorName.equals("filter")) {
      setDeserializer(function,FilterFunction.class);
      setSerializer(function,FilterFunction.class,0);
    }
 else     if (operatorName.equals("sink")) {
      setDeserializer(function,SinkFunction.class);
    }
 else     if (operatorName.equals("source")) {
      setSerializer(function,UserSourceInvokable.class,0);
    }
 else     if (operatorName.equals("coMap")) {
      setSerializer(function,CoMapFunction.class,2);
    }
 else     if (operatorName.equals("elements")) {
      outTupleTypeInfo=new TupleTypeInfo<OUT>(TypeExtractor.getForObject(function));
      outTupleSerializer=new StreamRecordSerializer<OUT>(outTupleTypeInfo.createSerializer());
      outSerializationDelegate=new SerializationDelegate<StreamRecord<OUT>>(outTupleSerializer);
    }
 else {
      throw new Exception("Wrong operator name: " + operatorName);
    }
  }
 catch (  Exception e) {
    throw new StreamComponentException(e);
  }
}
