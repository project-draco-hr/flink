{
  if (this.currentIterator != null && this.currentIterator.next(target)) {
    return true;
  }
 else   if (this.closed) {
    throw new IllegalStateException("The sorter has been closed.");
  }
 else {
    if (AsynchronousPartialSorter.this.iteratorException != null) {
      throw new IOException("The sorter has ancountered an error.",AsynchronousPartialSorter.this.iteratorException);
    }
    while (true) {
      if (this.currentElement == endMarker()) {
        return false;
      }
 else       if (this.currentElement != null) {
        this.currentElement.buffer.reset();
        this.queues.empty.add(this.currentElement);
      }
      try {
        this.currentElement=null;
        while (!this.closed && this.currentElement == null) {
          this.currentElement=this.queues.spill.poll(1000,TimeUnit.MILLISECONDS);
        }
        if (AsynchronousPartialSorter.this.iteratorException != null) {
          throw new IOException("The sorter has ancountered an error.",AsynchronousPartialSorter.this.iteratorException);
        }
        if (this.currentElement == endMarker()) {
          releaseSortBuffers();
          return false;
        }
        if (this.currentElement == spillingMarker()) {
          this.currentElement=null;
          continue;
        }
      }
 catch (      InterruptedException e) {
        throw new RuntimeException("Iterator was interrupted getting the next sortedBuffer.");
      }
      this.currentIterator=this.currentElement.buffer.getIterator();
      if (this.currentIterator.next(target)) {
        return true;
      }
      this.currentIterator=null;
    }
  }
}
