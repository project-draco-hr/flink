{
  LinkedList<TriggerPolicy<Integer>> triggers=new LinkedList<TriggerPolicy<Integer>>();
  triggers.add(new CountTriggerPolicy<Integer>(8));
  triggers.add(new CountTriggerPolicy<Integer>(5));
  LinkedList<CloneableEvictionPolicy<Integer>> evictions=new LinkedList<CloneableEvictionPolicy<Integer>>();
  evictions.add(new ActiveCloneableEvictionPolicyWrapper<Integer>(new TumblingEvictionPolicy<Integer>()));
  LinkedList<CloneableTriggerPolicy<Integer>> distributedTriggers=new LinkedList<CloneableTriggerPolicy<Integer>>();
  List<Integer> inputs=new ArrayList<Integer>();
  inputs.add(1);
  inputs.add(2);
  inputs.add(2);
  inputs.add(2);
  inputs.add(1);
  inputs.add(2);
  inputs.add(1);
  inputs.add(2);
  inputs.add(2);
  inputs.add(1);
  List<Integer> expected=new ArrayList<Integer>();
  expected.add(2);
  expected.add(6);
  expected.add(4);
  expected.add(1);
  expected.add(2);
  expected.add(1);
  ReduceFunction<Integer> myReduceFunction=new ReduceFunction<Integer>(){
    private static final long serialVersionUID=1L;
    @Override public Integer reduce(    Integer value1,    Integer value2) throws Exception {
      return value1 + value2;
    }
  }
;
  GroupedWindowingInvokable<Integer> invokable=new GroupedWindowingInvokable<Integer>(myReduceFunction,new KeySelector<Integer,Integer>(){
    private static final long serialVersionUID=1L;
    @Override public Integer getKey(    Integer value){
      return value;
    }
  }
,distributedTriggers,evictions,triggers);
  ArrayList<Integer> result=new ArrayList<Integer>();
  for (  Tuple2<Integer,String[]> t : MockInvokable.createAndExecute(invokable,inputs)) {
    result.add(t.f0);
  }
  assertEquals(new HashSet<Integer>(expected),new HashSet<Integer>(result));
  assertEquals(expected.size(),result.size());
}
