{
  boolean checkpointDesicion=false;
  LOG.info("Checkpoint decision for vertex " + vertex + " required");
  if (rus.getUserCPU() >= 90) {
    LOG.info("CPU-Bottleneck");
    checkpointDesicion=true;
  }
 else {
    if (vertex.getNumberOfSuccessors() != 0 && vertex.getNumberOfPredecessors() * 1.0 / vertex.getNumberOfSuccessors() > 1.5) {
      LOG.info("vertex.getNumberOfPredecessors()/ vertex.getNumberOfSuccessors() > 1.5");
      checkpointDesicion=true;
    }
 else     if (true) {
      checkpointDesicion=true;
    }
  }
  final ExecutionGraph graph=vertex.getExecutionGraph();
  final Map<AbstractInstance,List<CheckpointDecision>> checkpointDecisions=new HashMap<AbstractInstance,List<CheckpointDecision>>();
  final List<CheckpointDecision> checkpointDecisionList=new SerializableArrayList<CheckpointDecision>();
synchronized (graph) {
    checkpointDecisionList.add(new CheckpointDecision(vertex.getID(),checkpointDesicion));
    checkpointDecisions.put(vertex.getAllocatedResource().getInstance(),checkpointDecisionList);
  }
  this.decisionPropagator.propagateCheckpointDecisions(checkpointDecisions);
}
