{
  boolean checkpointDesicion=false;
  LOG.info("Checkpoint decision for vertex " + vertex + " required");
  Environment ee=vertex.getEnvironment();
  double in=0;
  for (int i=0; i < ee.getNumberOfInputGates(); i++) {
    in+=ee.getInputGate(i).getNumberOfInputChannels();
  }
  double out=0;
  for (int i=0; i < ee.getNumberOfOutputGates(); i++) {
    out+=ee.getOutputGate(i).getNumberOfOutputChannels();
  }
  if (out != 0 && in / out > 1.5) {
    LOG.info("vertex.getNumberOfPredecessors()/vertex.getNumberOfSuccessors() > 1.5");
    checkpointDesicion=true;
  }
 else   if (true) {
    checkpointDesicion=true;
  }
  final ExecutionGraph graph=vertex.getExecutionGraph();
  final Map<AbstractInstance,List<CheckpointDecision>> checkpointDecisions=new HashMap<AbstractInstance,List<CheckpointDecision>>();
  final List<CheckpointDecision> checkpointDecisionList=new SerializableArrayList<CheckpointDecision>();
synchronized (graph) {
    checkpointDecisionList.add(new CheckpointDecision(vertex.getID(),checkpointDesicion));
    checkpointDecisions.put(vertex.getAllocatedResource().getInstance(),checkpointDecisionList);
  }
  this.decisionPropagator.propagateCheckpointDecisions(checkpointDecisions);
}
