{
  LOG.info("Checkpoint decision for vertex " + vertex + " required");
synchronized (decidedVertices) {
    if (!decidedVertices.contains(vertex.getID())) {
      boolean checkpointDecision=getDecision(vertex,rus);
      final ExecutionGraph graph=vertex.getExecutionGraph();
      final Map<AbstractInstance,List<CheckpointDecision>> checkpointDecisions=new HashMap<AbstractInstance,List<CheckpointDecision>>();
      List<CheckpointDecision> checkpointDecisionList=null;
synchronized (graph) {
        ExecutionGroupVertex groupVertex=vertex.getGroupVertex();
        for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
          ExecutionVertex member=groupVertex.getGroupMember(i);
          AbstractInstance instance=member.getAllocatedResource().getInstance();
          if (checkpointDecisions.containsKey(instance)) {
            checkpointDecisionList=checkpointDecisions.get(instance);
          }
 else {
            checkpointDecisionList=new SerializableArrayList<CheckpointDecision>();
          }
          checkpointDecisionList.add(new CheckpointDecision(member.getID(),checkpointDecision));
          checkpointDecisions.put(instance,checkpointDecisionList);
          this.decidedVertices.add(member.getID());
        }
      }
      this.decisionPropagator.propagateCheckpointDecisions(checkpointDecisions);
    }
  }
}
