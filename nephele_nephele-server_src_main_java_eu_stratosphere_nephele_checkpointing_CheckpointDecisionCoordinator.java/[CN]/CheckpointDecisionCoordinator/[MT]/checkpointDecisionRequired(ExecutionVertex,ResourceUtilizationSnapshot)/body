{
  boolean checkpointDecision=false;
  LOG.info("Checkpoint decision for vertex " + vertex + " required");
  if (rus.getForced() == null) {
    if (rus.getUserCPU() >= 90) {
      LOG.info("CPU-Bottleneck");
      checkpointDecision=true;
    }
 else {
      if (vertex.getNumberOfSuccessors() != 0 && vertex.getNumberOfPredecessors() * 1.0 / vertex.getNumberOfSuccessors() > 1.5) {
        LOG.info("vertex.getNumberOfPredecessors()/ vertex.getNumberOfSuccessors() > 1.5");
        checkpointDecision=true;
      }
 else       if (true) {
        checkpointDecision=true;
      }
    }
  }
 else {
    checkpointDecision=rus.getForced();
  }
  final ExecutionGraph graph=vertex.getExecutionGraph();
  final Map<AbstractInstance,List<CheckpointDecision>> checkpointDecisions=new HashMap<AbstractInstance,List<CheckpointDecision>>();
  final List<CheckpointDecision> checkpointDecisionList=new SerializableArrayList<CheckpointDecision>();
synchronized (graph) {
    checkpointDecisionList.add(new CheckpointDecision(vertex.getID(),checkpointDecision));
    checkpointDecisions.put(vertex.getAllocatedResource().getInstance(),checkpointDecisionList);
  }
  this.decisionPropagator.propagateCheckpointDecisions(checkpointDecisions);
}
