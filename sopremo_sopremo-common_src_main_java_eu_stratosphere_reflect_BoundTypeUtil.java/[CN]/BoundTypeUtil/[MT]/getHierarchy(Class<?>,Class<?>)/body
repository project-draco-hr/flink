{
  if (!superClass.isAssignableFrom(subclass))   throw new IllegalArgumentException();
  List<Type> hierarchy=new ArrayList<Type>();
  if (superClass == subclass)   return hierarchy;
  if (superClass.isInterface()) {
    Type[] interfaces=subclass.getGenericInterfaces();
    int minDistance=Integer.MAX_VALUE;
    for (    Type xface : interfaces) {
      Class<?> type=(Class<?>)(xface instanceof Class ? xface : ((ParameterizedType)xface).getRawType());
      if (type == superClass) {
        hierarchy.clear();
        hierarchy.add(xface);
        break;
      }
      if (superClass.isAssignableFrom(type)) {
        List<Type> partialHierarchy=getHierarchy(superClass,type);
        if (partialHierarchy.size() + 1 < minDistance) {
          hierarchy=partialHierarchy;
          hierarchy.add(0,xface);
          minDistance=hierarchy.size();
        }
      }
    }
    if (hierarchy.isEmpty()) {
      hierarchy.add(subclass.getGenericSuperclass());
      hierarchy.addAll(getHierarchy(superClass,subclass.getSuperclass()));
    }
    return hierarchy;
  }
  Type clazz=subclass;
  do {
    hierarchy.add(clazz);
    Class<?> type=(Class<?>)(clazz instanceof Class ? clazz : ((ParameterizedType)clazz).getRawType());
    clazz=type.getGenericSuperclass();
  }
 while (superClass != clazz);
  return hierarchy;
}
