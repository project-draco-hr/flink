{
  final KeyValuePair<K,V> actualPair=inputFileIterator.next();
  final TaskConfig config=new TaskConfig(GlobalConfiguration.getConfiguration());
  this.assignMemory(config,10);
  final int NUM_SORT_BUFFERS=config.getNumSortBuffer();
  final int SIZE_SORT_BUFFER=config.getSortBufferSize() * 1024 * 1024;
  final int MEMORY_IO=config.getIOBufferSize() * 1024 * 1024;
  final int MAX_NUM_FILEHANLDES=config.getMergeFactor();
  final Comparator<K> keyComparator=new Comparator<K>(){
    @Override public int compare(    final K k1,    final K k2){
      return k1.compareTo(k2);
    }
  }
;
  try {
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>((Class<K>)actualPair.getKey().getClass());
    final SerializationFactory<V> valSerialization=new WritableSerializationFactory<V>((Class<V>)actualPair.getValue().getClass());
    @SuppressWarnings("rawtypes") final UnilateralSortMerger<K,V> sortMerger=new UnilateralSortMerger<K,V>(MockTaskManager.INSTANCE.getMemoryManager(),MockTaskManager.INSTANCE.getIoManager(),NUM_SORT_BUFFERS,SIZE_SORT_BUFFER,MEMORY_IO,MAX_NUM_FILEHANLDES,keySerialization,valSerialization,keyComparator,new TestPairsReader(inputFileIterator,actualPair),new ReduceTask());
    this.closableManager.add(sortMerger);
    return sortMerger.getIterator();
  }
 catch (  final MemoryAllocationException mae) {
    throw new RuntimeException("MemoryManager is not able to provide the required amount of memory for ReduceTask",mae);
  }
catch (  final IOException ioe) {
    throw new RuntimeException("IOException caught when obtaining SortMerger for ReduceTask",ioe);
  }
}
