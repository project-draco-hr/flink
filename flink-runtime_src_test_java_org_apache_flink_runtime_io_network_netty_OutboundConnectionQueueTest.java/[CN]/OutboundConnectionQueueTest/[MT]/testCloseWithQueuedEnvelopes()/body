{
  initTest(true);
  final JobID jid=new JobID();
  final ChannelID cid=new ChannelID();
  final CountDownLatch sync=verifier.waitForEnvelopes(3,cid);
  Mockito.when(channel.isWritable()).thenReturn(false);
  Assert.assertTrue(queue.enqueue(new Envelope(1,jid,cid)));
  Assert.assertTrue(queue.enqueue(new Envelope(2,jid,cid)));
  Assert.assertTrue(queue.enqueue(new Envelope(3,jid,cid)));
  controller.fireIdle();
  Mockito.verify(connectionManager,Mockito.times(0)).close(Mockito.any(RemoteReceiver.class));
  Boolean hasRequestedClose=Whitebox.<Boolean>getInternalState(queue,"hasRequestedClose");
  Assert.assertFalse("Close request while envelope in flight.",hasRequestedClose);
  Mockito.when(channel.isWritable()).thenReturn(true);
  channel.pipeline().fireChannelWritabilityChanged();
  while (sync.getCount() != 0) {
    sync.await();
  }
  verifier.verifyEnvelopeReceived(cid,3);
  controller.fireIdle();
  verifier.waitForClose();
  Mockito.verify(connectionManager,Mockito.times(1)).close(Mockito.any(RemoteReceiver.class));
}
