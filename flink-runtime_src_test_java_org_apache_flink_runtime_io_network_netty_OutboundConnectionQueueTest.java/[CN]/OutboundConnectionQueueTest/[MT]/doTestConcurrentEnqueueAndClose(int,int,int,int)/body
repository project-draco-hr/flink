{
  final InetAddress bindHost=InetAddress.getLocalHost();
  final int bindPort=20000;
  final ServerBootstrap in=new ServerBootstrap();
  in.group(new NioEventLoopGroup(1)).channel(NioServerSocketChannel.class).localAddress(bindHost,bindPort).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel channel) throws Exception {
      channel.pipeline().addLast(new ChannelInboundHandlerAdapter());
    }
  }
);
  final Bootstrap out=new Bootstrap();
  out.group(new NioEventLoopGroup(1)).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel channel) throws Exception {
      channel.pipeline().addLast(new ChannelOutboundHandlerAdapter());
    }
  }
).option(ChannelOption.TCP_NODELAY,false).option(ChannelOption.SO_KEEPALIVE,true);
  in.bind().sync();
  channel=out.connect(bindHost,bindPort).sync().channel();
  queue=new OutboundConnectionQueue(channel,receiver,connectionManager,0);
  controller=new TestControlHandler(true);
  verifier=new TestVerificationHandler();
  channel.pipeline().addFirst("Test Control Handler",controller);
  channel.pipeline().addFirst("Test Verification Handler",verifier);
  final Random rand=new Random(RANDOM_SEED);
  final ConcurrentMap<ChannelID,OutboundConnectionQueue> producerQueues=new ConcurrentHashMap<ChannelID,OutboundConnectionQueue>();
  final ChannelID[] ids=new ChannelID[numProducers];
  for (int i=0; i < numProducers; i++) {
    ids[i]=new ChannelID();
    producerQueues.put(ids[i],queue);
  }
  final CountDownLatch receivedAllEnvelopesLatch=verifier.waitForEnvelopes(numEnvelopesPerProducer - 1,ids);
  final List<Channel> closedChannels=new ArrayList<Channel>();
  final Runnable closer=new Runnable(){
    @Override public void run(){
      while (receivedAllEnvelopesLatch.getCount() != 0) {
        try {
          controller.fireIdle();
          if (rand.nextBoolean()) {
            controller.fireIdle();
          }
          Thread.sleep(minSleepTimeMs / 2);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
;
  final Runnable[] producers=new Runnable[numProducers];
  for (int i=0; i < numProducers; i++) {
    final int index=i;
    producers[i]=new Runnable(){
      @Override public void run(){
        final JobID jid=new JobID();
        final ChannelID cid=ids[index];
        for (int j=0; j < numEnvelopesPerProducer; j++) {
          OutboundConnectionQueue localQueue=producerQueues.get(cid);
          try {
            while (!localQueue.enqueue(new Envelope(j,jid,cid))) {
synchronized (lock) {
                if (localQueue == queue) {
                  closedChannels.add(channel);
                  channel=out.connect(bindHost,bindPort).sync().channel();
                  queue=new OutboundConnectionQueue(channel,receiver,connectionManager,0);
                  channel.pipeline().addFirst("Test Control Handler",controller);
                  channel.pipeline().addFirst("Test Verification Handler",verifier);
                }
              }
              producerQueues.put(cid,queue);
              localQueue=queue;
            }
            int sleepTime=rand.nextInt((maxSleepTimeMs - minSleepTimeMs) + 1) + minSleepTimeMs;
            Thread.sleep(sleepTime);
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
;
  }
  for (int i=0; i < numProducers; i++) {
    new Thread(producers[i],"Producer " + i).start();
  }
  new Thread(closer,"Closer").start();
  while (receivedAllEnvelopesLatch.getCount() != 0) {
    receivedAllEnvelopesLatch.await();
  }
synchronized (lock) {
    if (channel != null) {
      controller.fireIdle();
    }
  }
  verifier.waitForClose();
  if (minSleepTimeMs == 0 && maxSleepTimeMs == 0) {
    Assert.assertEquals(0,closedChannels.size());
  }
  for (  Channel ch : closedChannels) {
    Assert.assertFalse(ch.isOpen());
  }
  System.out.println(closedChannels.size() + " channels were closed during execution.");
  out.group().shutdownGracefully().sync();
  in.group().shutdownGracefully().sync();
}
