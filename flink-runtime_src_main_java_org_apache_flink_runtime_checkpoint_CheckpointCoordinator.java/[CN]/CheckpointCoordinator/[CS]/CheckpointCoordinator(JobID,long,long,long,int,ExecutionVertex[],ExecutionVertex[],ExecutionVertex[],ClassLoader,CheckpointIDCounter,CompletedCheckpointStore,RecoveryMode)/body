{
  checkArgument(baseInterval > 0,"Checkpoint timeout must be larger than zero");
  checkArgument(checkpointTimeout >= 1,"Checkpoint timeout must be larger than zero");
  checkArgument(minPauseBetweenCheckpoints >= 0,"minPauseBetweenCheckpoints must be >= 0");
  checkArgument(maxConcurrentCheckpointAttempts >= 1,"maxConcurrentCheckpointAttempts must be >= 1");
  this.job=checkNotNull(job);
  this.baseInterval=baseInterval;
  this.checkpointTimeout=checkpointTimeout;
  this.minPauseBetweenCheckpoints=minPauseBetweenCheckpoints;
  this.maxConcurrentCheckpointAttempts=maxConcurrentCheckpointAttempts;
  this.tasksToTrigger=checkNotNull(tasksToTrigger);
  this.tasksToWaitFor=checkNotNull(tasksToWaitFor);
  this.tasksToCommitTo=checkNotNull(tasksToCommitTo);
  this.pendingCheckpoints=new LinkedHashMap<Long,PendingCheckpoint>();
  this.completedCheckpointStore=checkNotNull(completedCheckpointStore);
  this.recentPendingCheckpoints=new ArrayDeque<Long>(NUM_GHOST_CHECKPOINT_IDS);
  this.userClassLoader=userClassLoader;
  this.checkpointIdCounter=checkNotNull(checkpointIDCounter);
  checkpointIDCounter.start();
  this.timer=new Timer("Checkpoint Timer",true);
  if (recoveryMode == RecoveryMode.STANDALONE) {
    this.shutdownHook=new Thread(new Runnable(){
      @Override public void run(){
        try {
          CheckpointCoordinator.this.shutdown();
        }
 catch (        Throwable t) {
          LOG.error("Error during shutdown of checkpoint coordinator via " + "JVM shutdown hook: " + t.getMessage(),t);
        }
      }
    }
);
    try {
      Runtime.getRuntime().addShutdownHook(shutdownHook);
    }
 catch (    IllegalStateException ignored) {
    }
catch (    Throwable t) {
      LOG.error("Cannot register checkpoint coordinator shutdown hook.",t);
    }
  }
 else {
    this.shutdownHook=null;
  }
}
