{
  if (shutdown) {
    LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.");
    return false;
  }
  final long checkpointID=checkpointIdCounter.getAndIncrement();
  LOG.info("Triggering checkpoint " + checkpointID + " @ "+ timestamp);
  try {
    ExecutionAttemptID[] triggerIDs=new ExecutionAttemptID[tasksToTrigger.length];
    for (int i=0; i < tasksToTrigger.length; i++) {
      Execution ee=tasksToTrigger[i].getCurrentExecutionAttempt();
      if (ee != null) {
        triggerIDs[i]=ee.getAttemptId();
      }
 else {
        LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",tasksToTrigger[i].getSimpleName());
        return false;
      }
    }
    Map<ExecutionAttemptID,ExecutionVertex> ackTasks=new HashMap<ExecutionAttemptID,ExecutionVertex>(tasksToWaitFor.length);
    for (    ExecutionVertex ev : tasksToWaitFor) {
      Execution ee=ev.getCurrentExecutionAttempt();
      if (ee != null) {
        ackTasks.put(ee.getAttemptId(),ev);
      }
 else {
        LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",ev.getSimpleName());
        return false;
      }
    }
    final PendingCheckpoint checkpoint=new PendingCheckpoint(job,checkpointID,timestamp,ackTasks);
    TimerTask canceller=new TimerTask(){
      @Override public void run(){
        try {
synchronized (lock) {
            if (!checkpoint.isDiscarded()) {
              LOG.info("Checkpoint " + checkpointID + " expired before completing.");
              checkpoint.discard(userClassLoader,true);
              pendingCheckpoints.remove(checkpointID);
              rememberRecentCheckpointId(checkpointID);
            }
          }
        }
 catch (        Throwable t) {
          LOG.error("Exception while handling checkpoint timeout",t);
        }
      }
    }
;
synchronized (lock) {
      if (shutdown) {
        throw new IllegalStateException("Checkpoint coordinator has been shutdown.");
      }
      pendingCheckpoints.put(checkpointID,checkpoint);
      timer.schedule(canceller,checkpointTimeout);
    }
    for (int i=0; i < tasksToTrigger.length; i++) {
      ExecutionAttemptID id=triggerIDs[i];
      TriggerCheckpoint message=new TriggerCheckpoint(job,id,checkpointID,timestamp);
      tasksToTrigger[i].sendMessageToCurrentExecution(message,id);
    }
    numUnsuccessfulCheckpointsTriggers.set(0);
    return true;
  }
 catch (  Throwable t) {
    int numUnsuccessful=numUnsuccessfulCheckpointsTriggers.incrementAndGet();
    LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)",t);
synchronized (lock) {
      PendingCheckpoint checkpoint=pendingCheckpoints.remove(checkpointID);
      if (checkpoint != null && !checkpoint.isDiscarded()) {
        checkpoint.discard(userClassLoader,true);
      }
    }
    return false;
  }
}
