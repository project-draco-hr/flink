{
synchronized (lock) {
    if (shutdown) {
      return false;
    }
    if (triggerRequestQueued) {
      LOG.warn("Trying to trigger another checkpoint while one was queued already");
      return false;
    }
    if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {
      triggerRequestQueued=true;
      if (currentPeriodicTrigger != null) {
        currentPeriodicTrigger.cancel();
        currentPeriodicTrigger=null;
      }
      return false;
    }
    if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {
      if (currentPeriodicTrigger != null) {
        currentPeriodicTrigger.cancel();
        currentPeriodicTrigger=null;
      }
      ScheduledTrigger trigger=new ScheduledTrigger();
      timer.scheduleAtFixedRate(trigger,minPauseBetweenCheckpoints,baseInterval);
      return false;
    }
  }
  ExecutionAttemptID[] triggerIDs=new ExecutionAttemptID[tasksToTrigger.length];
  for (int i=0; i < tasksToTrigger.length; i++) {
    Execution ee=tasksToTrigger[i].getCurrentExecutionAttempt();
    if (ee != null && ee.getState() == ExecutionState.RUNNING) {
      triggerIDs[i]=ee.getAttemptId();
    }
 else {
      LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",tasksToTrigger[i].getSimpleName());
      return false;
    }
  }
  Map<ExecutionAttemptID,ExecutionVertex> ackTasks=new HashMap<>(tasksToWaitFor.length);
  for (  ExecutionVertex ev : tasksToWaitFor) {
    Execution ee=ev.getCurrentExecutionAttempt();
    if (ee != null) {
      ackTasks.put(ee.getAttemptId(),ev);
    }
 else {
      LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",ev.getSimpleName());
      return false;
    }
  }
  lastTriggeredCheckpoint=timestamp;
  final long checkpointID;
  if (nextCheckpointId < 0) {
    try {
      checkpointID=checkpointIdCounter.getAndIncrement();
    }
 catch (    Throwable t) {
      int numUnsuccessful=++numUnsuccessfulCheckpointsTriggers;
      LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)",t);
      return false;
    }
  }
 else {
    checkpointID=nextCheckpointId;
  }
  LOG.info("Triggering checkpoint " + checkpointID + " @ "+ timestamp);
  final PendingCheckpoint checkpoint=new PendingCheckpoint(job,checkpointID,timestamp,ackTasks);
  TimerTask canceller=new TimerTask(){
    @Override public void run(){
      try {
synchronized (lock) {
          if (!checkpoint.isDiscarded()) {
            LOG.info("Checkpoint " + checkpointID + " expired before completing.");
            checkpoint.discard(userClassLoader);
            pendingCheckpoints.remove(checkpointID);
            rememberRecentCheckpointId(checkpointID);
            onCancelCheckpoint(checkpointID);
            triggerQueuedRequests();
          }
        }
      }
 catch (      Throwable t) {
        LOG.error("Exception while handling checkpoint timeout",t);
      }
    }
  }
;
  try {
synchronized (lock) {
      if (shutdown) {
        return false;
      }
 else       if (triggerRequestQueued) {
        LOG.warn("Trying to trigger another checkpoint while one was queued already");
        return false;
      }
 else       if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {
        triggerRequestQueued=true;
        if (currentPeriodicTrigger != null) {
          currentPeriodicTrigger.cancel();
          currentPeriodicTrigger=null;
        }
        return false;
      }
      pendingCheckpoints.put(checkpointID,checkpoint);
      timer.schedule(canceller,checkpointTimeout);
    }
    for (int i=0; i < tasksToTrigger.length; i++) {
      ExecutionAttemptID id=triggerIDs[i];
      TriggerCheckpoint message=new TriggerCheckpoint(job,id,checkpointID,timestamp);
      tasksToTrigger[i].sendMessageToCurrentExecution(message,id);
    }
    numUnsuccessfulCheckpointsTriggers=0;
    return true;
  }
 catch (  Throwable t) {
synchronized (lock) {
      pendingCheckpoints.remove(checkpointID);
    }
    int numUnsuccessful=++numUnsuccessfulCheckpointsTriggers;
    LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)",t);
    if (!checkpoint.isDiscarded()) {
      checkpoint.discard(userClassLoader);
    }
    return false;
  }
}
