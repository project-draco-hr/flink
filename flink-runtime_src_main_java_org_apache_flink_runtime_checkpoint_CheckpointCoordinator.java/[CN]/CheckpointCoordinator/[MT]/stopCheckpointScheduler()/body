{
synchronized (lock) {
    triggerRequestQueued=false;
    periodicScheduling=false;
    if (currentPeriodicTrigger != null) {
      currentPeriodicTrigger.cancel();
      currentPeriodicTrigger=null;
    }
    for (    PendingCheckpoint p : pendingCheckpoints.values()) {
      p.abortError(new Exception("Checkpoint Coordinator is suspending."));
    }
    pendingCheckpoints.clear();
    numUnsuccessfulCheckpointsTriggers=0;
  }
}
