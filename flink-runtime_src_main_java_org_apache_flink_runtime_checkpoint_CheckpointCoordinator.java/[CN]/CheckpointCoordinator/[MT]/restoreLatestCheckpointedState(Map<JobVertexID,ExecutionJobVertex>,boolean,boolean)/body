{
synchronized (lock) {
    if (shutdown) {
      throw new IllegalStateException("CheckpointCoordinator is shut down");
    }
    completedCheckpointStore.recover();
    CompletedCheckpoint latest=completedCheckpointStore.getLatestCheckpoint();
    if (latest == null) {
      if (errorIfNoCheckpoint) {
        throw new IllegalStateException("No completed checkpoint available");
      }
 else {
        return false;
      }
    }
    for (    Map.Entry<JobVertexID,TaskState> taskGroupStateEntry : latest.getTaskStates().entrySet()) {
      TaskState taskState=taskGroupStateEntry.getValue();
      ExecutionJobVertex executionJobVertex=tasks.get(taskGroupStateEntry.getKey());
      if (executionJobVertex != null) {
        if (taskState.getParallelism() != executionJobVertex.getParallelism()) {
          throw new RuntimeException("Cannot restore the latest checkpoint because " + "the parallelism changed. The operator" + executionJobVertex.getJobVertexId() + " has parallelism "+ executionJobVertex.getParallelism()+ " whereas the corresponding"+ "state object has a parallelism of "+ taskState.getParallelism());
        }
        int counter=0;
        List<Set<Integer>> keyGroupPartitions=createKeyGroupPartitions(numberKeyGroups,executionJobVertex.getParallelism());
        for (int i=0; i < executionJobVertex.getParallelism(); i++) {
          SubtaskState subtaskState=taskState.getState(i);
          SerializedValue<StateHandle<?>> state=null;
          if (subtaskState != null) {
            counter++;
            state=subtaskState.getState();
          }
          Map<Integer,SerializedValue<StateHandle<?>>> kvStateForTaskMap=taskState.getUnwrappedKvStates(keyGroupPartitions.get(i));
          Execution currentExecutionAttempt=executionJobVertex.getTaskVertices()[i].getCurrentExecutionAttempt();
          currentExecutionAttempt.setInitialState(state,kvStateForTaskMap);
        }
        if (allOrNothingState && counter > 0 && counter < executionJobVertex.getParallelism()) {
          throw new IllegalStateException("The checkpoint contained state only for " + "a subset of tasks for vertex " + executionJobVertex);
        }
      }
 else {
        throw new IllegalStateException("There is no execution job vertex for the job" + " vertex ID " + taskGroupStateEntry.getKey());
      }
    }
    return true;
  }
}
