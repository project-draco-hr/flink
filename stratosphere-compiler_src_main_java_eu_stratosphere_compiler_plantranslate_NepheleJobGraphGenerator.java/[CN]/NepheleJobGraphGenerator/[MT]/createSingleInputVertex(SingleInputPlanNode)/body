{
  final String taskName=node.getNodeName();
  final DriverStrategy ds=node.getDriverStrategy();
  boolean chaining=false;
{
    Channel inConn=node.getInput();
    PlanNode pred=inConn.getSource();
    chaining=ds.getPushChainDriverClass() != null && !(pred instanceof NAryUnionPlanNode) && !(pred instanceof BulkPartialSolutionPlanNode) && !(pred instanceof IterationPlanNode) && inConn.getShipStrategy() == ShipStrategyType.FORWARD && inConn.getLocalStrategy() == LocalStrategy.NONE && pred.getOutgoingChannels().size() == 1 && node.getDegreeOfParallelism() == pred.getDegreeOfParallelism() && node.getSubtasksPerInstance() == pred.getSubtasksPerInstance();
    if (this.currentIteration != null && this.currentIteration instanceof WorksetIterationPlanNode && node.getOutgoingChannels().size() > 0) {
      WorksetIterationPlanNode wspn=(WorksetIterationPlanNode)this.currentIteration;
      if (wspn.getSolutionSetDeltaPlanNode() == pred || wspn.getNextWorkSetPlanNode() == pred) {
        chaining=false;
      }
    }
  }
  final JobTaskVertex vertex;
  final TaskConfig config;
  if (chaining) {
    vertex=null;
    config=new TaskConfig(new Configuration());
    this.chainedTasks.put(node,new TaskInChain(ds.getPushChainDriverClass(),config,taskName));
  }
 else {
    vertex=new JobTaskVertex(taskName,this.jobGraph);
    vertex.setTaskClass((this.currentIteration != null && node.isOnDynamicPath()) ? IterationIntermediatePactTask.class : RegularPactTask.class);
    config=new TaskConfig(vertex.getConfiguration());
    config.setDriver(ds.getDriverClass());
  }
  config.setStubWrapper(node.getPactContract().getUserCodeWrapper());
  config.setStubParameters(node.getPactContract().getParameters());
  config.setDriverStrategy(ds);
  if (node.getComparator() != null) {
    config.setDriverComparator(node.getComparator(),0);
  }
  assignDriverResources(node,config);
  return vertex;
}
