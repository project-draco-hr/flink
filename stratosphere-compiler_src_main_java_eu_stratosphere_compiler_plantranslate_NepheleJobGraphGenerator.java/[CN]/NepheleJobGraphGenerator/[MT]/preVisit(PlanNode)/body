{
  if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node) || this.iterations.containsKey(node)) {
    return false;
  }
  final AbstractJobVertex vertex;
  try {
    if (node instanceof SinkPlanNode) {
      vertex=createDataSinkVertex((SinkPlanNode)node);
    }
 else     if (node instanceof SourcePlanNode) {
      vertex=createDataSourceVertex((SourcePlanNode)node);
    }
 else     if (node instanceof BulkIterationPlanNode) {
      BulkIterationPlanNode iterationNode=(BulkIterationPlanNode)node;
      PlanNode root=iterationNode.getRootOfStepFunction();
      if (root.getDegreeOfParallelism() != node.getDegreeOfParallelism() || root.getSubtasksPerInstance() != node.getSubtasksPerInstance()) {
        throw new CompilerException("Error: The final operator of the step " + "function has a different degree of parallelism than the iteration operator itself.");
      }
      IterationDescriptor descr=new IterationDescriptor(iterationNode,this.iterationIdEnumerator++);
      this.iterations.put(iterationNode,descr);
      vertex=null;
    }
 else     if (node instanceof WorksetIterationPlanNode) {
      WorksetIterationPlanNode iterationNode=(WorksetIterationPlanNode)node;
      PlanNode nextWorkSet=iterationNode.getNextWorkSetPlanNode();
      PlanNode solutionSetDelta=iterationNode.getSolutionSetDeltaPlanNode();
      if (nextWorkSet.getDegreeOfParallelism() != node.getDegreeOfParallelism() || nextWorkSet.getSubtasksPerInstance() != node.getSubtasksPerInstance()) {
        throw new CompilerException("It is currently not supported that the final operator of the step " + "function has a different degree of parallelism than the iteration operator itself.");
      }
      if (solutionSetDelta.getDegreeOfParallelism() != node.getDegreeOfParallelism() || solutionSetDelta.getSubtasksPerInstance() != node.getSubtasksPerInstance()) {
        throw new CompilerException("It is currently not supported that the final operator of the step " + "function has a different degree of parallelism than the iteration operator itself.");
      }
      IterationDescriptor descr=new IterationDescriptor(iterationNode,this.iterationIdEnumerator++);
      this.iterations.put(iterationNode,descr);
      vertex=null;
    }
 else     if (node instanceof SingleInputPlanNode) {
      vertex=createSingleInputVertex((SingleInputPlanNode)node);
    }
 else     if (node instanceof DualInputPlanNode) {
      vertex=createDualInputVertex((DualInputPlanNode)node);
    }
 else     if (node instanceof NAryUnionPlanNode) {
      vertex=null;
    }
 else     if (node instanceof BulkPartialSolutionPlanNode) {
      vertex=createBulkIterationHead((BulkPartialSolutionPlanNode)node);
    }
 else     if (node instanceof SolutionSetPlanNode) {
      vertex=null;
    }
 else     if (node instanceof WorksetPlanNode) {
      vertex=createWorksetIterationHead((WorksetPlanNode)node);
    }
 else {
      throw new CompilerException("Unrecognized node type: " + node.getClass().getName());
    }
  }
 catch (  Exception e) {
    throw new CompilerException("Error translating node '" + node + "': "+ e.getMessage(),e);
  }
  if (vertex != null) {
    int pd=node.getDegreeOfParallelism();
    vertex.setNumberOfSubtasks(pd);
    if (this.maxDegreeVertex == null || this.maxDegreeVertex.getNumberOfSubtasks() < pd) {
      this.maxDegreeVertex=vertex;
    }
    if (node.getSubtasksPerInstance() >= 1) {
      vertex.setNumberOfSubtasksPerInstance(node.getSubtasksPerInstance());
    }
    if (this.currentIteration != null) {
      PlanNode iterationNode=(PlanNode)this.currentIteration;
      if (iterationNode.getDegreeOfParallelism() < pd) {
        throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, degree-of-parallelism than the iteration operator.");
      }
      if (iterationNode.getSubtasksPerInstance() < node.getSubtasksPerInstance()) {
        throw new CompilerException("Error: All functions that are part of an iteration must have the same, or a lower, number of subtasks-per-node than the iteration operator.");
      }
      IterationDescriptor descr=this.iterations.get(this.currentIteration);
      new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId());
    }
    this.vertices.put(node,vertex);
  }
  return true;
}
