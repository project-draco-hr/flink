{
  final ExecutionEdge edge=edges.get(sourceChannelID);
  if (edge == null) {
    LOG.error("Cannot find execution edge associated with ID " + sourceChannelID);
    fail(new Exception("Channels are not correctly registered"));
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
  if (sourceChannelID.equals(edge.getInputChannelId())) {
    final ExecutionVertex targetVertex=edge.getSource().getProducer();
    final ExecutionState executionState=targetVertex.getExecutionState();
    if (executionState == ExecutionState.RUNNING) {
      Instance location=targetVertex.getCurrentAssignedResource().getInstance();
      if (location.getInstanceConnectionInfo().equals(caller)) {
        return ConnectionInfoLookupResponse.createReceiverFoundAndReady(edge.getOutputChannelId());
      }
 else {
        final InstanceConnectionInfo ici=location.getInstanceConnectionInfo();
        final InetSocketAddress isa=new InetSocketAddress(ici.address(),ici.dataPort());
        int connectionIdx=edge.getSource().getIntermediateResult().getConnectionIndex();
        return ConnectionInfoLookupResponse.createReceiverFoundAndReady(new RemoteReceiver(isa,connectionIdx));
      }
    }
 else     if (executionState == ExecutionState.FINISHED) {
      LOG.error("Receiver " + targetVertex + " set to FINISHED even though data is pending");
      fail(new Exception("Channels are not correctly registered"));
      return ConnectionInfoLookupResponse.createReceiverNotFound();
    }
 else     if (executionState == ExecutionState.FAILED || executionState == ExecutionState.CANCELED || executionState == ExecutionState.CANCELING) {
      return ConnectionInfoLookupResponse.createJobIsAborting();
    }
 else {
      LOG.error("Channel lookup (backwards) - sender " + targetVertex + " found in inconsistent state "+ executionState);
      fail(new Exception("Channels are not correctly registered"));
      return ConnectionInfoLookupResponse.createReceiverNotFound();
    }
  }
  final ExecutionVertex targetVertex=edge.getTarget();
  final ExecutionState executionState=targetVertex.getExecutionState();
  if (executionState == ExecutionState.RUNNING) {
    Instance location=targetVertex.getCurrentAssignedResource().getInstance();
    if (location.getInstanceConnectionInfo().equals(caller)) {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(edge.getInputChannelId());
    }
 else {
      final InstanceConnectionInfo ici=location.getInstanceConnectionInfo();
      final InetSocketAddress isa=new InetSocketAddress(ici.address(),ici.dataPort());
      final int connectionIdx=edge.getSource().getIntermediateResult().getConnectionIndex();
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(new RemoteReceiver(isa,connectionIdx));
    }
  }
 else   if (executionState == ExecutionState.DEPLOYING || executionState == ExecutionState.SCHEDULED) {
    return ConnectionInfoLookupResponse.createReceiverNotReady();
  }
 else   if (executionState == ExecutionState.CREATED) {
    try {
      edge.getTarget().scheduleForExecution(scheduler,false);
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
 catch (    JobException e) {
      fail(new Exception("Cannot schedule the receivers, not enough resources."));
      return ConnectionInfoLookupResponse.createJobIsAborting();
    }
  }
 else   if (executionState == ExecutionState.CANCELED || executionState == ExecutionState.CANCELING || executionState == ExecutionState.FAILED) {
    return ConnectionInfoLookupResponse.createJobIsAborting();
  }
 else {
    String message="Channel lookup (forward) - receiver " + targetVertex + " found in inconsistent state "+ executionState;
    LOG.error(message);
    fail(new Exception(message));
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
}
