{
synchronized (progressLock) {
    int nextPos=nextVertexToFinish;
    if (nextPos >= verticesInCreationOrder.size()) {
      return;
    }
    if (verticesInCreationOrder.get(nextPos) == ev) {
      do {
        nextPos++;
      }
 while (nextPos < verticesInCreationOrder.size() && verticesInCreationOrder.get(nextPos).isInFinalState());
      nextVertexToFinish=nextPos;
      if (nextPos == verticesInCreationOrder.size()) {
        JobStatus current;
        while (true) {
          current=this.state;
          if (current == JobStatus.RUNNING) {
            if (transitionState(current,JobStatus.FINISHED)) {
              postRunCleanup();
              break;
            }
          }
 else           if (current == JobStatus.CANCELLING) {
            if (transitionState(current,JobStatus.CANCELED)) {
              postRunCleanup();
              break;
            }
          }
 else           if (current == JobStatus.FAILING) {
            if (numberOfRetriesLeft > 0 && transitionState(current,JobStatus.RESTARTING)) {
              numberOfRetriesLeft--;
              future(new Callable<Object>(){
                @Override public Object call() throws Exception {
                  try {
                    Thread.sleep(delayBeforeRetrying);
                  }
 catch (                  InterruptedException e) {
                  }
                  restart();
                  return null;
                }
              }
,AkkaUtils.globalExecutionContext());
              break;
            }
 else             if (numberOfRetriesLeft <= 0 && transitionState(current,JobStatus.FAILED,failureCause)) {
              postRunCleanup();
              break;
            }
          }
 else {
            fail(new Exception("ExecutionGraph went into final state from state " + current));
          }
        }
        progressLock.notifyAll();
      }
    }
  }
}
