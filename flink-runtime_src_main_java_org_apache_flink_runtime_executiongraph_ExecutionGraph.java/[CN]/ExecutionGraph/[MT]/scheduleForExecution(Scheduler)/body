{
  if (scheduler == null) {
    throw new IllegalArgumentException("Scheduler must not be null.");
  }
  if (this.scheduler != null && this.scheduler != scheduler) {
    throw new IllegalArgumentException("Cannot use different schedulers for the same job");
  }
  if (transitionState(JobStatus.CREATED,JobStatus.RUNNING)) {
    this.scheduler=scheduler;
switch (scheduleMode) {
case FROM_SOURCES:
      for (      ExecutionJobVertex ejv : this.tasks.values()) {
        if (ejv.getJobVertex().isInputVertex()) {
          ejv.scheduleAll(scheduler,allowQueuedScheduling);
        }
      }
    break;
case ALL:
  for (  ExecutionJobVertex ejv : getVerticesTopologically()) {
    ejv.scheduleAll(scheduler,allowQueuedScheduling);
  }
break;
case BACKTRACKING:
throw new JobException("BACKTRACKING is currently not supported as schedule mode.");
}
if (monitoringEnabled) {
stateMonitorActor=StreamCheckpointCoordinator.spawn(parentContext,this,Duration.create(monitoringInterval,TimeUnit.MILLISECONDS));
}
}
 else {
throw new IllegalStateException("Job may only be scheduled from state " + JobStatus.CREATED);
}
}
