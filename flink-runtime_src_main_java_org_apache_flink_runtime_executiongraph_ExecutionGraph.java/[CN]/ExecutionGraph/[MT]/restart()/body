{
  try {
    if (state == JobStatus.FAILED) {
      if (!transitionState(JobStatus.FAILED,JobStatus.RESTARTING)) {
        throw new IllegalStateException("Execution Graph left the state FAILED while trying to restart.");
      }
    }
synchronized (progressLock) {
      if (state != JobStatus.RESTARTING) {
        throw new IllegalStateException("Can only restart job from state restarting.");
      }
      if (scheduler == null) {
        throw new IllegalStateException("The execution graph has not been scheduled before - scheduler is null.");
      }
      this.currentExecutions.clear();
      for (      ExecutionJobVertex jv : this.verticesInCreationOrder) {
        jv.resetForNewExecution();
      }
      for (int i=0; i < stateTimestamps.length; i++) {
        stateTimestamps[i]=0;
      }
      numFinishedJobVertices=0;
      transitionState(JobStatus.RESTARTING,JobStatus.CREATED);
      if (checkpointCoordinator != null) {
        checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(),false,false);
      }
    }
    scheduleForExecution(scheduler);
  }
 catch (  Throwable t) {
    fail(t);
  }
}
