{
  try {
synchronized (progressLock) {
      JobStatus current=state;
      if (current == JobStatus.CANCELED) {
        LOG.info("Canceled job during restart. Aborting restart.");
        return;
      }
 else       if (current != JobStatus.RESTARTING) {
        throw new IllegalStateException("Can only restart job from state restarting.");
      }
      if (scheduler == null) {
        throw new IllegalStateException("The execution graph has not been scheduled before - scheduler is null.");
      }
      this.currentExecutions.clear();
      for (      ExecutionJobVertex jv : this.verticesInCreationOrder) {
        jv.resetForNewExecution();
      }
      for (int i=0; i < stateTimestamps.length; i++) {
        stateTimestamps[i]=0;
      }
      numFinishedJobVertices=0;
      transitionState(JobStatus.RESTARTING,JobStatus.CREATED);
      if (checkpointCoordinator != null) {
        checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(),false,false);
      }
    }
    scheduleForExecution(scheduler);
  }
 catch (  Throwable t) {
    fail(t);
  }
}
