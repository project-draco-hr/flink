{
  try {
    if (state == JobStatus.FAILED) {
      transitionState(JobStatus.FAILED,JobStatus.RESTARTING);
    }
synchronized (progressLock) {
      if (state != JobStatus.RESTARTING) {
        throw new IllegalStateException("Can only restart job from state restarting.");
      }
      if (scheduler == null) {
        throw new IllegalStateException("The execution graph has not been schedudled before - scheduler is null.");
      }
      this.currentExecutions.clear();
      this.edges.clear();
      for (      ExecutionJobVertex jv : this.verticesInCreationOrder) {
        jv.resetForNewExecution();
      }
      for (int i=0; i < stateTimestamps.length; i++) {
        stateTimestamps[i]=0;
      }
      nextVertexToFinish=0;
      transitionState(JobStatus.RESTARTING,JobStatus.CREATED);
    }
    scheduleForExecution(scheduler);
  }
 catch (  Throwable t) {
    fail(t);
  }
}
