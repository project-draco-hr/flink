{
  final InternalJobStatus currentJobStatus=eg.getJobStatus();
switch (currentJobStatus) {
case CREATED:
    if (eg.jobHasScheduledStatus()) {
      return InternalJobStatus.SCHEDULED;
    }
 else     if (latestStateChange == ExecutionState.CANCELED) {
      if (eg.jobHasFailedOrCanceledStatus()) {
        return InternalJobStatus.CANCELED;
      }
    }
 else     if (latestStateChange == ExecutionState.FAILED) {
      return InternalJobStatus.FAILING;
    }
  break;
case SCHEDULED:
if (latestStateChange == ExecutionState.RUNNING) {
  return InternalJobStatus.RUNNING;
}
 else if (latestStateChange == ExecutionState.CANCELED) {
  if (eg.jobHasFailedOrCanceledStatus()) {
    return InternalJobStatus.CANCELED;
  }
}
 else if (latestStateChange == ExecutionState.FAILED) {
  return InternalJobStatus.FAILING;
}
break;
case RUNNING:
if (latestStateChange == ExecutionState.CANCELED) {
return InternalJobStatus.CANCELING;
}
if (latestStateChange == ExecutionState.FAILED) {
final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,true);
while (it.hasNext()) {
final ExecutionVertex vertex=it.next();
if (vertex.getExecutionState() == ExecutionState.FAILED) {
return InternalJobStatus.FAILING;
}
}
}
if (eg.jobHasFinishedStatus()) {
return InternalJobStatus.FINISHED;
}
break;
case FAILING:
if (eg.jobHasFailedOrCanceledStatus()) {
return InternalJobStatus.FAILED;
}
break;
case FAILED:
LOG.error("Received update of execute state in job status FAILED");
break;
case CANCELING:
if (eg.jobHasFailedOrCanceledStatus()) {
return InternalJobStatus.CANCELED;
}
break;
case CANCELED:
LOG.error("Received update of execute state in job status CANCELED: " + eg.getJobID());
break;
case FINISHED:
LOG.error("Received update of execute state in job status FINISHED: " + eg.getJobID() + " "+ StringUtils.stringifyException(new Throwable()));
break;
}
return currentJobStatus;
}
