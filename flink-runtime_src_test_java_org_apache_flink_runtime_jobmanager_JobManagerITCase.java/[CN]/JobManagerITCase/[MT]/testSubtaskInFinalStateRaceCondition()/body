{
  final int NUM_TASKS=1;
  try {
    final AbstractJobVertex source=new AbstractJobVertex("Source");
    final WaitingOnFinalizeJobVertex sink=new WaitingOnFinalizeJobVertex("Sink",500);
    source.setInvokableClass(WaitingNoOpInvokable.class);
    sink.setInvokableClass(NoOpInvokable.class);
    source.setParallelism(NUM_TASKS);
    sink.setParallelism(NUM_TASKS);
    final JobGraph jobGraph=new JobGraph("SubtaskInFinalStateRaceCondition",source,sink);
    final JobManager jm=startJobManager(2 * NUM_TASKS);
    try {
      JobSubmissionResult result=jm.submitJob(jobGraph);
      if (result.getReturnCode() != AbstractJobResult.ReturnCode.SUCCESS) {
        fail(result.getDescription());
      }
      ExecutionGraph eg=jm.getCurrentJobs().get(jobGraph.getJobID());
      if (eg != null) {
        eg.waitForJobEnd();
        assertEquals(JobStatus.FINISHED,eg.getState());
      }
      assertTrue("Sink has to have called finalizeOnMaster before job can finish.",sink.finished);
      waitForTaskThreadsToBeTerminated();
    }
  finally {
      jm.shutdown();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
