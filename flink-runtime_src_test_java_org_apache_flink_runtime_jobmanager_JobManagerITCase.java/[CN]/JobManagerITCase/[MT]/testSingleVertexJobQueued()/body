{
  final int NUM_TASKS=111;
  try {
    final AbstractJobVertex vertex=new AbstractJobVertex("Test Vertex");
    vertex.setParallelism(NUM_TASKS);
    vertex.setInvokableClass(NoOpInvokable.class);
    final JobGraph jobGraph=new JobGraph("Test Job",vertex);
    jobGraph.setAllowQueuedScheduling(true);
    JobManager jm=startJobManager(10);
    try {
      LibraryCacheManager.register(jobGraph.getJobID(),new String[0]);
      JobSubmissionResult result=jm.submitJob(jobGraph);
      assertEquals(AbstractJobResult.ReturnCode.SUCCESS,result.getReturnCode());
      ExecutionGraph eg=jm.getCurrentJobs().get(jobGraph.getJobID());
      if (eg != null) {
        eg.waitForJobEnd();
        assertEquals(JobStatus.FINISHED,eg.getState());
      }
 else {
      }
    }
  finally {
      jm.shutdown();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
