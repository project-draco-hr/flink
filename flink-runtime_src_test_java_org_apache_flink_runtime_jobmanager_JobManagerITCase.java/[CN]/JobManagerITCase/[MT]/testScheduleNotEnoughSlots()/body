{
  try {
    final AbstractJobVertex vertex=new AbstractJobVertex("Test Vertex");
    vertex.setParallelism(2);
    vertex.setInvokableClass(BlockingNoOpInvokable.class);
    final JobGraph jobGraph=new JobGraph("Test Job",vertex);
    final JobManager jm=startJobManager(1);
    final GlobalBufferPool bp=((LocalInstanceManager)jm.getInstanceManager()).getTaskManagers()[0].getChannelManager().getGlobalBufferPool();
    try {
      assertEquals(1,jm.getAvailableSlots());
      LibraryCacheManager.register(jobGraph.getJobID(),new String[0]);
      JobSubmissionResult result=jm.submitJob(jobGraph);
      assertEquals(AbstractJobResult.ReturnCode.ERROR,result.getReturnCode());
      ExecutionGraph eg=jm.getCurrentJobs().get(jobGraph.getJobID());
      if (eg != null) {
        long deadline=System.currentTimeMillis() + 60 * 1000;
        boolean success=false;
        while (System.currentTimeMillis() < deadline) {
          JobStatus state=eg.getState();
          if (state == JobStatus.FINISHED) {
            success=true;
            break;
          }
 else           if (state == JobStatus.FAILED || state == JobStatus.CANCELED) {
            break;
          }
 else {
            Thread.sleep(200);
          }
        }
        assertTrue("The job did not finish successfully.",success);
        assertEquals(0,eg.getRegisteredExecutions().size());
      }
 else {
      }
      waitForTaskThreadsToBeTerminated();
      assertEquals(bp.numBuffers(),bp.numAvailableBuffers());
    }
  finally {
      jm.shutdown();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
