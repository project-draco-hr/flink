{
  super.read(in);
  final int numOutputChannels=in.readInt();
  final Class<?>[] parameters={OutputGate.class,int.class,ChannelID.class,CompressionLevel.class};
  for (int i=0; i < numOutputChannels; i++) {
    final ChannelID channelID=new ChannelID();
    channelID.read(in);
    final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
    final String className=StringRecord.readString(in);
    Class<? extends IOReadableWritable> c=null;
    try {
      c=ClassUtils.getRecordByName(className);
    }
 catch (    ClassNotFoundException e) {
      LOG.error(e);
    }
    if (c == null) {
      throw new IOException("Class is null!");
    }
    AbstractOutputChannel<T> eoc=null;
    try {
      final Constructor<AbstractOutputChannel<T>> constructor=(Constructor<AbstractOutputChannel<T>>)c.getDeclaredConstructor(parameters);
      if (constructor == null) {
        throw new IOException("Constructor is null!");
      }
      constructor.setAccessible(true);
      eoc=constructor.newInstance(this,i,channelID,compressionLevel);
    }
 catch (    InstantiationException e) {
      LOG.error(e);
    }
catch (    IllegalArgumentException e) {
      LOG.error(e);
    }
catch (    IllegalAccessException e) {
      LOG.error(e);
    }
catch (    InvocationTargetException e) {
      LOG.error(e);
    }
catch (    SecurityException e) {
      LOG.error(e);
    }
catch (    NoSuchMethodException e) {
      LOG.error(e);
    }
    if (eoc == null) {
      throw new IOException("Created output channel is null!");
    }
    eoc.read(in);
    addOutputChannel(eoc);
  }
}
