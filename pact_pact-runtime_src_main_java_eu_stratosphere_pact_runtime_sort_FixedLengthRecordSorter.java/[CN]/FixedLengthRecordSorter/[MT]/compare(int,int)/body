{
  final int bufferNumI=i / this.recordsPerSegment;
  final int segmentOffsetI=(i % this.recordsPerSegment) * this.recordSize;
  final int bufferNumJ=j / this.recordsPerSegment;
  final int segmentOffsetJ=(j % this.recordsPerSegment) * this.recordSize;
  final MemorySegment segI=this.sortBuffer.get(bufferNumI);
  final MemorySegment segJ=this.sortBuffer.get(bufferNumJ);
  final byte[] bI=segI.getBackingArray();
  final byte[] bJ=segJ.getBackingArray();
  int val=0;
  for (int pos=0, posI=segI.translateOffset(segmentOffsetI), posJ=segJ.translateOffset(segmentOffsetJ); pos < this.numKeyBytes && (val=(bI[posI] & 0xff) - (bJ[posJ] & 0xff)) == 0; pos++, posI++, posJ++)   ;
  if (val != 0 || this.normalizedKeyFullyDetermines) {
    return this.useNormKeyUninverted ? val : -val;
  }
  throw new IllegalStateException("We do not support directly comparing records here.");
}
