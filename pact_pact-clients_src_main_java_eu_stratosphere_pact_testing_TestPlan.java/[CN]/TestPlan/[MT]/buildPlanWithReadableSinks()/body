{
  final Collection<FileDataSinkContract<?,?>> existingSinks=this.getDataSinks();
  final Collection<FileDataSinkContract<?,?>> wrappedSinks=new ArrayList<FileDataSinkContract<?,?>>();
  for (  final FileDataSinkContract<?,?> FileDataSinkContract : existingSinks)   if (!FileDataSinkContract.getFormatClass().equals(SequentialOutputFormat.class)) {
    final FileDataSinkContract<Key,Value> safeSink=createDefaultSink(FileDataSinkContract.getName());
    safeSink.setInput(FileDataSinkContract.getInput());
    wrappedSinks.add(FileDataSinkContract);
    wrappedSinks.add(safeSink);
    this.expectedOutputs.put(safeSink,this.getExpectedOutput(FileDataSinkContract));
    this.actualOutputs.put(safeSink,this.getActualOutput(FileDataSinkContract));
    this.getActualOutput(FileDataSinkContract).fromFile(SequentialInputFormat.class,safeSink.getFilePath());
  }
 else {
    wrappedSinks.add(FileDataSinkContract);
    this.getActualOutput(FileDataSinkContract).fromFile(SequentialInputFormat.class,FileDataSinkContract.getFilePath());
  }
  return new Plan(wrappedSinks);
}
