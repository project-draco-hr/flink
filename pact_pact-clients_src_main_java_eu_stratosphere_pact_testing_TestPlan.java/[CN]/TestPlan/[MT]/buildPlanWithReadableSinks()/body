{
  final Collection<FileDataSink> existingSinks=this.getDataSinks();
  final Collection<GenericDataSink> wrappedSinks=new ArrayList<GenericDataSink>();
  for (  final FileDataSink fileSink : existingSinks)   if (!fileSink.getFormatClass().equals(SequentialOutputFormat.class)) {
    TestPairs expectedValues=this.expectedOutputs.get(fileSink);
    if (expectedValues == null)     continue;
    final FileDataSink safeSink=createDefaultSink(fileSink.getName());
    safeSink.setInputs(fileSink.getInputs());
    wrappedSinks.add(fileSink);
    wrappedSinks.add(safeSink);
    this.expectedOutputs.put(safeSink,expectedValues);
    this.actualOutputs.put(safeSink,this.getActualOutput(fileSink));
    this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class,safeSink.getFilePath());
  }
 else {
    wrappedSinks.add(fileSink);
    this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class,fileSink.getFilePath());
  }
  return new Plan(wrappedSinks);
}
