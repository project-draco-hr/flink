{
  for (  final DataSinkContract<?,?> dataSinkContract : this.getDataSinks())   if (dataSinkContract.getStubClass() == SequentialOutputFormat.class && this.getExpectedOutput(dataSinkContract).isInitialized()) {
    final TestPairs<Key,Value> actualValues=new TestPairs<Key,Value>();
    actualValues.fromFile(SequentialInputFormat.class,dataSinkContract.getFilePath());
    final TestPairs<Key,Value> expectedValues=(TestPairs<Key,Value>)this.getExpectedOutput(dataSinkContract);
    final Iterator<KeyValuePair<Key,Value>> actualIterator=actualValues.iterator();
    final Iterator<KeyValuePair<Key,Value>> expectedIterator=expectedValues.iterator();
    final int index=0;
    while (actualIterator.hasNext() && expectedIterator.hasNext()) {
      final Object expected=expectedIterator.next(), actual=actualIterator.next();
      try {
        Assert.assertEquals(expected,actual);
      }
 catch (      final AssertionFailedError e) {
        throw new ArrayComparisonFailure(String.format("Data sink %s contains unexpected values: ",dataSinkContract.getName()),e,index);
      }
    }
    if (expectedIterator.hasNext())     fail("More elements expected: " + toString(expectedIterator),dataSinkContract.getName());
    if (actualIterator.hasNext())     fail("Less elements expected: " + toString(actualIterator),dataSinkContract.getName());
  }
}
