{
  Integer[] times={1,3,4,6,7,9,14,20,21,22,30,31,33,36,40,41,42,43,44,45,47,55};
  Integer[] numToDelete={0,0,0,0,0,0,0,0,0,1,0,2,0,0,0,0,3};
  @SuppressWarnings("serial") TimeStamp<Integer> timeStamp=new TimeStamp<Integer>(){
    @Override public long getTimestamp(    Integer value){
      return value;
    }
    @Override public long getStartTime(){
      return 0;
    }
  }
;
  for (long granularity=0; granularity < 40; granularity++) {
    TimeEvictionPolicy<Integer> policy=new TimeEvictionPolicy<Integer>(granularity,timeStamp);
    boolean triggered=false;
    int fakeAndRealCounter=0;
    boolean fake=false;
    LinkedList<Integer> buffer=new LinkedList<Integer>();
    for (int i=0; i < times.length; i++) {
      fakeAndRealCounter++;
      if (fakeAndRealCounter > 2) {
        fake=!fake;
        fakeAndRealCounter=0;
      }
      int result;
      if (fake) {
        result=policy.notifyEvictionWithFakeElement(times[i],buffer.size());
      }
 else {
        result=policy.notifyEviction(times[i],(triggered=!triggered),buffer.size());
      }
      for (; result > 0 && !buffer.isEmpty(); result--) {
        if (buffer.getFirst() <= times[i] - granularity) {
          buffer.removeFirst();
        }
 else {
          fail("The policy wanted to evict time " + buffer.getFirst() + " while the current time was "+ times[i]+ "and the granularity was "+ granularity);
        }
      }
      if (!buffer.isEmpty()) {
        assertTrue("The policy did not evict " + buffer.getFirst() + " while the current time was "+ times[i]+ " and the granularity was "+ granularity,(buffer.getFirst() >= times[i] - granularity));
      }
      for (int j=numToDelete[i % numToDelete.length]; j > 0; j--) {
        if (!buffer.isEmpty()) {
          buffer.removeFirst();
        }
      }
      if (!fake) {
        buffer.add(times[i]);
      }
    }
  }
}
