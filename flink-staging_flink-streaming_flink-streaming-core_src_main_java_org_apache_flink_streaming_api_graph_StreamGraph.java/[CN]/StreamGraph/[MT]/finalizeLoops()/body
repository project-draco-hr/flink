{
  for (  StreamLoop loop : streamLoops.values()) {
    if (loop.getSourceSinkPairs().isEmpty()) {
      List<StreamNode> headOps=loop.getHeads();
      List<StreamNode> tailOps=loop.getTails();
      if (tailOps.isEmpty()) {
        throw new RuntimeException("Cannot execute job with empty iterations.");
      }
      if (loop.keepsPartitioning()) {
        Map<Integer,List<StreamNode>> parallelismToHeads=new HashMap<Integer,List<StreamNode>>();
        for (        StreamNode head : headOps) {
          int p=head.getParallelism();
          if (!parallelismToHeads.containsKey(p)) {
            parallelismToHeads.put(p,new ArrayList<StreamNode>());
          }
          parallelismToHeads.get(p).add(head);
        }
        int c=0;
        for (        Entry<Integer,List<StreamNode>> headGroup : parallelismToHeads.entrySet()) {
          List<StreamNode> headOpsInGroup=headGroup.getValue();
          Tuple2<StreamNode,StreamNode> sourceSinkPair=createItSourceAndSink(loop,c);
          StreamNode source=sourceSinkPair.f0;
          StreamNode sink=sourceSinkPair.f1;
          for (          StreamNode head : headOpsInGroup) {
            int inputType=loop.isCoIteration() ? 2 : 0;
            addEdge(source.getId(),head.getId(),new RebalancePartitioner(true),inputType,new ArrayList<String>());
          }
          for (int i=0; i < tailOps.size(); i++) {
            StreamNode tail=tailOps.get(i);
            StreamPartitioner<?> partitioner=loop.getTailPartitioners().get(i);
            addEdge(tail.getId(),sink.getId(),partitioner.copy(),0,loop.getTailSelectedNames().get(i));
          }
          source.setParallelism(headGroup.getKey());
          sink.setParallelism(source.getParallelism());
          setSerializersFrom(tailOps.get(0).getId(),sink.getId());
          if (loop.isCoIteration()) {
            source.setSerializerOut(new StreamRecordSerializer(loop.getFeedbackType(),executionConfig));
          }
 else {
            setSerializersFrom(headOpsInGroup.get(0).getId(),source.getId());
          }
          c++;
        }
      }
 else {
        Tuple2<StreamNode,StreamNode> sourceSinkPair=createItSourceAndSink(loop,0);
        StreamNode source=sourceSinkPair.f0;
        StreamNode sink=sourceSinkPair.f1;
        StreamPartitioner<?> partitioner=headOps.get(0).getInEdges().get(0).getPartitioner();
        for (        StreamNode head : headOps) {
          addEdge(source.getId(),head.getId(),partitioner.copy(),0,new ArrayList<String>());
        }
        for (int i=0; i < tailOps.size(); i++) {
          StreamNode tail=tailOps.get(i);
          addEdge(tail.getId(),sink.getId(),new RebalancePartitioner(true),0,loop.getTailSelectedNames().get(i));
        }
        sink.setParallelism(tailOps.get(0).getParallelism());
        source.setParallelism(sink.getParallelism());
        setSerializersFrom(headOps.get(0).getId(),source.getId());
        setSerializersFrom(tailOps.get(0).getId(),sink.getId());
      }
    }
  }
}
