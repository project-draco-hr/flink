{
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  final Class<Key> keyClass=stub.getInKeyType();
  final Class<Value> valueClass=stub.getInValueType();
  final SerializationFactory<Key> keySerialization=new WritableSerializationFactory<Key>(keyClass);
  final SerializationFactory<Value> valSerialization=new WritableSerializationFactory<Value>(valueClass);
switch (config.getLocalStrategy()) {
case NONE:
{
      Iterator<KeyValuePair<Key,Value>> iter=new Iterator<KeyValuePair<Key,Value>>(){
        @Override public boolean hasNext(){
          return reader.hasNext();
        }
        @Override public KeyValuePair<Key,Value> next(){
          try {
            return reader.next();
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
        @Override public void remove(){
        }
      }
;
      return new SimpleCloseableInputProvider<KeyValuePair<Key,Value>>(iter);
    }
case SORT:
{
    final Comparator<Key> keyComparator=new Comparator<Key>(){
      @Override public int compare(      Key k1,      Key k2){
        return k1.compareTo(k2);
      }
    }
;
    try {
      SortMerger<Key,Value> sortMerger=new UnilateralSortMerger<Key,Value>(memoryManager,ioManager,this.availableMemory,this.maxFileHandles,keySerialization,valSerialization,keyComparator,reader,this,this.spillThreshold);
      return sortMerger;
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException("MemoryManager is not able to provide the required amount of memory for ReduceTask",mae);
    }
catch (    IOException ioe) {
      throw new RuntimeException("IOException caught when obtaining SortMerger for ReduceTask",ioe);
    }
  }
case COMBININGSORT:
{
  final Comparator<Key> keyComparator=new Comparator<Key>(){
    @Override public int compare(    Key k1,    Key k2){
      return k1.compareTo(k2);
    }
  }
;
  try {
    SortMerger<Key,Value> sortMerger=new CombiningUnilateralSortMerger<Key,Value>(stub,memoryManager,ioManager,this.availableMemory,this.maxFileHandles,keySerialization,valSerialization,keyComparator,reader,this,this.spillThreshold,false);
    return sortMerger;
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException("MemoryManager is not able to provide the required amount of memory for ReduceTask",mae);
  }
catch (  IOException ioe) {
    throw new RuntimeException("IOException caught when obtaining SortMerger for ReduceTask",ioe);
  }
}
default :
throw new RuntimeException("Invalid local strategy provided for ReduceTask.");
}
}
