{
  final long availableMemory=this.config.getMemorySize();
  final int maxFileHandles=this.config.getNumFilehandles();
  final float spillThreshold=this.config.getSortSpillingTreshold();
  final LocalStrategy ls=this.config.getLocalStrategy();
  if ((ls == LocalStrategy.SORT || ls == LocalStrategy.COMBININGSORT) && availableMemory < MIN_REQUIRED_MEMORY) {
    throw new Exception("The Reduce task was initialized with too little memory for local strategy " + this.config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ MIN_REQUIRED_MEMORY+ " bytes.");
  }
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  final MutableObjectIterator<IT> in=getInput(0);
  this.serializer=getInputSerializer(0);
  this.comparator=getInputComparator(0);
switch (config.getLocalStrategy()) {
case NONE:
    this.input=new SimpleCloseableInputProvider<IT>(in);
  break;
case SORT:
this.input=new UnilateralSortMerger<IT>(memoryManager,ioManager,in,this,this.serializer,this.comparator.duplicate(),availableMemory,maxFileHandles,spillThreshold);
break;
case COMBININGSORT:
this.input=new CombiningUnilateralSortMerger<IT>(this.stub,memoryManager,ioManager,in,this,this.serializer,this.comparator.duplicate(),availableMemory,maxFileHandles,spillThreshold,false);
break;
default :
throw new Exception("Invalid local strategy provided for ReduceTask: " + ls.name());
}
}
