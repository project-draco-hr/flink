{
  final int degOfPar=defaultParallelism;
  FileDataSourceContract<PactInteger,PactInteger> source=new FileDataSourceContract<PactInteger,PactInteger>(DummyInputFormat.class,IN_FILE_1,"Source");
  source.setDegreeOfParallelism(degOfPar);
  MapContract<PactInteger,PactInteger,PactInteger,PactInteger> map1=new MapContract<PactInteger,PactInteger,PactInteger,PactInteger>(IdentityMap.class,"Map1");
  map1.setDegreeOfParallelism(degOfPar);
  map1.addInput(source);
  ReduceContract<PactInteger,PactInteger,PactInteger,PactInteger> reduce1=new ReduceContract<PactInteger,PactInteger,PactInteger,PactInteger>(IdentityReduce.class,"Reduce 1");
  reduce1.setDegreeOfParallelism(degOfPar);
  reduce1.addInput(map1);
  MapContract<PactInteger,PactInteger,PactInteger,PactInteger> map2=new MapContract<PactInteger,PactInteger,PactInteger,PactInteger>(IdentityMap.class,"Map2");
  map2.setDegreeOfParallelism(degOfPar * 2);
  map2.addInput(reduce1);
  ReduceContract<PactInteger,PactInteger,PactInteger,PactInteger> reduce2=new ReduceContract<PactInteger,PactInteger,PactInteger,PactInteger>(IdentityReduce.class,"Reduce 2");
  reduce2.setDegreeOfParallelism(degOfPar * 2);
  reduce2.addInput(map2);
  FileDataSinkContract<PactInteger,PactInteger> sink=new FileDataSinkContract<PactInteger,PactInteger>(DummyOutputFormat.class,OUT_FILE_1,"Sink");
  sink.setDegreeOfParallelism(degOfPar * 2);
  sink.addInput(reduce2);
  Plan plan=new Plan(sink,"Test Increasing Degree Of Parallelism");
  OptimizedPlan oPlan=this.compiler.compile(plan,this.instanceType);
  DataSinkNode sinkNode=oPlan.getDataSinks().iterator().next();
  ReduceNode red2Node=(ReduceNode)sinkNode.getInputConnections().get(0).getSourcePact();
  MapNode map2Node=(MapNode)red2Node.getInputConnections().get(0).getSourcePact();
  Assert.assertEquals("The Reduce 1 Node has an invalid shipping strategy.",ShipStrategy.PARTITION_LOCAL_HASH,map2Node.getInputConnections().get(0).getShipStrategy());
}
