{
  final String[] requiredLibraries=LibraryCacheManager.getRequiredJarFiles(jobID);
  if (requiredLibraries == null) {
    throw new IOException("No entry of required libraries for job " + jobID);
  }
  LibraryCacheProfileRequest request=new LibraryCacheProfileRequest();
  request.setRequiredLibraries(requiredLibraries);
  Future<Object> futureResponse=Patterns.ask(taskManager,new TaskManagerMessages.RequestLibraryCacheProfile(request),AkkaUtils.FUTURE_TIMEOUT());
  Future<Iterable<Object>> updateFuture=futureResponse.flatMap(new Mapper<Object,Future<Iterable<Object>>>(){
    public Future<Iterable<Object>> apply(    final Object o){
      LibraryCacheProfileResponse response=(LibraryCacheProfileResponse)o;
      List<Future<Object>> futureAcks=new ArrayList<Future<Object>>();
      for (int i=0; i < requiredLibraries.length; i++) {
        if (!response.isCached(i)) {
          LibraryCacheUpdate update=new LibraryCacheUpdate(requiredLibraries[i]);
          Future<Object> future=Patterns.ask(taskManager,update,AkkaUtils.FUTURE_TIMEOUT());
          futureAcks.add(future);
        }
      }
      return Futures.sequence(futureAcks,ExecutionContexts.global());
    }
  }
,ExecutionContexts.global());
  try {
    Await.result(updateFuture,AkkaUtils.AWAIT_DURATION());
  }
 catch (  IOException ioe) {
    throw ioe;
  }
catch (  Exception e) {
    throw new RuntimeException("Encountered exception while updating library cache.",e);
  }
}
