{
  if (convertedNodes.containsKey(root))   return convertedNodes.get(root);
  NodeConverterInfo<InputType,OutputType> converterInfo=this.getNodeConverterInfo(root.getClass());
  for (  GraphConversionListener<InputType,OutputType> listener : this.conversionListener)   listener.beforeSubgraphConversion(root);
  List<OutputType> childTypes=new ArrayList<OutputType>();
  if (converterInfo == null || !converterInfo.isStopRecursion())   for (  InputType child : navigator.getConnectedNodes(root)) {
    OutputType handledResult=this.convertGraph(child,navigator);
    if (this.flattenCollection && handledResult instanceof Collection<?>)     childTypes.addAll((Collection<? extends OutputType>)handledResult);
 else     if (handledResult != null)     childTypes.add(handledResult);
  }
  childTypes.addAll(this.lastChildren);
  this.lastChildren=converterInfo != null && converterInfo.shouldAppendChildren() ? childTypes.subList(converterInfo.getAppendIndex(),childTypes.size()) : Collections.EMPTY_LIST;
  OutputType convertedType=this.convertNode(root,childTypes);
  for (  GraphConversionListener<InputType,OutputType> listener : this.conversionListener)   listener.afterSubgraphConversion(root,convertedType);
  if (convertedType == null)   return childTypes.isEmpty() ? null : childTypes.get(0);
  return convertedType;
}
