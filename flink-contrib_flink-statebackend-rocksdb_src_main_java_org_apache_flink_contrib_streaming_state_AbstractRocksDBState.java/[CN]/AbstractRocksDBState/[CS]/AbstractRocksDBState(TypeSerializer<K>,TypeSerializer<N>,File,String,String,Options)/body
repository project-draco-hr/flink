{
  rocksDbPath=new File(basePath,"db" + UUID.randomUUID().toString());
  hadoopConfPath=new File(basePath,HADOOP_CONF_NAME);
  RocksDB.loadLibrary();
  try {
    if (rocksDbPath.exists()) {
      LOG.warn("Deleting already existing db directory {}.",rocksDbPath);
      FileUtils.deleteDirectory(rocksDbPath);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException("Error cleaning RocksDB data directory.",e);
  }
  try (BackupEngine backupEngine=BackupEngine.open(Env.getDefault(),new BackupableDBOptions(restorePath + "/"))){
    backupEngine.restoreDbFromLatestBackup(rocksDbPath.getAbsolutePath(),rocksDbPath.getAbsolutePath(),new RestoreOptions(true));
  }
 catch (  RocksDBException|IllegalArgumentException e) {
    throw new RuntimeException("Error while restoring RocksDB state from " + restorePath,e);
  }
 finally {
    try {
      FileUtils.deleteDirectory(new File(restorePath));
    }
 catch (    IOException e) {
      LOG.error("Error cleaning up local restore directory " + restorePath,e);
    }
  }
  this.keySerializer=requireNonNull(keySerializer);
  this.namespaceSerializer=namespaceSerializer;
  this.basePath=basePath;
  this.checkpointPath=checkpointPath;
  if (!basePath.exists()) {
    if (!basePath.mkdirs()) {
      throw new RuntimeException("Could not create RocksDB data directory.");
    }
  }
  try {
    db=RocksDB.open(options,rocksDbPath.getAbsolutePath());
  }
 catch (  RocksDBException e) {
    throw new RuntimeException("Error while opening RocksDB instance.",e);
  }
  writeHadoopConfig(hadoopConfPath);
}
