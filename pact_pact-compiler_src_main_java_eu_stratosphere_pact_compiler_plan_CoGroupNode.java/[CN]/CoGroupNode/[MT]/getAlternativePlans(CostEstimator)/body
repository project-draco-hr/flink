{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  List<OptimizerNode> allPreds1=new ArrayList<OptimizerNode>(this.input1.size());
  for (  PactConnection c : this.input1) {
    allPreds1.add(c.getSourcePact());
  }
  List<OptimizerNode> allPreds2=new ArrayList<OptimizerNode>(this.input2.size());
  for (  PactConnection c : this.input2) {
    allPreds2.add(c.getSourcePact());
  }
  List<CoGroupNode> outputPlans=new ArrayList<CoGroupNode>();
  for (  PactConnection c : this.input1) {
    List<? extends OptimizerNode> inPlans1=c.getSourcePact().getAlternativePlans(estimator);
    for (    PactConnection cc : this.input2) {
      List<? extends OptimizerNode> inPlans2=cc.getSourcePact().getAlternativePlans(estimator);
      for (      OptimizerNode pred1 : inPlans1) {
        for (        OptimizerNode pred2 : inPlans2) {
          if (!areBranchCompatible(pred1,pred2)) {
            continue;
          }
          ShipStrategy ss1=c.getShipStrategy();
          ShipStrategy ss2=cc.getShipStrategy();
          GlobalProperties gp1;
          GlobalProperties gp2;
          if (ss1 == ShipStrategy.NONE) {
            gp1=pred1.getGlobalProperties();
            if (ss2 == ShipStrategy.NONE) {
              gp2=pred2.getGlobalProperties();
              if (gp1.getPartitioning().isComputablyPartitioned()) {
                ss1=ShipStrategy.FORWARD;
              }
              if (gp2.getPartitioning().isComputablyPartitioned()) {
                if ((!gp1.getPartitioning().isComputablyPartitioned()) || gp1.getPartitioning() == gp2.getPartitioning()) {
                  ss2=ShipStrategy.FORWARD;
                }
 else {
                  if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                    createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator,allPreds1,allPreds2);
                    createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator,allPreds1,allPreds2);
                  }
 else                   if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                    createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator,allPreds1,allPreds2);
                    createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator,allPreds1,allPreds2);
                  }
                  continue;
                }
              }
              if (ss1 == ShipStrategy.FORWARD) {
                if (ss2 == ShipStrategy.FORWARD) {
                  createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator,allPreds1,allPreds2);
                  if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                  }
                }
 else {
                  if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                    createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator,allPreds1,allPreds2);
                  }
 else                   if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                    createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator,allPreds1,allPreds2);
                    createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator,allPreds1,allPreds2);
                  }
 else {
                    throw new CompilerException("Invalid partitioning property for input 1 of CoGroup '" + getPactContract().getName() + "'.");
                  }
                }
              }
 else               if (ss2 == ShipStrategy.FORWARD) {
                if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator,allPreds1,allPreds2);
                }
 else                 if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator,allPreds1,allPreds2);
                  createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator,allPreds1,allPreds2);
                }
 else {
                  throw new CompilerException("Invalid partitioning property for input 2 of CoGroup '" + getPactContract().getName() + "'.");
                }
              }
 else {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator,allPreds1,allPreds2);
              }
            }
 else {
              gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
switch (ss2) {
case FORWARD:
                if (gp2.getPartitioning().isPartitioned()) {
                  if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                    ss1=ShipStrategy.PARTITION_HASH;
                  }
 else                   if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                    ss1=ShipStrategy.PARTITION_RANGE;
                  }
 else {
                    throw new CompilerException();
                  }
                }
 else {
                  continue;
                }
              break;
case PARTITION_HASH:
            ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
          break;
case PARTITION_RANGE:
        ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
      break;
default :
    throw new CompilerException("Invalid fixed shipping strategy '" + ss2.name() + "' for CoGroup contract '"+ getPactContract().getName()+ "'.");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator,allPreds1,allPreds2);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
  if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
    ss2=ShipStrategy.PARTITION_HASH;
  }
 else   if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
    ss2=ShipStrategy.PARTITION_RANGE;
  }
 else {
    throw new CompilerException();
  }
}
 else {
  continue;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException("Invalid fixed shipping strategy '" + ss1.name() + "' for match contract '"+ getPactContract().getName()+ "'.");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator,allPreds1,allPreds2);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator,allPreds1,allPreds2);
}
 else {
continue;
}
}
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException("Could not create a valid plan for the reduce contract '" + getPactContract().getName() + "'. The compiler hints specified incompatible shipping strategies.");
}
prunePlanAlternatives(outputPlans);
if (isBranching()) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}
