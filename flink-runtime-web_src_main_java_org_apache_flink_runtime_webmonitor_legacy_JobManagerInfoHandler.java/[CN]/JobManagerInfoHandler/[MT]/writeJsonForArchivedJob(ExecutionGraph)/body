{
  StringBuilder bld=new StringBuilder();
  bld.append("[");
  bld.append("{");
  bld.append("\"jobid\": \"").append(graph.getJobID()).append("\",");
  bld.append("\"jobname\": \"").append(graph.getJobName()).append("\",");
  bld.append("\"status\": \"").append(graph.getState()).append("\",");
  bld.append("\"SCHEDULED\": ").append(graph.getStatusTimestamp(JobStatus.CREATED)).append(",");
  bld.append("\"RUNNING\": ").append(graph.getStatusTimestamp(JobStatus.RUNNING)).append(",");
  bld.append("\"FINISHED\": ").append(graph.getStatusTimestamp(JobStatus.FINISHED)).append(",");
  bld.append("\"FAILED\": ").append(graph.getStatusTimestamp(JobStatus.FAILED)).append(",");
  bld.append("\"CANCELED\": ").append(graph.getStatusTimestamp(JobStatus.CANCELED)).append(",");
  if (graph.getState() == JobStatus.FAILED) {
    bld.append("\"failednodes\": [");
    boolean first=true;
    for (    ExecutionVertex vertex : graph.getAllExecutionVertices()) {
      if (vertex.getExecutionState() == ExecutionState.FAILED) {
        InstanceConnectionInfo location=vertex.getCurrentAssignedResourceLocation();
        Throwable failureCause=vertex.getFailureCause();
        if (location != null || failureCause != null) {
          if (first) {
            first=false;
          }
 else {
            bld.append(",");
          }
          bld.append("{");
          bld.append("\"node\": \"").append(location == null ? "(none)" : location.getFQDNHostname()).append("\",");
          bld.append("\"message\": \"").append(failureCause == null ? "" : StringUtils.escapeHtml(ExceptionUtils.stringifyException(failureCause))).append("\"");
          bld.append("}");
        }
      }
    }
    bld.append("],");
  }
  bld.append("\"groupvertices\": [");
  boolean first=true;
  for (  ExecutionJobVertex groupVertex : graph.getVerticesTopologically()) {
    if (first) {
      first=false;
    }
 else {
      bld.append(",");
    }
    bld.append(JsonFactory.toJson(groupVertex));
  }
  bld.append("],");
  ExecutionConfig ec=graph.getExecutionConfig();
  if (ec != null) {
    bld.append("\"executionConfig\": {");
    bld.append("\"Execution Mode\": \"").append(ec.getExecutionMode()).append("\",");
    bld.append("\"Number of execution retries\": \"").append(ec.getNumberOfExecutionRetries()).append("\",");
    bld.append("\"Job parallelism\": \"").append(ec.getParallelism()).append("\",");
    bld.append("\"Object reuse mode\": \"").append(ec.isObjectReuseEnabled()).append("\"");
    ExecutionConfig.GlobalJobParameters uc=ec.getGlobalJobParameters();
    if (uc != null) {
      Map<String,String> ucVals=uc.toMap();
      if (ucVals != null) {
        String ucString="{";
        int i=0;
        for (        Map.Entry<String,String> ucVal : ucVals.entrySet()) {
          ucString+="\"" + ucVal.getKey() + "\":\""+ ucVal.getValue()+ "\"";
          if (++i < ucVals.size()) {
            ucString+=",\n";
          }
        }
        bld.append(", \"userConfig\": ").append(ucString).append("}");
      }
 else {
        LOG.debug("GlobalJobParameters.toMap() did not return anything");
      }
    }
 else {
      LOG.debug("No GlobalJobParameters were set in the execution config");
    }
    bld.append("},");
  }
 else {
    LOG.warn("Unable to retrieve execution config from execution graph");
  }
  final Future<Object> response=Patterns.ask(jobmanager,new RequestAccumulatorResultsStringified(graph.getJobID()),new Timeout(timeout));
  Object result;
  try {
    result=Await.result(response,timeout);
  }
 catch (  Exception ex) {
    throw new RuntimeException("Could not retrieve the accumulator results from the job manager.",ex);
  }
  if (result instanceof AccumulatorResultStringsFound) {
    StringifiedAccumulatorResult[] accumulators=((AccumulatorResultStringsFound)result).result();
    bld.append("\n\"accumulators\": [");
    int i=0;
    for (    StringifiedAccumulatorResult accumulator : accumulators) {
      bld.append("{ \"name\": \"").append(accumulator.getName()).append(" (").append(accumulator.getType()).append(")\",").append(" \"value\": \"").append(accumulator.getValue()).append("\"}\n");
      if (++i < accumulators.length) {
        bld.append(",");
      }
    }
    bld.append("],\n");
  }
 else   if (result instanceof AccumulatorResultsNotFound) {
    bld.append("\n\"accumulators\": [],");
  }
 else   if (result instanceof AccumulatorResultsErroneous) {
    LOG.error("Could not obtain accumulators for job " + graph.getJobID(),((AccumulatorResultsErroneous)result).cause());
  }
 else {
    throw new RuntimeException("RequestAccumulatorResults requires a response of type " + "AccumulatorResultStringsFound. Instead the response is of type " + result.getClass() + ".");
  }
  bld.append("\"groupverticetimes\": {");
  first=true;
  for (  ExecutionJobVertex groupVertex : graph.getVerticesTopologically()) {
    if (first) {
      first=false;
    }
 else {
      bld.append(",");
    }
    long started=Long.MAX_VALUE;
    long ended=0;
    for (    ExecutionVertex vertex : groupVertex.getTaskVertices()) {
      long running=vertex.getStateTimestamp(ExecutionState.RUNNING);
      if (running != 0 && running < started) {
        started=running;
      }
      long finished=vertex.getStateTimestamp(ExecutionState.FINISHED);
      long canceled=vertex.getStateTimestamp(ExecutionState.CANCELED);
      long failed=vertex.getStateTimestamp(ExecutionState.FAILED);
      if (finished != 0 && finished > ended) {
        ended=finished;
      }
      if (canceled != 0 && canceled > ended) {
        ended=canceled;
      }
      if (failed != 0 && failed > ended) {
        ended=failed;
      }
    }
    bld.append("\"").append(groupVertex.getJobVertexId()).append("\": {");
    bld.append("\"groupvertexid\": \"").append(groupVertex.getJobVertexId()).append("\",");
    bld.append("\"groupvertexname\": \"").append(groupVertex).append("\",");
    bld.append("\"STARTED\": ").append(started).append(",");
    bld.append("\"ENDED\": ").append(ended);
    bld.append("}");
  }
  bld.append("}");
  bld.append("}");
  bld.append("]");
  return bld.toString();
}
