{
  if ("archive".equals(routed.queryParam("get"))) {
    Future<Object> response=Patterns.ask(archive,ArchiveMessages.getRequestArchivedJobs(),new Timeout(timeout));
    Object result=Await.result(response,timeout);
    if (!(result instanceof ArchiveMessages.ArchivedJobs)) {
      throw new RuntimeException("RequestArchiveJobs requires a response of type " + "ArchivedJobs. Instead the response is of type " + result.getClass() + ".");
    }
 else {
      final List<ExecutionGraph> archivedJobs=new ArrayList<ExecutionGraph>(((ArchiveMessages.ArchivedJobs)result).asJavaCollection());
      return writeJsonForArchive(archivedJobs);
    }
  }
 else   if ("jobcounts".equals(routed.queryParam("get"))) {
    Future<Object> response=Patterns.ask(archive,ArchiveMessages.getRequestJobCounts(),new Timeout(timeout));
    Object result=Await.result(response,timeout);
    if (!(result instanceof Tuple3)) {
      throw new RuntimeException("RequestJobCounts requires a response of type " + "Tuple3. Instead the response is of type " + result.getClass() + ".");
    }
 else {
      return writeJsonForJobCounts((Tuple3<Integer,Integer,Integer>)result);
    }
  }
 else   if ("job".equals(routed.queryParam("get"))) {
    String jobId=routed.queryParam("job");
    Future<Object> response=Patterns.ask(archive,new JobManagerMessages.RequestJob(JobID.fromHexString(jobId)),new Timeout(timeout));
    Object result=Await.result(response,timeout);
    if (!(result instanceof JobManagerMessages.JobResponse)) {
      throw new RuntimeException("RequestJob requires a response of type JobResponse. " + "Instead the response is of type " + result.getClass());
    }
 else {
      final JobManagerMessages.JobResponse jobResponse=(JobManagerMessages.JobResponse)result;
      if (jobResponse instanceof JobManagerMessages.JobFound) {
        ExecutionGraph archivedJob=((JobManagerMessages.JobFound)result).executionGraph();
        return writeJsonForArchivedJob(archivedJob);
      }
 else {
        throw new Exception("DoGet:job: Could not find job for job ID " + jobId);
      }
    }
  }
 else   if ("groupvertex".equals(routed.queryParam("get"))) {
    String jobId=routed.queryParam("job");
    String groupVertexId=routed.queryParam("groupvertex");
    if (groupVertexId.equals("null")) {
      throw new Exception("Found null groupVertexId");
    }
    Future<Object> response=Patterns.ask(archive,new JobManagerMessages.RequestJob(JobID.fromHexString(jobId)),new Timeout(timeout));
    Object result=Await.result(response,timeout);
    if (!(result instanceof JobManagerMessages.JobResponse)) {
      throw new RuntimeException("RequestJob requires a response of type JobResponse. " + "Instead the response is of type " + result.getClass());
    }
 else {
      final JobManagerMessages.JobResponse jobResponse=(JobManagerMessages.JobResponse)result;
      if (jobResponse instanceof JobManagerMessages.JobFound) {
        ExecutionGraph archivedJob=((JobManagerMessages.JobFound)jobResponse).executionGraph();
        return writeJsonForArchivedJobGroupvertex(archivedJob,JobVertexID.fromHexString(groupVertexId));
      }
 else {
        throw new Exception("DoGet:groupvertex: Could not find job for job ID " + jobId);
      }
    }
  }
 else   if ("taskmanagers".equals(routed.queryParam("get"))) {
    Future<Object> response=Patterns.ask(jobmanager,JobManagerMessages.getRequestNumberRegisteredTaskManager(),new Timeout(timeout));
    Object result=Await.result(response,timeout);
    if (!(result instanceof Integer)) {
      throw new RuntimeException("RequestNumberRegisteredTaskManager requires a " + "response of type Integer. Instead the response is of type " + result.getClass() + ".");
    }
 else {
      final int numberOfTaskManagers=(Integer)result;
      final Future<Object> responseRegisteredSlots=Patterns.ask(jobmanager,JobManagerMessages.getRequestTotalNumberOfSlots(),new Timeout(timeout));
      final Object resultRegisteredSlots=Await.result(responseRegisteredSlots,timeout);
      if (!(resultRegisteredSlots instanceof Integer)) {
        throw new RuntimeException("RequestTotalNumberOfSlots requires a response of " + "type Integer. Instaed the response of type " + resultRegisteredSlots.getClass() + ".");
      }
 else {
        final int numberOfRegisteredSlots=(Integer)resultRegisteredSlots;
        return "{\"taskmanagers\": " + numberOfTaskManagers + ", "+ "\"slots\": "+ numberOfRegisteredSlots+ "}";
      }
    }
  }
 else   if ("cancel".equals(routed.queryParam("get"))) {
    String jobId=routed.queryParam("job");
    Future<Object> response=Patterns.ask(jobmanager,new JobManagerMessages.CancelJob(JobID.fromHexString(jobId)),new Timeout(timeout));
    Await.ready(response,timeout);
    return "{}";
  }
 else   if ("updates".equals(routed.queryParam("get"))) {
    String jobId=routed.queryParam("job");
    return writeJsonUpdatesForJob(JobID.fromHexString(jobId));
  }
 else   if ("version".equals(routed.queryParam("get"))) {
    return writeJsonForVersion();
  }
 else {
    Future<Object> response=Patterns.ask(jobmanager,JobManagerMessages.getRequestRunningJobs(),new Timeout(timeout));
    Object result=Await.result(response,timeout);
    if (!(result instanceof JobManagerMessages.RunningJobs)) {
      throw new RuntimeException("RequestRunningJobs requires a response of type " + "RunningJobs. Instead the response of type " + result.getClass() + ".");
    }
 else {
      final Iterable<ExecutionGraph> runningJobs=((JobManagerMessages.RunningJobs)result).asJavaIterable();
      return writeJsonForJobs(runningJobs);
    }
  }
}
