{
  if (LOG.isInfoEnabled())   LOG.info(getLogString("Start PACT code"));
  final UnilateralSortMerger<IT> sorter;
  if (this.config.getLocalStrategy() == LocalStrategy.SORT) {
    final Class<? extends TypeComparatorFactory<IT>> comparatorFactoryClass=this.config.getComparatorFactoryForInput(0,this.userCodeClassLoader);
    final TypeComparatorFactory<IT> comparatorFactory;
    if (comparatorFactoryClass == null) {
      @SuppressWarnings("unchecked") TypeComparatorFactory<IT> cf=(TypeComparatorFactory<IT>)PactRecordComparatorFactory.get();
      comparatorFactory=cf;
    }
 else {
      comparatorFactory=InstantiationUtil.instantiate(comparatorFactoryClass,TypeComparatorFactory.class);
    }
    TypeComparator<IT> comparator;
    try {
      comparator=comparatorFactory.createComparator(getTaskConfiguration(),this.config.getPrefixForInputParameters(0),this.userCodeClassLoader);
    }
 catch (    ClassNotFoundException cnfex) {
      throw new Exception("The instantiation of the type comparator from factory '" + comparatorFactory.getClass().getName() + "' failed. A referenced class from the user code could not be loaded.");
    }
    final long availableMemory=this.config.getMemorySize();
    final int maxFileHandles=this.config.getNumFilehandles();
    final float spillThreshold=this.config.getSortSpillingTreshold();
    sorter=new UnilateralSortMerger<IT>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),this.reader,this,this.inputTypeSerializer,comparator,availableMemory,maxFileHandles,spillThreshold);
    this.reader=sorter.getIterator();
  }
 else {
    sorter=null;
  }
  try {
    final MutableObjectIterator<IT> reader=this.reader;
    final OutputFormat<IT> format=this.format;
    final IT record=this.inputTypeSerializer.createInstance();
    if (this.taskCanceled) {
      return;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(getLogString("Starting to produce output"));
    }
    format.open(this.getEnvironment().getIndexInSubtaskGroup() + 1);
    if (record.getClass() == PactRecord.class && format instanceof FileOutputFormat) {
      @SuppressWarnings("unchecked") final MutableObjectIterator<PactRecord> pi=(MutableObjectIterator<PactRecord>)reader;
      final PactRecord pr=(PactRecord)record;
      final FileOutputFormat pf=(FileOutputFormat)format;
      while (!this.taskCanceled && pi.next(pr)) {
        pf.writeRecord(pr);
      }
    }
 else {
      while (!this.taskCanceled && reader.next(record)) {
        format.writeRecord(record);
      }
    }
    if (!this.taskCanceled) {
      this.format.close();
      this.format=null;
    }
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      if (LOG.isErrorEnabled())       LOG.error(getLogString("Error in Pact user code: " + ex.getMessage()),ex);
      throw ex;
    }
  }
 finally {
    if (this.format != null) {
      try {
        this.format.close();
      }
 catch (      Throwable t) {
        if (LOG.isWarnEnabled())         LOG.warn(getLogString("Error closing the ouput format."),t);
      }
    }
    if (sorter != null) {
      sorter.close();
    }
  }
  if (!this.taskCanceled) {
    if (LOG.isDebugEnabled())     LOG.debug(getLogString("Finished producing output"));
    if (LOG.isInfoEnabled())     LOG.info(getLogString("Finished PACT code"));
  }
 else {
    if (LOG.isWarnEnabled())     LOG.warn(getLogString("PACT code cancelled"));
  }
}
