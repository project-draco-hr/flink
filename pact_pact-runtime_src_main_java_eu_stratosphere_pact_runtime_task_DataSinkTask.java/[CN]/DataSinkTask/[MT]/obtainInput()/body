{
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  final Class<Key> keyClass=format.getKeyType();
  final Class<Value> valueClass=format.getValueType();
  final SerializationFactory<Key> keySerialization=new WritableSerializationFactory<Key>(keyClass);
  final SerializationFactory<Value> valSerialization=new WritableSerializationFactory<Value>(valueClass);
switch (config.getLocalStrategy()) {
case NONE:
{
      Iterator<KeyValuePair<Key,Value>> iter=new Iterator<KeyValuePair<Key,Value>>(){
        @Override public boolean hasNext(){
          return reader.hasNext();
        }
        @Override public KeyValuePair<Key,Value> next(){
          try {
            return reader.next();
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
        @Override public void remove(){
        }
      }
;
      return new SimpleCloseableInputProvider<KeyValuePair<Key,Value>>(iter);
    }
case SORT:
{
    final Order sortOrder=Order.valueOf(config.getStubParameters().getString(SORT_ORDER,""));
    final Comparator<Key> keyComparator;
    if (sortOrder == Order.ASCENDING || sortOrder == Order.ANY) {
      keyComparator=new Comparator<Key>(){
        @Override public int compare(        Key k1,        Key k2){
          return k1.compareTo(k2);
        }
      }
;
    }
 else {
      keyComparator=new Comparator<Key>(){
        @Override public int compare(        Key k1,        Key k2){
          return k2.compareTo(k1);
        }
      }
;
    }
    try {
      SortMerger<Key,Value> sortMerger=new UnilateralSortMerger<Key,Value>(memoryManager,ioManager,this.availableMemory,this.maxFileHandles,keySerialization,valSerialization,keyComparator,reader,this,this.spillThreshold);
      return sortMerger;
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException("MemoryManager is not able to provide the required amount of memory for ReduceTask",mae);
    }
catch (    IOException ioe) {
      throw new RuntimeException("IOException caught when obtaining SortMerger for ReduceTask",ioe);
    }
  }
default :
throw new RuntimeException("Invalid local strategy provided for ReduceTask.");
}
}
