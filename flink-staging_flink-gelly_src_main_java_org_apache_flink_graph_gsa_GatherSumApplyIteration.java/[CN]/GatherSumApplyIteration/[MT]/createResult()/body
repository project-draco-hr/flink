{
  if (vertexDataSet == null) {
    throw new IllegalStateException("The input data set has not been set.");
  }
  TypeInformation<K> keyType=((TupleTypeInfo<?>)vertexDataSet.getType()).getTypeAt(0);
  TypeInformation<M> messageType=TypeExtractor.createTypeInfo(GatherFunction.class,gather.getClass(),2,null,null);
  TypeInformation<Tuple2<K,M>> innerType=new TupleTypeInfo<Tuple2<K,M>>(keyType,messageType);
  TypeInformation<Vertex<K,VV>> outputType=vertexDataSet.getType();
  Graph<K,VV,EV> graph=Graph.fromDataSet(vertexDataSet,edgeDataSet,ExecutionEnvironment.getExecutionEnvironment());
  if (this.configuration != null && this.configuration.isOptNumVertices()) {
    try {
      long numberOfVertices=graph.numberOfVertices();
      gather.setNumberOfVertices(numberOfVertices);
      sum.setNumberOfVertices(numberOfVertices);
      apply.setNumberOfVertices(numberOfVertices);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  GatherUdf<K,VV,EV,M> gatherUdf=new GatherUdf<K,VV,EV,M>(gather,innerType);
  SumUdf<K,VV,EV,M> sumUdf=new SumUdf<K,VV,EV,M>(sum,innerType);
  ApplyUdf<K,VV,EV,M> applyUdf=new ApplyUdf<K,VV,EV,M>(apply,outputType);
  final int[] zeroKeyPos=new int[]{0};
  final DeltaIteration<Vertex<K,VV>,Vertex<K,VV>> iteration=vertexDataSet.iterateDelta(vertexDataSet,maximumNumberOfIterations,zeroKeyPos);
  if (this.configuration != null) {
    iteration.name(this.configuration.getName("Gather-sum-apply iteration (" + gather + " | "+ sum+ " | "+ apply+ ")"));
    iteration.parallelism(this.configuration.getParallelism());
    iteration.setSolutionSetUnManaged(this.configuration.isSolutionSetUnmanagedMemory());
    for (    Map.Entry<String,Aggregator<?>> entry : this.configuration.getAggregators().entrySet()) {
      iteration.registerAggregator(entry.getKey(),entry.getValue());
    }
  }
 else {
    iteration.name("Gather-sum-apply iteration (" + gather + " | "+ sum+ " | "+ apply+ ")");
  }
  DataSet<Tuple2<K,Neighbor<VV,EV>>> neighbors=iteration.getWorkset().join(edgeDataSet).where(0).equalTo(0).with(new ProjectKeyWithNeighbor<K,VV,EV>());
  MapOperator<Tuple2<K,Neighbor<VV,EV>>,Tuple2<K,M>> gatherMapOperator=neighbors.map(gatherUdf);
  gatherMapOperator=gatherMapOperator.name("Gather");
  if (this.configuration != null) {
    for (    Tuple2<String,DataSet<?>> e : this.configuration.getGatherBcastVars()) {
      gatherMapOperator=gatherMapOperator.withBroadcastSet(e.f1,e.f0);
    }
  }
  DataSet<Tuple2<K,M>> gatheredSet=gatherMapOperator;
  ReduceOperator<Tuple2<K,M>> sumReduceOperator=gatheredSet.groupBy(0).reduce(sumUdf);
  sumReduceOperator=sumReduceOperator.name("Sum");
  if (this.configuration != null) {
    for (    Tuple2<String,DataSet<?>> e : this.configuration.getSumBcastVars()) {
      sumReduceOperator=sumReduceOperator.withBroadcastSet(e.f1,e.f0);
    }
  }
  DataSet<Tuple2<K,M>> summedSet=sumReduceOperator;
  JoinOperator<?,?,Vertex<K,VV>> appliedSet=summedSet.join(iteration.getSolutionSet()).where(0).equalTo(0).with(applyUdf);
  appliedSet=appliedSet.name("Apply");
  if (this.configuration != null) {
    for (    Tuple2<String,DataSet<?>> e : this.configuration.getApplyBcastVars()) {
      appliedSet=appliedSet.withBroadcastSet(e.f1,e.f0);
    }
  }
  appliedSet.withForwardedFieldsFirst("0").withForwardedFieldsSecond("0");
  return iteration.closeWith(appliedSet,appliedSet);
}
