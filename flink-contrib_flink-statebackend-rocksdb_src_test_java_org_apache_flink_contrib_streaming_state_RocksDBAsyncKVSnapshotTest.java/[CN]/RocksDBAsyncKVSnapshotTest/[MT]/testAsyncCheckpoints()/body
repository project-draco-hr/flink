{
  final OneShotLatch delayCheckpointLatch=new OneShotLatch();
  final OneShotLatch ensureCheckpointLatch=new OneShotLatch();
  final OneInputStreamTask<String,String> task=new OneInputStreamTask<>();
  final OneInputStreamTaskTestHarness<String,String> testHarness=new OneInputStreamTaskTestHarness<>(task,BasicTypeInfo.STRING_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
  testHarness.configureForKeyedStream(new KeySelector<String,String>(){
    @Override public String getKey(    String value) throws Exception {
      return value;
    }
  }
,BasicTypeInfo.STRING_TYPE_INFO);
  StreamConfig streamConfig=testHarness.getStreamConfig();
  File dbDir=new File(new File(ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH,UUID.randomUUID().toString()),"state");
  File chkDir=new File(new File(ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH,UUID.randomUUID().toString()),"snapshots");
  RocksDBStateBackend backend=new RocksDBStateBackend(chkDir.getAbsoluteFile().toURI(),new MemoryStateBackend());
  backend.setDbStoragePath(dbDir.getAbsolutePath());
  streamConfig.setStateBackend(backend);
  streamConfig.setStreamOperator(new AsyncCheckpointOperator());
  StreamMockEnvironment mockEnv=new StreamMockEnvironment(testHarness.jobConfig,testHarness.taskConfig,testHarness.memorySize,new MockInputSplitProvider(),testHarness.bufferSize){
    @Override public void acknowledgeCheckpoint(    long checkpointId){
      super.acknowledgeCheckpoint(checkpointId);
    }
    @Override public void acknowledgeCheckpoint(    long checkpointId,    StateHandle<?> state){
      super.acknowledgeCheckpoint(checkpointId,state);
      try {
        delayCheckpointLatch.await();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      assertTrue(state instanceof StreamTaskStateList);
      StreamTaskStateList stateList=(StreamTaskStateList)state;
      StreamTaskState taskState=stateList.getState(this.getUserClassLoader())[0];
      assertEquals(1,taskState.getKvStates().size());
      assertTrue(taskState.getKvStates().get("count") instanceof AbstractRocksDBState.AbstractRocksDBSnapshot);
      ensureCheckpointLatch.trigger();
    }
  }
;
  testHarness.invoke(mockEnv);
  for (  Field field : StreamTask.class.getDeclaredFields()) {
    if (field.getName().equals("isRunning")) {
      field.setAccessible(true);
      while (!field.getBoolean(task)) {
        Thread.sleep(10);
      }
    }
  }
  testHarness.processElement(new StreamRecord<>("Wohoo",0));
  task.triggerCheckpoint(42,17);
  delayCheckpointLatch.trigger();
  ensureCheckpointLatch.await();
  testHarness.endInput();
  testHarness.waitForTaskCompletion();
}
