{
  final ScheduledExecutorService timerService=Executors.newSingleThreadScheduledExecutor();
  try {
    final CollectingOutput<Integer> out=new CollectingOutput<>();
    final Object lock=new Object();
    final StreamTask<?,?> mockTask=createMockTaskWithTimer(timerService,lock);
    WindowFunction<Integer,Integer,Integer,TimeWindow> failingFunction=new FailingFunction(100);
    final long hundredYears=100L * 365 * 24* 60* 60* 1000;
    AbstractAlignedProcessingTimeWindowOperator<Integer,Integer,Integer,?> op=new AccumulatingProcessingTimeWindowOperator<>(failingFunction,identitySelector,hundredYears,hundredYears);
    op.setup(mockTask,new StreamConfig(new Configuration()),out);
    op.open();
    for (int i=0; i < 150; i++) {
synchronized (lock) {
        op.processElement(new StreamRecord<Integer>(i));
      }
    }
    try {
      op.close();
      fail("This should fail with an exception");
    }
 catch (    Exception e) {
      assertTrue(e.getMessage().contains("Artificial Test Exception") || (e.getCause() != null && e.getCause().getMessage().contains("Artificial Test Exception")));
    }
    op.dispose();
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    timerService.shutdown();
  }
}
