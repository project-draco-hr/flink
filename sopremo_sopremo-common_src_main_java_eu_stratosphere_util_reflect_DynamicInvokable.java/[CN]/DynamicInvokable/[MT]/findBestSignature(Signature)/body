{
  MemberType member=getMember(signature);
  if (member != null)   return signature;
  int minDistance=Integer.MAX_VALUE;
  boolean ambiguous=false;
  Signature bestSignatureSoFar=null;
  for (  final Entry<Signature,MemberType> originalSignature : this.originalSignatures.entrySet()) {
    final int distance=originalSignature.getKey().getDistance(signature);
    if (distance < 0)     continue;
    if (distance < minDistance) {
      minDistance=distance;
      bestSignatureSoFar=originalSignature.getKey();
      ambiguous=false;
    }
 else     if (distance == minDistance)     ambiguous=true;
  }
  if (minDistance == Integer.MAX_VALUE)   return null;
  if (ambiguous && LOG.isWarnEnabled())   this.warnForAmbiguity(signature,minDistance);
  member=minDistance == Signature.INCOMPATIBLE ? null : this.originalSignatures.get(bestSignatureSoFar);
  this.cachedSignatures.put(bestSignatureSoFar,member);
  return bestSignatureSoFar;
}
