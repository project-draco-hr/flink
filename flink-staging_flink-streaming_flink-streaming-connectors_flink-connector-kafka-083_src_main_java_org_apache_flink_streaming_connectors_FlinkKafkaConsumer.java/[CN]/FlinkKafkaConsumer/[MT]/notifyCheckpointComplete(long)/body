{
  if (fetcher == null) {
    LOG.debug("notifyCheckpointComplete() called on uninitialized source");
    return;
  }
  if (!running) {
    LOG.debug("notifyCheckpointComplete() called on closed source");
    return;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Committing offsets externally for checkpoint {}",checkpointId);
  }
  long[] checkpointOffsets;
synchronized (pendingCheckpoints) {
    final int posInMap=pendingCheckpoints.indexOf(checkpointId);
    if (posInMap == -1) {
      LOG.warn("Received confirmation for unknown checkpoint id {}",checkpointId);
      return;
    }
    checkpointOffsets=(long[])pendingCheckpoints.remove(posInMap);
    for (int i=0; i < posInMap; i++) {
      pendingCheckpoints.remove(0);
    }
  }
  if (LOG.isInfoEnabled()) {
    LOG.info("Committing offsets {} to offset store: {}",Arrays.toString(checkpointOffsets),offsetStore);
  }
  Map<TopicPartition,Long> offsetsToCommit=new HashMap<TopicPartition,Long>();
  for (  TopicPartition tp : subscribedPartitions) {
    int partition=tp.partition();
    long offset=checkpointOffsets[partition];
    long lastCommitted=commitedOffsets[partition];
    if (offset != OFFSET_NOT_SET) {
      if (offset > lastCommitted) {
        offsetsToCommit.put(tp,offset);
        LOG.debug("Committing offset {} for partition {}",offset,partition);
      }
 else {
        LOG.debug("Ignoring offset {} for partition {} because it is already committed",offset,partition);
      }
    }
  }
  offsetHandler.commit(offsetsToCommit);
}
