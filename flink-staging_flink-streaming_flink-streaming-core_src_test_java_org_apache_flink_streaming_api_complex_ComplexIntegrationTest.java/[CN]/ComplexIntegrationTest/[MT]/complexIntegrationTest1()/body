{
  expected1="";
  for (int i=0; i < 8; i++) {
    expected1+="(10,(a,1))\n";
  }
  expected1+="(10,(a,1))";
  expected2="";
  for (int i=0; i < 18; i++) {
    expected2+="(20,(a,1))\n";
  }
  expected2+="(20,(a,1))";
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  DataStream<Tuple2<Long,Tuple2<String,Long>>> sourceStream1=env.addSource(new TupleSource()).setParallelism(1);
  IterativeStream<Tuple2<Long,Tuple2<String,Long>>> it=sourceStream1.map(new MapFunction<Tuple2<Long,Tuple2<String,Long>>,Tuple2<Long,Tuple2<String,Long>>>(){
    Tuple2<Long,Tuple2<String,Long>> result=new Tuple2<Long,Tuple2<String,Long>>(0L,new Tuple2<String,Long>("",0L));
    @Override public Tuple2<Long,Tuple2<String,Long>> map(    Tuple2<Long,Tuple2<String,Long>> value) throws Exception {
      result.f0=result.f0 + value.f0;
      result.f1=value.f1;
      return result;
    }
  }
).setParallelism(1).filter(new FilterFunction<Tuple2<Long,Tuple2<String,Long>>>(){
    @Override public boolean filter(    Tuple2<Long,Tuple2<String,Long>> value) throws Exception {
      return value.f0 < 20;
    }
  }
).iterate(5000);
  SplitDataStream<Tuple2<Long,Tuple2<String,Long>>> step=it.map(new IncrementMap()).split(new MyOutputSelector());
  it.closeWith(step.select("iterate"));
  step.select("firstOutput").writeAsText(resultPath1,FileSystem.WriteMode.OVERWRITE);
  step.select("secondOutput").writeAsText(resultPath2,FileSystem.WriteMode.OVERWRITE);
  env.execute();
}
