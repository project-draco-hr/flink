{
  final int avgSegmentSize=checkedDownCast(Math.min(totalMemory / minNumSegments,this.chunkSize));
  final int minSizeForSegmentInFirstPass=Math.max(minSegmentSize,(int)(0.65f * avgSegmentSize));
  final long limitForMultipleSegs=2L * minSizeForSegmentInFirstPass;
  if (avgSegmentSize < minSegmentSize) {
    throw new IllegalArgumentException("The requested memory cannot be distributed across the required " + "number of chunks without violating the requested minimal chunk size.");
  }
  long memoryLeft=totalMemory;
  int numMoreSegments=minNumSegments;
  boolean success=false;
  try {
    ListIterator<FreeSegmentEntry> freeSegs=this.freeSegments.listIterator();
    while (memoryLeft > 0 && freeSegs.hasNext()) {
      FreeSegmentEntry entry=freeSegs.next();
      int size=checkedDownCast(entry.end - entry.start);
      if (size >= memoryLeft) {
        final int numSegmentsToFit=numMoreSegments > 0 ? numMoreSegments : 1;
        final int segSize=checkedDownCast(memoryLeft / numSegmentsToFit);
        target.ensureCapacity(target.size() + numSegmentsToFit);
        if (numSegmentsToFit > 1) {
          for (int i=0; i < numSegmentsToFit - 1; i++) {
            final MemorySegmentDescriptor descr=createDescriptor(owner,entry,segSize);
            final DefaultMemorySegment newSeg=factory(descr);
            target.add(newSeg);
            segsByThisOwner.add(newSeg);
          }
          memoryLeft-=(numSegmentsToFit - 1) * segSize;
        }
        final MemorySegmentDescriptor descr=createDescriptor(owner,entry,checkedDownCast(memoryLeft));
        final DefaultMemorySegment newSeg=factory(descr);
        target.add(newSeg);
        segsByThisOwner.add(newSeg);
        memoryLeft=0;
        numMoreSegments=0;
      }
 else       if (size >= limitForMultipleSegs) {
        int numSegmentsToFit=(int)Math.ceil(size / ((double)avgSegmentSize));
        int segSize=size / numSegmentsToFit;
        if (memoryLeft < size + segSize) {
          segSize=checkedDownCast(memoryLeft / (numSegmentsToFit + 1));
        }
        target.ensureCapacity(target.size() + numSegmentsToFit);
        for (int i=0; i < numSegmentsToFit - 1; i++) {
          final MemorySegmentDescriptor descr=createDescriptor(owner,entry,segSize);
          final DefaultMemorySegment newSeg=factory(descr);
          target.add(newSeg);
          segsByThisOwner.add(newSeg);
        }
        final MemorySegmentDescriptor descr=createDescriptor(owner,entry,checkedDownCast(entry.end - entry.start));
        final DefaultMemorySegment newSeg=factory(descr);
        target.add(newSeg);
        segsByThisOwner.add(newSeg);
        memoryLeft-=size;
        numMoreSegments-=numSegmentsToFit;
      }
 else       if (size >= avgSegmentSize) {
        int sizeForSegment=(memoryLeft >= 2 * avgSegmentSize) ? avgSegmentSize : (int)(memoryLeft / 2);
        target.ensureCapacity(target.size() + 1);
        final MemorySegmentDescriptor descr=createDescriptor(owner,entry,sizeForSegment);
        final DefaultMemorySegment newSeg=factory(descr);
        target.add(newSeg);
        segsByThisOwner.add(newSeg);
        memoryLeft-=sizeForSegment;
        numMoreSegments--;
      }
      if (entry.start == entry.end) {
        freeSegs.remove();
      }
    }
    if (memoryLeft > 0) {
      freeSegs=this.freeSegments.listIterator();
      while (memoryLeft > 0 && freeSegs.hasNext()) {
        FreeSegmentEntry entry=freeSegs.next();
        int size=checkedDownCast(entry.end - entry.start);
        if (size >= minSegmentSize) {
          int segSize=checkedDownCast(Math.min(size,memoryLeft));
          target.ensureCapacity(target.size() + 1);
          final MemorySegmentDescriptor descr=createDescriptor(owner,entry,segSize);
          final DefaultMemorySegment newSeg=factory(descr);
          target.add(newSeg);
          segsByThisOwner.add(newSeg);
          memoryLeft-=segSize;
          if (entry.start == entry.end) {
            freeSegs.remove();
          }
        }
      }
    }
    if (memoryLeft > 0) {
      throw new MemoryAllocationException();
    }
    success=true;
    return;
  }
  finally {
    if (!success) {
      for (int i=0; i < target.size(); i++) {
        internalRelease((DefaultMemorySegment)target.get(i));
      }
      segsByThisOwner.removeAll(target);
      target.clear();
    }
  }
}
