{
  if (owner == null) {
    throw new IllegalArgumentException("The owner of a memory segment must not be null.");
  }
  if (minSegmentSize > this.chunkSize) {
    throw new MemoryAllocationException("The memory chunks of this MemoryManager are too small to serve " + "segments of minimal size " + minSegmentSize);
  }
  if (LOG.isDebugEnabled() && owner.getEnvironment() != null) {
    LOG.info("Allocating " + totalMemory + " bytes in at least "+ minNumSegments+ " buffers for "+ owner.getEnvironment().getTaskName()+ " ("+ (owner.getEnvironment().getIndexInSubtaskGroup() + 1)+ "/"+ owner.getEnvironment().getCurrentNumberOfSubtasks()+ ")");
  }
  final ArrayList<MemorySegment> segments=new ArrayList<MemorySegment>(minNumSegments + 1);
synchronized (this.lock) {
    if (isShutDown) {
      throw new IllegalStateException("Memory Manager has been shut down.");
    }
    ArrayList<DefaultMemorySegment> segsByThisOwner=allocatedSegments.get(owner);
    if (segsByThisOwner == null) {
      segsByThisOwner=new ArrayList<DefaultMemorySegment>();
      allocatedSegments.put(owner,segsByThisOwner);
    }
    segsByThisOwner.ensureCapacity(segsByThisOwner.size() + minNumSegments + 1);
    if (this.strategy == AllocationStrategy.COMPACT) {
      internalAllocateCompact(owner,segments,segsByThisOwner,totalMemory,minNumSegments,minSegmentSize);
    }
  }
  return segments;
}
