{
  if (memorySize <= 0) {
    throw new IllegalArgumentException("Size of total memory must be positive.");
  }
  if (chunkSize <= MIN_CHUNK_SIZE) {
    throw new IllegalArgumentException("The chunk size must be at least " + MIN_CHUNK_SIZE + " bytes.");
  }
  if (allocationStrategy == null) {
    throw new IllegalArgumentException("The allocation strategy must not be null.");
  }
  this.totalSize=memorySize;
  this.freeSegments=new LinkedList<FreeSegmentEntry>();
  this.allocatedSegments=new HashMap<AbstractInvokable,ArrayList<DefaultMemorySegment>>();
  this.strategy=allocationStrategy;
  int numberOfFullChunks=checkedDownCast(memorySize / chunkSize);
  int lastChunkSize=checkedDownCast(memorySize % chunkSize);
  int numberOfChunks=lastChunkSize == 0 ? numberOfFullChunks : numberOfFullChunks + 1;
  this.chunkSize=chunkSize;
  this.memory=new byte[numberOfChunks][];
  for (int i=0; i < numberOfFullChunks; i++) {
    this.memory[i]=new byte[chunkSize];
    this.freeSegments.add(new FreeSegmentEntry(i,i * ((long)this.chunkSize),i * ((long)this.chunkSize) + this.memory[i].length));
  }
  if (lastChunkSize > 0) {
    this.memory[numberOfFullChunks]=new byte[lastChunkSize];
    this.freeSegments.add(new FreeSegmentEntry(numberOfFullChunks,numberOfFullChunks * ((long)this.chunkSize),numberOfFullChunks * ((long)this.chunkSize) + lastChunkSize));
  }
}
