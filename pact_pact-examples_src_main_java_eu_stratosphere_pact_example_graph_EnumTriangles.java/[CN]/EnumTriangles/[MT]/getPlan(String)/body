{
  if (args.length != 3) {
    return null;
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String edgeInput=args[1];
  String output=args[2];
  DataSourceContract<Edge,PactNull> edges=new DataSourceContract<Edge,PactNull>(EdgeListInFormat.class,edgeInput);
  edges.setFormatParameter("delimiter","\n");
  edges.setDegreeOfParallelism(noSubTasks);
  edges.setOutputContract(UniqueKey.class);
  MapContract<Edge,PactNull,PactString,Edge> assignKeys=new MapContract<Edge,PactNull,PactString,Edge>(AssignKeys.class,"Assign Keys");
  assignKeys.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,Edge,Edge,EdgeList> buildTriads=new ReduceContract<PactString,Edge,Edge,EdgeList>(BuildTriads.class,"Build Triads");
  buildTriads.setDegreeOfParallelism(noSubTasks);
  MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList> closeTriads=new MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList>(CloseTriads.class,"Close Triads");
  closeTriads.setDegreeOfParallelism(noSubTasks);
  closeTriads.getStubParameters().setString(PactCompiler.HINT_LOCAL_STRATEGY,PactCompiler.HINT_LOCAL_STRATEGY_SORT);
  DataSinkContract<PactNull,EdgeList> triangles=new DataSinkContract<PactNull,EdgeList>(EdgeListOutFormat.class,output);
  triangles.setDegreeOfParallelism(noSubTasks);
  triangles.setInput(closeTriads);
  closeTriads.setSecondInput(edges);
  closeTriads.setFirstInput(buildTriads);
  buildTriads.setInput(assignKeys);
  assignKeys.setInput(edges);
  return new Plan(triangles,"Enumerate Triangles");
}
