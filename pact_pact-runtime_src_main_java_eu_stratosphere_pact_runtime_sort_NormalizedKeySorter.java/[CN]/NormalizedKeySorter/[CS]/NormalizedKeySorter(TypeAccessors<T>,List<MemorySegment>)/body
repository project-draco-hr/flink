{
  if (accessors == null || memory == null) {
    throw new NullPointerException();
  }
  this.accessors=accessors;
  this.totalNumBuffers=memory.size();
  if (this.totalNumBuffers < MIN_REQUIRED_BUFFERS) {
    throw new IllegalArgumentException("Normalized-Key sorter requires at least " + MIN_REQUIRED_BUFFERS + " memory buffers.");
  }
  final int segmentSize=memory.get(0).size();
  if ((segmentSize & segmentSize - 1) != 0) {
    throw new IllegalArgumentException("Normalized-Key-Sort requires buffers whose size is a power of 2.");
  }
  this.segmentSizeMask=segmentSize - 1;
  this.segmentSizeBits=MathUtils.log2floor(segmentSize);
  if (memory instanceof ArrayList<?>) {
    this.freeMemory=(ArrayList<MemorySegment>)memory;
  }
 else {
    this.freeMemory=new ArrayList<MemorySegment>(memory.size());
    this.freeMemory.addAll(memory);
  }
  this.memorySource=new MemorySegmentListIterator(this.freeMemory);
  this.sortIndex=new ArrayList<MemorySegment>(16);
  this.recordBuffers=new ArrayList<MemorySegment>(16);
  this.numKeyBytes=Math.min(this.accessors.getNormalizeKeyLen(),MAX_NORMALIZED_KEY_LEN);
  this.indexEntrySize=this.numKeyBytes + OFFSET_LEN;
  this.indexEntriesPerSegment=segmentSize / this.indexEntrySize;
  this.lastIndexEntryOffset=(this.indexEntriesPerSegment - 1) * this.indexEntrySize;
  this.swapBuffer=new byte[this.indexEntrySize];
  reset();
}
