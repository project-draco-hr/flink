{
  TransferEnvelope transferEnvelope=null;
synchronized (this.queuedEnvelopes) {
    if (this.queuedEnvelopes.isEmpty()) {
      return null;
    }
    transferEnvelope=this.queuedEnvelopes.peek();
    if (transferEnvelope.getBuffer() == null) {
      this.queuedEnvelopes.poll();
    }
  }
  if (transferEnvelope.getBuffer() == null) {
    final EventList eventList=transferEnvelope.getEventList();
    if (!eventList.isEmpty()) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        this.byteBufferedInputChannel.processEvent(it.next());
      }
    }
    return null;
  }
  BufferPairResponse response;
  if (this.byteBufferedInputChannel.getCompressionLevel() == CompressionLevel.NO_COMPRESSION) {
    response=new BufferPairResponse(null,transferEnvelope.getBuffer());
  }
 else {
    final int maximumBufferSize=this.readBufferProvider.getMaximumBufferSize();
    final BufferPairRequest request=new BufferPairRequest(transferEnvelope.getBuffer().isBackedByMemory() ? -1 : transferEnvelope.getBuffer().size(),maximumBufferSize,true);
    try {
      response=this.readBufferProvider.requestEmptyReadBuffers(request);
    }
 catch (    InterruptedException e) {
      this.byteBufferedInputChannel.checkForNetworkEvents();
      return null;
    }
    if (transferEnvelope.getBuffer().isBackedByMemory()) {
      response=new BufferPairResponse(transferEnvelope.getBuffer(),response.getUncompressedDataBuffer());
    }
 else {
      final Buffer oldBuffer=transferEnvelope.getBuffer();
      try {
        oldBuffer.copyToBuffer(response.getCompressedDataBuffer());
        transferEnvelope.setBuffer(response.getCompressedDataBuffer());
      }
 catch (      IOException ioe) {
        LOG.error(ioe);
        this.byteBufferedInputChannel.reportIOException(ioe);
        return null;
      }
      oldBuffer.recycleBuffer();
    }
    this.uncompressedDataBuffer=response.getUncompressedDataBuffer();
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (!eventList.isEmpty()) {
    final Iterator<AbstractEvent> it=eventList.iterator();
    while (it.hasNext()) {
      this.byteBufferedInputChannel.processEvent(it.next());
    }
  }
  return response;
}
