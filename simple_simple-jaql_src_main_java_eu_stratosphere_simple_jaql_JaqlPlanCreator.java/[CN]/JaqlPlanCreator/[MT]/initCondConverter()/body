{
  this.condConverter.register(new CondConverter<OrExpr>(){
    @Override public Condition convert(    OrExpr expr,    List<Condition> childConditions){
      return Condition.chain(childConditions,Combination.OR);
    }
  }
);
  this.condConverter.register(new CondConverter<AndExpr>(){
    @Override public Condition convert(    AndExpr expr,    List<Condition> childConditions){
      return Condition.chain(childConditions,Combination.AND);
    }
  }
);
  this.condConverter.register(new CondConverter<PathExpr>(){
    @Override public Condition convert(    PathExpr expr,    List<Condition> childConditions){
      return new Condition(new BooleanExpression(parsePath(expr)));
    }
  }
);
  this.condConverter.register(new CondConverter<CompareExpr>(){
    private Field OpField;
    private BinaryOperator[] OperatorMapping={BinaryOperator.EQUAL,BinaryOperator.NOT_EQUAL,BinaryOperator.LESS,BinaryOperator.LESS_EQUAL,BinaryOperator.GREATER,BinaryOperator.GREATER_EQUAL};
{
      try {
        this.OpField=CompareExpr.class.getDeclaredField("op");
        this.OpField.setAccessible(true);
      }
 catch (      Exception e) {
        throw new IllegalStateException("Cannot find op field",e);
      }
    }
    @Override public Condition convert(    CompareExpr expr,    List<Condition> childConditions){
      try {
        int op=(Integer)this.OpField.get(expr);
        return new Condition(new BooleanExpression(JaqlPlanCreator.this.parsePath(expr.child(0)),this.OperatorMapping[op],JaqlPlanCreator.this.parsePath(expr.child(1))));
      }
 catch (      Exception e) {
        throw new IllegalArgumentException("Cannot parse " + expr,e);
      }
    }
  }
);
}
