{
  this.pathConverter.register(PathExpr.class,new PathConverter<PathExpr>(){
    @Override public JsonPath convert(    PathExpr expr,    List<JsonPath> childPaths){
      for (int index=childPaths.size() - 2; index >= 0; index--) {
        JsonPath childPath=childPaths.get(index);
        JsonPath lastSelector;
        if (childPath.getSelector() == null)         childPaths.set(index,lastSelector=childPath.clone());
 else {
          JsonPath lastButOneSelector=childPath.getSelector(-2);
          lastButOneSelector.setSelector(lastSelector=lastButOneSelector.getSelector().clone());
        }
        lastSelector.setSelector(childPaths.get(index + 1));
      }
      return childPaths.get(0);
    }
  }
);
  this.pathConverter.register(VarExpr.class,new PathConverter<VarExpr>(){
    @Override public JsonPath convert(    VarExpr expr,    List<JsonPath> childPath){
      Binding binding=JaqlPlanCreator.this.bindings.get(expr.var().taggedName());
      Object var=binding.getTransformed();
      if (expressionToOperators.containsKey(binding.getExpr())) {
        var=expressionToOperators.get(binding.getExpr());
      }
      if (var instanceof Operator) {
        int index=JaqlPlanCreator.this.findInputIndex((Operator)var);
        if (index != -1)         return new JsonPath.Input(index);
      }
      if (var instanceof JsonPath)       return (JsonPath)var;
      System.out.println(expr.var().taggedName() + " -> " + var);
      return new JsonPath.IdentifierAccess(expr.var().taggedName());
    }
  }
);
  this.pathConverter.register(PathFieldValue.class,new PathConverter<PathFieldValue>(){
    @Override public JsonPath convert(    PathFieldValue expr,    List<JsonPath> childPath){
      JsonPath.FieldAccess fieldAccess=new JsonPath.FieldAccess(((ConstExpr)expr.nameExpr()).value.toString());
      if (childPath.size() > 1)       fieldAccess.setSelector(childPath.get(1));
      return fieldAccess;
    }
  }
);
  this.pathConverter.register(ConstExpr.class,new PathConverter<ConstExpr>(){
    @Override public JsonPath convert(    ConstExpr expr,    List<JsonPath> childPath){
      return new JsonPath.Constant(expr.value);
    }
  }
);
  this.pathConverter.register(PathIndex.class,new PathConverter<PathIndex>(){
    @Override public JsonPath convert(    PathIndex expr,    List<JsonPath> childPath){
      return new JsonPath.ArrayAccess(((Constant)childPath.get(0)).asInt());
    }
  }
);
  this.pathConverter.register(PathArrayAll.class,new PathConverter<PathArrayAll>(){
    @Override public JsonPath convert(    PathArrayAll expr,    List<JsonPath> childPath){
      JsonPath.ArrayAccess path=new JsonPath.ArrayAccess();
      path.setSelector(childPath.get(0));
      return path;
    }
  }
);
  this.pathConverter.register(Expr.class,new PathConverter<Expr>(){
    @Override public JsonPath convert(    Expr expr,    List<JsonPath> childPaths){
      if (!expr.getClass().getSimpleName().endsWith("Fn"))       return null;
      BuiltInFunctionDescriptor d=BuiltInFunction.getDescriptor(expr.getClass());
      return new JsonPath.Function(d.getName(),childPaths.toArray(new JsonPath[childPaths.size()]));
    }
  }
);
  this.pathConverter.register(ArrayExpr.class,new PathConverter<ArrayExpr>(){
    @Override public JsonPath convert(    ArrayExpr expr,    List<JsonPath> childPaths){
      return new JsonPath.ArrayCreation(childPaths);
    }
  }
);
  this.pathConverter.register(MathExpr.class,new PathConverter<MathExpr>(){
    private Field OpField;
    private ArithmeticOperator[] OperatorMapping={ArithmeticOperator.PLUS,ArithmeticOperator.MINUS,ArithmeticOperator.MULTIPLY,ArithmeticOperator.DIVIDE};
{
      try {
        this.OpField=MathExpr.class.getDeclaredField("op");
        this.OpField.setAccessible(true);
      }
 catch (      Exception e) {
        throw new IllegalStateException("Cannot find op field",e);
      }
    }
    @Override public JsonPath convert(    MathExpr expr,    List<JsonPath> childConditions){
      try {
        int op=(Integer)this.OpField.get(expr);
        return new JsonPath.Arithmetic(childConditions.get(0),this.OperatorMapping[op],childConditions.get(1));
      }
 catch (      Exception e) {
        throw new IllegalArgumentException("Cannot parse " + expr,e);
      }
    }
  }
);
}
