{
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(this.stub.getFirstInKeyType(),this.stub.getFirstInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain SpillingResettableIterator for first input",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(this.stub.getSecondInKeyType(),this.stub.getSecondInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain BlockResettableIterator for second input",mae);
      }
      firstInputIsOuter=false;
    }
 else     if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(this.stub.getSecondInKeyType(),this.stub.getSecondInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain SpillingResettableIterator for second input",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(this.stub.getFirstInKeyType(),this.stub.getFirstInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain BlockResettableIterator for first input",mae);
      }
      firstInputIsOuter=true;
    }
 else {
      throw new RuntimeException("Invalid local strategy for CrossTask: " + this.config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException("Unable to open SpillingResettableIterator",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException("Unable to open SpillingResettableIterator",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException("Unable to open SpillingResettableIterator",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    if (LOG.isDebugEnabled()) {
      LOG.debug(getLogString("SpillingResettable iterator obtained"));
      LOG.debug(getLogString("BlockResettable iterator obtained"));
    }
    this.stub.open();
    boolean moreOuterBlocks=false;
    if (innerInput.hasNext()) {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          KeyValuePair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            KeyValuePair<Key,Value> outerPair=outerInput.next();
            if (firstInputIsOuter) {
              this.stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),this.output);
            }
 else {
              this.stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),this.output);
            }
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
 else {
      LOG.debug("Inner input is empty, we must clear the outer input as well to close the channel");
      do {
        while (outerInput.hasNext()) {
          outerInput.next();
        }
      }
 while (outerInput.nextBlock());
    }
    this.stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(getLogString("Unexpected ERROR in PACT code"));
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException("Error closing SpillingResettableIterator.",t1);
    if (t2 != null)     throw new RuntimeException("Error closung BlockResettableIterator.",t2);
  }
}
