{
  LastRepeatableIterator<KeyValuePair<Key,Value>> outerInput=new LastRepeatableIterator<KeyValuePair<Key,Value>>(){
    byte[] lastSerialized=new byte[1024];
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    ByteArrayInputStream bais=new ByteArrayInputStream(lastSerialized);
    DataInputStream dis=new DataInputStream(bais);
    KeyValuePairDeserializer<Key,Value> deserializer=new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType());
    @Override public boolean hasNext(){
      return outerReader.hasNext();
    }
    @Override public KeyValuePair<Key,Value> next(){
      try {
        KeyValuePair<Key,Value> pair=outerReader.next();
        pair.write(dos);
        dos.flush();
        baos.flush();
        if (baos.size() <= lastSerialized.length) {
          System.arraycopy(baos.toByteArray(),0,lastSerialized,0,baos.size());
        }
 else {
          lastSerialized=new byte[baos.size() * 2];
          System.arraycopy(baos.toByteArray(),0,lastSerialized,0,baos.size());
          bais=new ByteArrayInputStream(lastSerialized);
          dis=new DataInputStream(bais);
        }
        baos.reset();
        return pair;
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public KeyValuePair<Key,Value> repeatLast(){
      KeyValuePair<Key,Value> pair=deserializer.getInstance();
      try {
        pair.read(dis);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
      bais.reset();
      return pair;
    }
  }
;
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  try {
    innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,MEMORY_IO / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()));
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException("Unable to obtain SpillingResettable iterator for inner side.",mae);
  }
  try {
    innerInput.open();
  }
 catch (  ServiceException se) {
    throw new RuntimeException("Unable to open SpillingResettable iterator for inner side.",se);
  }
catch (  IOException ioe) {
    throw new RuntimeException("Unable to open SpillingResettable iterator for inner side.",ioe);
  }
catch (  InterruptedException ie) {
    throw new RuntimeException("Unable to open SpillingResettable iterator for inner side.",ie);
  }
  LOG.debug("Resetable iterator obtained: " + this.getEnvironment().getTaskName() + " ("+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ "/"+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ")");
  stub.open();
  while (outerInput.hasNext()) {
    Pair outerPair=outerInput.next();
    while (innerInput.hasNext()) {
      Pair innerPair=innerInput.next();
      if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
        stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
      }
 else {
        stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
      }
      outerPair=outerInput.repeatLast();
    }
    innerInput.reset();
  }
  stub.close();
  try {
    innerInput.close();
  }
 catch (  ServiceException se) {
    throw new RuntimeException("Unable to close SpillingResettable iterator for inner side.",se);
  }
}
