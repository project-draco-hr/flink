{
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain SpillingResettableIterator for first input",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain BlockResettableIterator for second input",mae);
      }
    }
 else     if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain SpillingResettableIterator for second input",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException("Unable to obtain BlockResettableIterator for first input",mae);
      }
    }
 else {
      throw new RuntimeException("Invalid local strategy for CrossTask: " + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException("Unable to open SpillingResettableIterator",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException("Unable to open SpillingResettableIterator",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException("Unable to open SpillingResettableIterator",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    LOG.debug("SpillingResettable iterator obtained: " + this.getEnvironment().getTaskName() + " ("+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ "/"+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ")");
    LOG.debug("BlockResettable iterator obtained: " + this.getEnvironment().getTaskName() + " ("+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ "/"+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ")");
    stub.open();
    boolean moreOuterBlocks=false;
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      do {
        while (innerInput.hasNext() && !this.taskCanceled) {
          Pair<Key,Value> innerPair=innerInput.next();
          while (outerInput.hasNext() && !this.taskCanceled) {
            Pair<Key,Value> outerPair=outerInput.next();
            stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (moreOuterBlocks && !this.taskCanceled);
    }
 else {
      do {
        while (innerInput.hasNext() && !this.taskCanceled) {
          Pair<Key,Value> innerPair=innerInput.next();
          while (outerInput.hasNext() && !this.taskCanceled) {
            Pair<Key,Value> outerPair=outerInput.next();
            stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (moreOuterBlocks && !this.taskCanceled);
    }
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error("Unexpected ERROR in PACT code: " + this.getEnvironment().getTaskName() + " ("+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ "/"+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ")");
      throw ex;
    }
  }
 finally {
    ServiceException se1=null, se2=null;
    try {
      if (innerInput != null)       innerInput.close();
    }
 catch (    ServiceException se) {
      LOG.warn(se);
      se1=se;
    }
    try {
      if (outerInput != null)       outerInput.close();
    }
 catch (    ServiceException se) {
      LOG.warn(se);
      se2=se;
    }
    if (se1 != null)     throw new RuntimeException("Unable to close SpillingResettableIterator.",se1);
    if (se2 != null)     throw new RuntimeException("Unable to close BlockResettableIterator.",se2);
  }
}
