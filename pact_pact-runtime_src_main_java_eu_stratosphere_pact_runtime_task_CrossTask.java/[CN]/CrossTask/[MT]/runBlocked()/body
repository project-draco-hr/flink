{
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  final MutableObjectIterator<PactRecord> innerReader=inputs[0];
  final MutableObjectIterator<PactRecord> outerReader=inputs[1];
  innerInput=null;
  outerInput=null;
  final boolean firstInputIsOuter;
  if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
    innerInput=new SpillingResettableMutableObjectIterator(memoryManager,ioManager,innerReader,availableMemory / 2,this);
    outerInput=new BlockResettableMutableObjectIterator(memoryManager,outerReader,availableMemory / 2,1,this);
    firstInputIsOuter=false;
  }
 else   if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
    innerInput=new SpillingResettableMutableObjectIterator(memoryManager,ioManager,innerReader,availableMemory / 2,this);
    outerInput=new BlockResettableMutableObjectIterator(memoryManager,outerReader,availableMemory / 2,1,this);
    firstInputIsOuter=true;
  }
 else {
    throw new RuntimeException("Invalid local strategy for CrossTask: " + config.getLocalStrategy());
  }
  innerInput.open();
  if (!this.running)   return;
  outerInput.open();
  if (LOG.isDebugEnabled()) {
    LOG.debug(getLogString("SpillingResettable iterator obtained"));
    LOG.debug(getLogString("BlockResettable iterator obtained"));
  }
  boolean moreOuterBlocks=false;
  PactRecord innerRecord=new PactRecord();
  PactRecord outerRecord=new PactRecord();
  if (innerInput.next(innerRecord)) {
    innerInput.reset();
    do {
      while (this.running && innerInput.next(innerRecord)) {
        while (this.running && outerInput.next(outerRecord)) {
          if (firstInputIsOuter) {
            stub.cross(outerRecord,innerRecord,output);
          }
 else {
            stub.cross(innerRecord,outerRecord,output);
          }
          innerInput.repeatLast(innerRecord);
        }
        outerInput.reset();
      }
      moreOuterBlocks=outerInput.nextBlock();
      if (moreOuterBlocks) {
        innerInput.reset();
      }
    }
 while (this.running && moreOuterBlocks);
  }
}
