{
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>();
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    Collection<MemorySegment> inputSegments;
    inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
    freeSegmentsAtShutdown(inputSegments);
    final ChannelReader reader=ioManager.createChannelReader(id,inputSegments);
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  Collection<MemorySegment> outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
  freeSegmentsAtShutdown(outputSegments);
  ChannelWriter writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  while (mi.hasNext()) {
    KeyValuePair<K,V> pair=mi.next();
    if (!writer.write(pair)) {
      throw new RuntimeException("Writing of pair during merging failed");
    }
  }
  outputSegments=writer.close();
  memoryManager.release(outputSegments);
  return mergedChannelID;
}
