{
  final double numMerges=Math.ceil(channelIDs.size() / ((double)maxNumFileHandles));
  final int channelsToMergePerStep=(int)Math.ceil(channelIDs.size() / numMerges);
  if (memorySize < channelsToMergePerStep * MIN_IO_BUFFER_SIZE) {
    throw new MemoryAllocationException("Available memory of " + memorySize + " is not sufficient to merge "+ channelsToMergePerStep+ " channels.");
  }
  final List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelsToMergePerStep);
  final List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,memorySize,channelsToMergePerStep);
  registerSegmentsToBeFreedAtShutdown(allBuffers);
  final ArrayList<Channel.ID> mergedChannelIDs=new ArrayList<Channel.ID>((int)(numMerges + 1));
  final ArrayList<Channel.ID> channelsToMergeThisStep=new ArrayList<Channel.ID>(channelsToMergePerStep);
  int channelNum=0;
  while (channelNum < channelIDs.size()) {
    channelsToMergeThisStep.clear();
    for (int i=0; i < channelsToMergePerStep && channelNum < channelIDs.size(); i++, channelNum++) {
      channelsToMergeThisStep.add(channelIDs.get(channelNum));
    }
    if (channelsToMergeThisStep.size() < 2) {
      mergedChannelIDs.addAll(channelsToMergeThisStep);
    }
 else {
      mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep,readBuffers,writeBuffers));
    }
  }
  this.memoryManager.release(allBuffers);
  unregisterSegmentsToBeFreedAtShutdown(allBuffers);
  return mergedChannelIDs;
}
