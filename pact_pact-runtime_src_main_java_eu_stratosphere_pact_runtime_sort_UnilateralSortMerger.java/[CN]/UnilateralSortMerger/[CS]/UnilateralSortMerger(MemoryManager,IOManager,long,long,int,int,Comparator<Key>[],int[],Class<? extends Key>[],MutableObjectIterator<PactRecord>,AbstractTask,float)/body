{
  if (memoryManager == null | ioManager == null | keyComparators == null | keyPositions == null | keyClasses == null) {
    throw new NullPointerException();
  }
  if (parentTask == null) {
    throw new NullPointerException("Parent Task must not be null.");
  }
  if (maxNumFileHandles < 2) {
    throw new IllegalArgumentException("Merger cannot work with less than two file handles.");
  }
  if (keyComparators.length < 1) {
    throw new IllegalArgumentException("There must be at least one sort column and hence one comparator.");
  }
  if (keyComparators.length != keyPositions.length || keyPositions.length != keyClasses.length) {
    throw new IllegalArgumentException("The number of comparators, key columns and key types must match.");
  }
  if (ioMemory != 0 && totalMemory < maxNumFileHandles * MIN_IO_BUFFER_SIZE) {
    maxNumFileHandles=(int)(totalMemory / MIN_IO_BUFFER_SIZE);
    LOG.warn("Reducing merge fan-in to " + maxNumFileHandles + " due too memory limitations.");
  }
  this.maxNumFileHandles=maxNumFileHandles;
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.keyComparators=keyComparators;
  this.keyPositions=keyPositions;
  this.keyClasses=keyClasses;
  this.parent=parentTask;
  this.memoryToReleaseAtShutdown=new ArrayList<List<MemorySegment>>();
  this.channelsToDeleteAtShutdown=new ArrayList<List<StreamChannelAccess<?,?>>>();
  final CircularQueues circularQueues=new CircularQueues();
  if (ioMemory < 0) {
    ioMemory=totalMemory / 64;
    ioMemory=Math.max(Math.min(ioMemory,NUM_WRITE_BUFFERS * MAX_IO_BUFFER_SIZE),NUM_WRITE_BUFFERS * MIN_IO_BUFFER_SIZE);
    ioMemory&=IO_BUFFER_ALIGNMENT_MASK << 1;
  }
  final long sortMem=totalMemory - ioMemory;
  long numSortMemSegments=sortMem / SORT_MEM_SEGMENT_SIZE;
  if (numSortMemSegments < MIN_NUM_SORT_MEM_SEGMENTS) {
    throw new IOException("Too little memory provided to Sort-Merger to perform task.");
  }
  if (numSortBuffers < 1) {
    if (sortMem > 96 * 1024 * 1024) {
      numSortBuffers=3;
    }
 else     if (numSortMemSegments >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {
      numSortBuffers=2;
    }
 else {
      numSortBuffers=1;
    }
  }
  final int numSegmentsPerSortBuffer=numSortMemSegments / numSortBuffers > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)(numSortMemSegments / numSortBuffers);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Instantiating unilateral sort-merger with " + ioMemory + " bytes of write cache and "+ sortMem+ " bytes of sorting/merging memory. Dividing sort memory over "+ numSortBuffers+ " buffers ("+ numSegmentsPerSortBuffer+ " pages a "+ SORT_MEM_SEGMENT_SIZE+ " bytes) , merging maximally "+ maxNumFileHandles+ " streams at once.");
  }
  this.sortBuffers=new ArrayList<NormalizedKeySorter<?>>(numSortBuffers);
  final PactRecordAccessors accessors=new PactRecordAccessors(keyPositions,keyClasses);
  for (int i=0; i < numSortBuffers; i++) {
    final List<MemorySegment> sortSegments=this.memoryManager.allocateStrict(parent,numSegmentsPerSortBuffer,SORT_MEM_SEGMENT_SIZE);
    final NormalizedKeySorter<PactRecord> buffer=new NormalizedKeySorter<PactRecord>(accessors,sortSegments);
    this.sortBuffers.add(buffer);
    CircularElement element=new CircularElement(i,buffer);
    circularQueues.empty.add(element);
  }
  ExceptionHandler<IOException> exceptionHandler=new ExceptionHandler<IOException>(){
    public void handleException(    IOException exception){
      if (!closed) {
        setResultIteratorException(exception);
        close();
      }
    }
  }
;
  this.readThread=getReadingThread(exceptionHandler,input,circularQueues,parentTask,((long)(startSpillingFraction * sortMem)));
  this.sortThread=getSortingThread(exceptionHandler,circularQueues,parentTask);
  this.spillThread=getSpillingThread(exceptionHandler,circularQueues,memoryManager,ioManager,ioMemory,sortMem,parentTask);
  startThreads();
}
