{
  if (memoryManager == null | ioManager == null | keyComparators == null | keyPositions == null | keyClasses == null) {
    throw new NullPointerException();
  }
  if (parentTask == null) {
    throw new NullPointerException("Parent Task must not be null.");
  }
  if (maxNumFileHandles < 2) {
    throw new IllegalArgumentException("Merger cannot work with less than two file handles.");
  }
  if (totalMemory < maxNumFileHandles * MIN_IO_BUFFER_SIZE) {
    throw new IOException("Too little memory for merging operations.");
  }
  if (keyComparators.length < 1) {
    throw new IllegalArgumentException("There must be at least one sort column and hence one comparator.");
  }
  if (keyComparators.length != keyPositions.length || keyPositions.length != keyClasses.length) {
    throw new IllegalArgumentException("The number of comparators, key columns and key types must match.");
  }
  this.maxNumFileHandles=maxNumFileHandles;
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.keyComparators=keyComparators;
  this.keyPositions=keyPositions;
  this.keyClasses=keyClasses;
  this.parent=parentTask;
  this.memoryToReleaseAtShutdown=new ArrayList<List<MemorySegment>>();
  this.channelsToDeleteAtShutdown=new ArrayList<List<StreamChannelAccess<?,?>>>();
  final CircularQueues circularQueues=new CircularQueues();
  long sortMem;
  if (ioMemory < 0) {
    ioMemory=totalMemory / 64;
    ioMemory=Math.max(Math.min(ioMemory,NUM_WRITE_BUFFERS * MAX_IO_BUFFER_SIZE),NUM_WRITE_BUFFERS * MIN_IO_BUFFER_SIZE);
    ioMemory&=BUFFER_ALIGNMENT_MASK << 1;
  }
  sortMem=totalMemory - ioMemory;
  if (sortMem < MIN_SORT_BUFFER_SIZE) {
    throw new IOException("Too little memory provided to Sort-Merger to perform task.");
  }
  if (numSortBuffers < 1) {
    if (sortMem > 96 * 1024 * 1024) {
      numSortBuffers=3;
    }
 else     if (sortMem >= 2 * MIN_SORT_BUFFER_SIZE) {
      numSortBuffers=2;
    }
 else {
      numSortBuffers=1;
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Instantiating unilateral sort-merger with " + ioMemory + " bytes of write cache and "+ sortMem+ " bytes of sorting/merging memory. Dividing sort memory over "+ numSortBuffers+ " buffers, merging maximally "+ maxNumFileHandles+ " streams at once.");
  }
  final List<MemorySegment> sortSegments=this.memoryManager.allocate(parentTask,sortMem,numSortBuffers,MIN_SORT_BUFFER_SIZE);
  registerSegmentsToBeFreedAtShutdown(sortSegments);
  this.sortSegments=sortSegments;
  for (int i=0; i < sortSegments.size(); i++) {
    MemorySegment mseg=sortSegments.get(i);
    RawComparator comparator=new DeserializerComparator(keyPositions,keyClasses,keyComparators);
    BufferSortableGuaranteed buffer=new BufferSortableGuaranteed(mseg,comparator);
    CircularElement element=new CircularElement(i,buffer);
    circularQueues.empty.add(element);
  }
  ExceptionHandler<IOException> exceptionHandler=new ExceptionHandler<IOException>(){
    public void handleException(    IOException exception){
      if (!closed) {
        setResultIteratorException(exception);
        close();
      }
    }
  }
;
  this.readThread=getReadingThread(exceptionHandler,input,circularQueues,parentTask,((long)(startSpillingFraction * sortMem)));
  this.sortThread=getSortingThread(exceptionHandler,circularQueues,parentTask);
  this.spillThread=getSpillingThread(exceptionHandler,circularQueues,memoryManager,ioManager,ioMemory,sortMem,parentTask);
  startThreads();
}
