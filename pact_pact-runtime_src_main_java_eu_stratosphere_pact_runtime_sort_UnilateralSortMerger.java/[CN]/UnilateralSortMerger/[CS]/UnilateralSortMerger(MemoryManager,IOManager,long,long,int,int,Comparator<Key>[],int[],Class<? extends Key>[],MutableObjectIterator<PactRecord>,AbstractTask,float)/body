{
  if (memoryManager == null | ioManager == null | keyComparators == null | keyPositions == null | keyClasses == null) {
    throw new NullPointerException();
  }
  if (parentTask == null) {
    throw new NullPointerException("Parent Task must not be null.");
  }
  if (maxNumFileHandles < 2) {
    throw new IllegalArgumentException("Merger cannot work with less than two file handles.");
  }
  if (keyComparators.length < 1) {
    throw new IllegalArgumentException("There must be at least one sort column and hence one comparator.");
  }
  if (keyComparators.length != keyPositions.length || keyPositions.length != keyClasses.length) {
    throw new IllegalArgumentException("The number of comparators, key columns and key types must match.");
  }
  this.maxNumFileHandles=maxNumFileHandles;
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.keyComparators=keyComparators;
  this.keyPositions=keyPositions;
  this.keyClasses=keyClasses;
  this.parent=parentTask;
  this.memoryToReleaseAtShutdown=new ArrayList<List<MemorySegment>>();
  this.channelsToDeleteAtShutdown=new ArrayList<Channel.ID>();
  this.openChannels=new ArrayList<BlockChannelAccess<?,?>>();
  if (maxWriteMem != 0) {
    if (maxWriteMem != -1 && maxWriteMem < NUM_WRITE_BUFFERS * MIN_IO_BUFFER_SIZE) {
      throw new IllegalArgumentException("The specified maximum write memory is to low. " + "Required are at least " + (NUM_WRITE_BUFFERS * MIN_IO_BUFFER_SIZE) + " bytes.");
    }
    final int minBuffers=NUM_WRITE_BUFFERS + maxNumFileHandles;
    final int desiredBuffers=NUM_WRITE_BUFFERS + 2 * maxNumFileHandles;
    int bufferSize=(int)(totalMemory / desiredBuffers);
    if (bufferSize < MIN_IO_BUFFER_SIZE) {
      bufferSize=MIN_IO_BUFFER_SIZE;
      if (totalMemory / minBuffers < MIN_IO_BUFFER_SIZE) {
        maxNumFileHandles=(int)(totalMemory / MIN_IO_BUFFER_SIZE) - NUM_WRITE_BUFFERS;
        if (LOG.isWarnEnabled())         LOG.warn("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to memory limitations.");
      }
    }
 else {
      bufferSize=Math.min(MAX_IO_BUFFER_SIZE,MathUtils.roundDownToPowerOf2(bufferSize));
    }
    this.ioBufferSize=maxWriteMem > 0 ? Math.min(bufferSize,MathUtils.roundDownToPowerOf2((int)(maxWriteMem / NUM_WRITE_BUFFERS))) : bufferSize;
    maxWriteMem=NUM_WRITE_BUFFERS * this.ioBufferSize;
  }
 else {
    this.ioBufferSize=-1;
  }
  final long sortMem=totalMemory - maxWriteMem;
  final long numSortMemSegments=sortMem / SORT_MEM_SEGMENT_SIZE;
  if (sortMem < MIN_SORT_MEM) {
    throw new IOException("Too little memory provided to Sort-Merger to perform task.");
  }
  if (numSortBuffers < 1) {
    if (sortMem > 96 * 1024 * 1024) {
      numSortBuffers=3;
    }
 else     if (numSortMemSegments >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {
      numSortBuffers=2;
    }
 else {
      numSortBuffers=1;
    }
  }
  final int numSegmentsPerSortBuffer=numSortMemSegments / numSortBuffers > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)(numSortMemSegments / numSortBuffers);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Instantiating unilateral sort-merger with " + maxWriteMem + " bytes of write cache and "+ sortMem+ " bytes of sorting/merging memory. Dividing sort memory over "+ numSortBuffers+ " buffers ("+ numSegmentsPerSortBuffer+ " pages with "+ SORT_MEM_SEGMENT_SIZE+ " bytes) , merging maximally "+ maxNumFileHandles+ " streams at once.");
  }
  final CircularQueues circularQueues=new CircularQueues();
  this.sortBuffers=new ArrayList<NormalizedKeySorter<?>>(numSortBuffers);
  final PactRecordAccessors accessors=new PactRecordAccessors(keyPositions,keyClasses);
  for (int i=0; i < numSortBuffers; i++) {
    final List<MemorySegment> sortSegments=memoryManager.allocateStrict(parentTask,numSegmentsPerSortBuffer,SORT_MEM_SEGMENT_SIZE);
    final NormalizedKeySorter<PactRecord> buffer=new NormalizedKeySorter<PactRecord>(accessors,sortSegments);
    this.sortBuffers.add(buffer);
    CircularElement element=new CircularElement(i,buffer);
    circularQueues.empty.add(element);
  }
  ExceptionHandler<IOException> exceptionHandler=new ExceptionHandler<IOException>(){
    public void handleException(    IOException exception){
      if (!closed) {
        setResultIteratorException(exception);
        close();
      }
    }
  }
;
  this.readThread=getReadingThread(exceptionHandler,input,circularQueues,parentTask,((long)(startSpillingFraction * sortMem)));
  this.sortThread=getSortingThread(exceptionHandler,circularQueues,parentTask);
  this.spillThread=getSpillingThread(exceptionHandler,circularQueues,memoryManager,ioManager,sortMem,parentTask);
  startThreads();
}
