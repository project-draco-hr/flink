{
  this.collectedPactRecordsInBytes+=record.getBinaryLength();
  try {
    if (this.spillingInThisBuffer) {
      if (this.currentBuffer.write(record)) {
        if (this.bytesUntilSpilling - this.currentBuffer.getOccupancy() <= 0) {
          this.bytesUntilSpilling=0;
          this.queues.sort.add(SPILLING_MARKER);
        }
        return;
      }
    }
 else {
      if (this.currentBuffer.write(record))       return;
    }
    if (this.bytesUntilSpilling > 0) {
      this.bytesUntilSpilling-=this.currentBuffer.getCapacity();
      if (this.bytesUntilSpilling <= 0) {
        this.bytesUntilSpilling=0;
        this.queues.sort.add(SPILLING_MARKER);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Emitting full buffer from reader thread: " + this.currentElement.id + ".");
    }
    this.queues.sort.add(this.currentElement);
    this.currentElement=null;
    while (this.running && this.currentElement == null) {
      try {
        this.currentElement=this.queues.empty.take();
      }
 catch (      InterruptedException iex) {
        if (this.running) {
          LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " + "Retrying to grab buffer...");
        }
 else {
          return;
        }
      }
    }
    if (!this.running)     return;
    this.currentBuffer=this.currentElement.buffer;
    if (!this.currentBuffer.isEmpty()) {
      throw new RuntimeException("BUG: New sort-buffer is not empty.");
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Retrieved empty read buffer " + this.currentElement.id + ".");
    }
    if (!this.currentBuffer.write(record)) {
      throw new RuntimeException("Record could not be written to empty sort-buffer: Serialized record exceeds buffer capacity.");
    }
  }
 catch (  IOException ioex) {
    throw new RuntimeException("BUG: An error occurred while writing a record to the sort buffer: " + ioex.getMessage(),ioex);
  }
}
