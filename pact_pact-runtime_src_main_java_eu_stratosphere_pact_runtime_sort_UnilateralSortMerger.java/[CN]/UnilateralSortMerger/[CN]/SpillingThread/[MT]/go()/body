{
  List<CircularElement> cache=new ArrayList<CircularElement>(buffersToKeepBeforeSpilling);
  CircularElement element=null;
  boolean cacheOnly=false;
  if (buffersToKeepBeforeSpilling > 0) {
    while (isRunning()) {
      if (cache.size() >= buffersToKeepBeforeSpilling) {
        cacheOnly=false;
        break;
      }
      element=queues.spill.take();
      cache.add(element);
      if (element == SENTINEL) {
        cacheOnly=true;
        break;
      }
    }
  }
  if (cacheOnly) {
    LOG.debug("Initiating merge-iterator (in-memory segments).");
    List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>();
    Iterator<CircularElement> iter=cache.iterator();
    while (iter.hasNext()) {
      CircularElement cached=iter.next();
      if (cached != SENTINEL) {
        iterators.add(cached.buffer.getIterator());
      }
    }
    LOG.debug("Releasing sort-buffer memory.");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    setResultIterator(new MergeIterator<K,V>(iterators,keyComparator));
  }
 else {
    LOG.debug("Initiating merge-iterator (materialized segments).");
    final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
    List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
    outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
    freeSegmentsAtShutdown(outputSegments);
    while (isRunning() && (element=takeNext(queues.spill,cache)) != SENTINEL) {
      Channel.ID channel=enumerator.next();
      channelIDs.add(channel);
      ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
      LOG.debug("Spilling buffer " + element.id + ".");
      element.buffer.writeToChannel(writer);
      LOG.debug("Spilled buffer " + element.id + ".");
      outputSegments=writer.close();
      element.buffer.reset();
      queues.empty.put(element);
    }
    LOG.debug("Spilling done.");
    LOG.debug("Releasing output-buffer memory.");
    memoryManager.release(outputSegments);
    LOG.debug("Releasing sort-buffer memory.");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    while (channelIDs.size() > maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,ioMemorySize);
    }
    setResultIterator(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug("Spilling thread done.");
}
