{
  NFA<Event> nfa=new NFA<>(Event.createTypeSerializer(),2);
  List<StreamEvent<Event>> streamEvents=new ArrayList<>();
  streamEvents.add(StreamEvent.of(new Event(1,"start",1.0),1L));
  streamEvents.add(StreamEvent.of(new Event(2,"bar",2.0),2L));
  streamEvents.add(StreamEvent.of(new Event(3,"start",3.0),3L));
  streamEvents.add(StreamEvent.of(new Event(4,"end",4.0),4L));
  State<Event> startingState=new State<>("",State.StateType.Start);
  State<Event> startState=new State<>("start",State.StateType.Normal);
  State<Event> endState=new State<>("end",State.StateType.Final);
  StateTransition<Event> starting2Start=new StateTransition<>(StateTransitionAction.TAKE,startState,new FilterFunction<Event>(){
    private static final long serialVersionUID=-4869589195918650396L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("start");
    }
  }
);
  StateTransition<Event> start2End=new StateTransition<>(StateTransitionAction.TAKE,endState,new FilterFunction<Event>(){
    private static final long serialVersionUID=2979804163709590673L;
    @Override public boolean filter(    Event value) throws Exception {
      return value.getName().equals("end");
    }
  }
);
  StateTransition<Event> start2Start=new StateTransition<>(StateTransitionAction.IGNORE,startState,null);
  startingState.addStateTransition(starting2Start);
  startState.addStateTransition(start2End);
  startState.addStateTransition(start2Start);
  nfa.addState(startingState);
  nfa.addState(startState);
  nfa.addState(endState);
  Set<Map<String,Event>> expectedPatterns=new HashSet<>();
  Map<String,Event> secondPattern=new HashMap<>();
  secondPattern.put("start",new Event(3,"start",3.0));
  secondPattern.put("end",new Event(4,"end",4.0));
  expectedPatterns.add(secondPattern);
  Collection<Map<String,Event>> actualPatterns=runNFA(nfa,streamEvents);
  assertEquals(expectedPatterns,actualPatterns);
}
