{
  if (args.length != 5) {
    System.out.println("Not correct parameters");
    System.exit(-1);
  }
  final int dop=Integer.valueOf(args[0]);
  final String input=args[1];
  final String output=args[2];
  final int spi=Integer.valueOf(args[3]);
  final int baseMemory=Integer.valueOf(args[4]);
  JobGraph graph=new JobGraph("Connected Components");
  JobInputVertex sourceVertex=createInput(AdjacencyListInput.class,input,graph,dop,spi);
  JobTaskVertex convert=createTask(ConvertToTransitiveClosureTypes.class,graph,dop,spi);
  convert.setVertexToShareInstancesWith(sourceVertex);
  JobTaskVertex initialState=createTask(InitialStateComponents.class,graph,dop,spi);
  initialState.setVertexToShareInstancesWith(sourceVertex);
  JobTaskVertex initialUpdateAssigner=createTask(InitialUpdates.class,graph,dop,spi);
  initialUpdateAssigner.setVertexToShareInstancesWith(sourceVertex);
  JobTaskVertex tmpTask=createTask(UpdateTempTask.class,graph,dop);
  tmpTask.setVertexToShareInstancesWith(sourceVertex);
  setMemorySize(tmpTask,baseMemory * 1 / 9);
  JobTaskVertex updatesMatch=createTask(AsynchronousUpdateableMatchingOptimized.class,graph,dop,spi);
  updatesMatch.setVertexToShareInstancesWith(sourceVertex);
  setMemorySize(updatesMatch,baseMemory * 8 / 9);
  JobOutputVertex sinkVertex=createOutput(NullOutput.class,output,graph,dop,spi);
  sinkVertex.setVertexToShareInstancesWith(sourceVertex);
  connectJobVertices(ShipStrategy.FORWARD,sourceVertex,convert,null,null);
  connectJobVertices(ShipStrategy.PARTITION_HASH,convert,initialState,null,null);
  connectJobVertices(ShipStrategy.FORWARD,initialState,initialUpdateAssigner,null,null);
  connectJobVertices(ShipStrategy.FORWARD,initialUpdateAssigner,tmpTask,null,null);
  NepheleUtil.connectAsyncBoundedRoundsIterationLoop(tmpTask,sinkVertex,null,null,updatesMatch,ShipStrategy.PARTITION_HASH,14,graph);
  connectJobVertices(ShipStrategy.FORWARD,initialState,updatesMatch,null,null);
  submit(graph,getConfiguration());
}
