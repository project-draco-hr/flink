{
  int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceIPM=connection.getSourcePact().getInstancesPerMachine();
  int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
  Class<?> sourceStub=connection.getSourcePact().getPactContract().getUserCodeClass();
  if (targetDOP == 1) {
    if (sourceDOP == 1) {
      outputVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION,DistributionPattern.POINTWISE);
    }
 else {
      outputVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION,DistributionPattern.POINTWISE);
    }
    outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
    inputConfig.addInputShipStrategy(ShipStrategy.FORWARD,inputNumber);
    return;
  }
  JobTaskVertex partitionVertex=new JobTaskVertex("Range partition - partitioning",this.jobGraph);
  this.auxVertices.add(partitionVertex);
  partitionVertex.setTaskClass(PartitionTask.class);
  partitionVertex.setNumberOfSubtasks(sourceDOP);
  if (sourceIPM >= 1) {
    partitionVertex.setNumberOfSubtasksPerInstance(sourceIPM);
  }
  TaskConfig partitionConfig=new TaskConfig(partitionVertex.getConfiguration());
  partitionConfig.setStubClass(sourceStub);
  Configuration partitionStubConfig=new Configuration();
  partitionStubConfig.setString(PartitionTask.GLOBAL_PARTITIONING_ORDER,connection.getTargetPact().getGlobalProperties().getOrdering().getOrder(0).name());
  partitionStubConfig.setBoolean(PartitionTask.PARTITION_BY_SAMPLING,false);
  partitionStubConfig.setInteger(PartitionTask.NUMBER_OF_PARTITIONS,targetDOP);
  partitionStubConfig.setClass(PartitionTask.DATA_DISTRIBUTION_CLASS,connection.getTargetPact().getPactContract().getCompilerHints().getInputDistributionClass());
  partitionConfig.setStubParameters(partitionStubConfig);
  outputVertex.connectTo(partitionVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION,DistributionPattern.POINTWISE);
  partitionConfig.addInputShipStrategy(ShipStrategy.FORWARD,1);
  outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  partitionVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION,DistributionPattern.BIPARTITE);
  inputConfig.addInputShipStrategy(ShipStrategy.PARTITION_RANGE,inputNumber);
  partitionConfig.addOutputShipStrategy(ShipStrategy.PARTITION_RANGE);
}
