{
  try {
    if (node instanceof UnionPlanNode) {
      return;
    }
    final Iterator<Channel> inConns=node.getInputs();
    if (!inConns.hasNext()) {
      return;
    }
    final AbstractJobVertex targetVertex=this.vertices.get(node);
    if (targetVertex == null) {
      final Channel inConn=inConns.next();
      if (inConns.hasNext()) {
        throw new IllegalStateException("Bug: Found a chained task with more than one input!");
      }
      final TaskInChain chainedTask=this.chainedTasks.get(node);
      AbstractJobVertex container=chainedTask.getContainingVertex();
      if (container == null) {
        final PlanNode sourceNode=inConn.getSource();
        container=this.vertices.get(sourceNode);
        if (container == null) {
          container=this.chainedTasks.get(sourceNode).getContainingVertex();
          if (container == null)           throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.");
        }
 else {
          new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD);
        }
        chainedTask.setContainingVertex(container);
      }
      this.chainedTasksInSequence.add(chainedTask);
      return;
    }
    final TaskConfig targetVertexConfig=new TaskConfig(targetVertex.getConfiguration());
    for (int inputIndex=0; inConns.hasNext(); inputIndex++) {
      final Channel input=inConns.next();
      TypeSerializerFactory<?> typeSerFact=null;
      for (      Channel inConn : getConnectionsOfInput(input)) {
        if (typeSerFact == null) {
          typeSerFact=inConn.getSerializer();
        }
 else         if (!typeSerFact.equals(inConn.getSerializer())) {
          throw new CompilerException("Conflicting types in union operator.");
        }
        final PlanNode sourceNode=inConn.getSource();
        AbstractJobVertex sourceVertex=this.vertices.get(sourceNode);
        TaskConfig sourceVertexConfig;
        if (sourceVertex == null) {
          final TaskInChain chainedTask=this.chainedTasks.get(sourceNode);
          if (chainedTask.getContainingVertex() == null)           throw new IllegalStateException("Bug: Chained task has not been assigned its containing vertex when connecting.");
          sourceVertex=chainedTask.getContainingVertex();
          sourceVertexConfig=chainedTask.getTaskConfig();
        }
 else {
          sourceVertexConfig=new TaskConfig(sourceVertex.getConfiguration());
        }
        connectJobVertices(inConn,inputIndex,sourceVertex,sourceVertexConfig,targetVertex,targetVertexConfig);
      }
      addLocalInfoFromChannelToConfig(input,targetVertexConfig,inputIndex);
    }
  }
 catch (  Exception e) {
    throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
  }
}
