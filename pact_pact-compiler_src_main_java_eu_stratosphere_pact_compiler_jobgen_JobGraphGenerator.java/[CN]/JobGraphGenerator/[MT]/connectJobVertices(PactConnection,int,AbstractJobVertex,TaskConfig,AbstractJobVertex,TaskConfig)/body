{
  final ChannelType channelType;
  final DistributionPattern distributionPattern;
switch (connection.getShipStrategy().type()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
distributionPattern=DistributionPattern.POINTWISE;
break;
case PARTITION_RANGE:
case PARTITION_HASH:
case BROADCAST:
channelType=ChannelType.NETWORK;
distributionPattern=DistributionPattern.BIPARTITE;
break;
default :
throw new IllegalArgumentException("Unsupported ship-strategy: " + connection.getShipStrategy().name());
}
final TaskConfig tempConfig;
final int[] keyPositions;
final Class<? extends Key>[] keyTypes;
final Contract targetContract=connection.getTargetPact().getPactContract();
if (targetContract instanceof AbstractPact<?>) {
AbstractPact<?> pact=(AbstractPact<?>)targetContract;
if (connection.getShipStrategy() instanceof PartitionShipStrategy) {
Map<Integer,Class<? extends Key>> keyTypeMap=new HashMap<Integer,Class<? extends Key>>();
int[] fields=pact.getKeyColumnNumbers(inputNumber - 1);
for (int i=0; i < fields.length; i++) {
keyTypeMap.put(fields[i],pact.getKeyClasses()[i]);
}
FieldList partitionKeys=((PartitionShipStrategy)connection.getShipStrategy()).getPartitionFields();
keyPositions=new int[partitionKeys.size()];
keyTypes=new Class[partitionKeys.size()];
int i=0;
for (Integer key : partitionKeys) {
keyPositions[i]=key;
keyTypes[i]=keyTypeMap.get(key);
i++;
}
}
 else {
keyPositions=null;
keyTypes=null;
}
}
 else if (targetContract instanceof GenericDataSink) {
final Ordering o=((GenericDataSink)targetContract).getPartitionOrdering();
if (o != null) {
final int numFields=o.getNumberOfFields();
keyPositions=new int[numFields];
keyTypes=new Class[numFields];
for (int i=0; i < numFields; i++) {
keyPositions[i]=o.getFieldNumber(i);
keyTypes[i]=o.getType(i);
}
}
 else {
keyPositions=null;
keyTypes=null;
}
}
 else {
keyPositions=null;
keyTypes=null;
}
final TaskConfig configForOutputShipStrategy;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION,distributionPattern);
configForOutputShipStrategy=outputConfig;
inputConfig.addInputToGroup(inputNumber);
break;
case TEMP_SENDER_SIDE:
int degreeOfParallelism=connection.getSourcePact().getDegreeOfParallelism();
int instancesPerMachine=connection.getSourcePact().getInstancesPerMachine();
JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),degreeOfParallelism,instancesPerMachine);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION,DistributionPattern.POINTWISE);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION,distributionPattern);
tempVertex.setVertexToShareInstancesWith(outputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
configForOutputShipStrategy=tempConfig;
inputConfig.addInputToGroup(inputNumber);
tempConfig.addInputToGroup(1);
break;
case TEMP_RECEIVER_SIDE:
degreeOfParallelism=connection.getTargetPact().getDegreeOfParallelism();
instancesPerMachine=connection.getTargetPact().getInstancesPerMachine();
tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),degreeOfParallelism,instancesPerMachine);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION,distributionPattern);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION,DistributionPattern.POINTWISE);
tempVertex.setVertexToShareInstancesWith(inputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
tempConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
configForOutputShipStrategy=outputConfig;
inputConfig.addInputToGroup(inputNumber);
tempConfig.addInputToGroup(1);
break;
default :
throw new CompilerException("Invalid connection temp mode: " + connection.getTempMode());
}
configForOutputShipStrategy.addOutputShipStrategy(connection.getShipStrategy().type());
if (!(keyPositions == null || keyTypes == null || keyPositions.length == 0 || keyTypes.length == 0)) {
final int outputNum=configForOutputShipStrategy.getNumOutputs() - 1;
configForOutputShipStrategy.setComparatorFactoryForOutput(PactRecordComparatorFactory.class,outputNum);
PactRecordComparatorFactory.writeComparatorSetupToConfig(configForOutputShipStrategy.getConfiguration(),configForOutputShipStrategy.getPrefixForOutputParameters(outputNum),keyPositions,keyTypes);
}
if (targetContract instanceof GenericDataSink) {
final DataDistribution distri=((GenericDataSink)targetContract).getDataDistribution();
if (distri != null) {
configForOutputShipStrategy.setOutputDataDistribution(distri);
}
}
}
