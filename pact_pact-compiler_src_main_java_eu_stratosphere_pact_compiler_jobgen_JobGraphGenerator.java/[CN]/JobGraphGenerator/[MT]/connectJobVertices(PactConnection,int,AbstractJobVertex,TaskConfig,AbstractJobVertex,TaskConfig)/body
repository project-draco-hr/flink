{
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException("Unsupported ship-strategy: " + connection.getShipStrategy().name());
}
TaskConfig tempConfig=null;
final int[] keyPositions;
final Class<? extends Key>[] keyTypes;
final Contract targetContract=connection.getTargetPact().getPactContract();
if (targetContract instanceof AbstractPact<?>) {
AbstractPact<?> pact=(AbstractPact<?>)targetContract;
if (connection.getScramblePartitionedFields() != null) {
int[] originalKeyPositions=pact.getKeyColumnNumbers(inputNumber - 1);
Class<? extends Key>[] originalKeyTypes=pact.getKeyClasses();
int[] scrambleArray=connection.getScramblePartitionedFields();
keyTypes=new Class[scrambleArray.length];
keyPositions=new int[scrambleArray.length];
for (int i=0; i < scrambleArray.length; i++) {
keyPositions[i]=originalKeyPositions[scrambleArray[i]];
keyTypes[i]=originalKeyTypes[scrambleArray[i]];
}
}
 else {
keyPositions=pact.getKeyColumnNumbers(inputNumber - 1);
keyTypes=pact.getKeyClasses();
}
}
 else {
keyPositions=null;
keyTypes=null;
}
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
if ((keyPositions == null | keyTypes == null) || (keyPositions.length == 0 | keyTypes.length == 0)) {
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
}
 else {
outputConfig.addOutputShipStrategy(connection.getShipStrategy(),keyPositions,keyTypes);
}
inputConfig.addInputShipStrategy(connection.getShipStrategy(),inputNumber);
break;
case TEMP_SENDER_SIDE:
int degreeOfParallelism=connection.getSourcePact().getDegreeOfParallelism();
int instancesPerMachine=connection.getSourcePact().getInstancesPerMachine();
JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),degreeOfParallelism,instancesPerMachine);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(outputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD,1);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy(),inputNumber);
break;
case TEMP_RECEIVER_SIDE:
degreeOfParallelism=connection.getTargetPact().getDegreeOfParallelism();
instancesPerMachine=connection.getTargetPact().getInstancesPerMachine();
tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),degreeOfParallelism,instancesPerMachine);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(inputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy(),1);
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD,inputNumber);
break;
default :
throw new CompilerException("Invalid connection temp mode: " + connection.getTempMode());
}
}
