{
  DataSinkNode sNode=(DataSinkNode)sinkNode;
  GenericDataSink sinkContract=sNode.getPactContract();
  JobOutputVertex sinkVertex=new JobOutputVertex(sinkNode.getPactContract().getName(),this.jobGraph);
  sinkVertex.setOutputClass(DataSinkTask.class);
  sinkVertex.getConfiguration().setInteger(DataSinkTask.DEGREE_OF_PARALLELISM_KEY,sinkNode.getDegreeOfParallelism());
  TaskConfig sinkConfig=new TaskConfig(sinkVertex.getConfiguration());
  sinkConfig.setStubClass(sinkContract.getUserCodeClass());
  sinkConfig.setStubParameters(sinkContract.getParameters());
  if (sNode.getLocalStrategy() == LocalStrategy.SORT) {
    assignMemory(sinkConfig,sinkNode.getMemoryPerTask());
    PactRecordComparatorFactory.writeComparatorSetupToConfig(sinkConfig.getConfigForInputParameters(0),sNode.getPactContract().getLocalOrder().getFieldPositions(),sNode.getPactContract().getLocalOrder().getTypes(),sNode.getPactContract().getLocalOrder().getFieldSortDirections());
  }
switch (sinkNode.getLocalStrategy()) {
case NONE:
    sinkConfig.setLocalStrategy(LocalStrategy.NONE);
  break;
case SORT:
sinkConfig.setLocalStrategy(LocalStrategy.SORT);
break;
default :
throw new CompilerException("Invalid local strategy for 'DataSink' (" + sinkNode.getName() + "): "+ sinkNode.getLocalStrategy());
}
return sinkVertex;
}
