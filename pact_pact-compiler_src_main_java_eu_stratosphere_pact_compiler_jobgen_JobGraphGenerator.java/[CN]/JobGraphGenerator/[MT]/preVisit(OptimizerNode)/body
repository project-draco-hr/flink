{
  if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node)) {
    return false;
  }
  final AbstractJobVertex vertex;
  try {
switch (node.getPactType()) {
case Map:
      vertex=generateMapVertex(node);
    break;
case Reduce:
  if (node instanceof ReduceNode) {
    vertex=generateReduceVertex((ReduceNode)node);
  }
 else   if (node instanceof CombinerNode) {
    vertex=generateCombineVertex((CombinerNode)node);
  }
 else {
    throw new CompilerException("Wrong node type for PACT type 'Reduce': " + node.getClass().getName());
  }
break;
case Match:
vertex=generateMatchVertex(node);
break;
case Cross:
vertex=generateCrossVertex(node);
break;
case Cogroup:
vertex=generateCoGroupVertex(node);
break;
case DataSource:
vertex=generateDataSourceVertex(node);
break;
case DataSink:
vertex=generateDataSinkVertex(node);
break;
default :
throw new Exception("Unknown PACT type: " + node.getPactType());
}
}
 catch (Exception e) {
throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
}
if (vertex != null) {
int pd=node.getDegreeOfParallelism();
vertex.setNumberOfSubtasks(pd);
if (this.maxDegreeVertex == null || this.maxDegreeVertex.getNumberOfSubtasks() < pd) {
this.maxDegreeVertex=vertex;
}
if (node.getInstancesPerMachine() >= 1) {
vertex.setNumberOfSubtasksPerInstance(node.getInstancesPerMachine());
}
this.vertices.put(node,vertex);
}
return true;
}
