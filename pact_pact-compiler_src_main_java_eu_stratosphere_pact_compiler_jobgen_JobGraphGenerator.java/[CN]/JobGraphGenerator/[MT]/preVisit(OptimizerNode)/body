{
  if (vertices.containsKey(node)) {
    return false;
  }
  AbstractJobVertex vertex=null;
  try {
switch (node.getPactType()) {
case Map:
      vertex=generateMapVertex(node);
    break;
case Reduce:
  if (node instanceof ReduceNode) {
    vertex=generateReduceVertex((ReduceNode)node);
  }
 else   if (node instanceof CombinerNode) {
    vertex=generateCombineVertex((CombinerNode)node);
  }
 else {
    throw new CompilerException("Wrong node type for PACT type 'Reduce': " + node.getClass().getName());
  }
break;
case Match:
vertex=generateMatchVertex(node);
break;
case Cross:
vertex=generateCrossVertex(node);
break;
case Cogroup:
vertex=generateCoGroupVertex(node);
break;
case GenericDataSource:
vertex=generateDataSourceVertex(node);
break;
case GenericDataSink:
vertex=generateDataSinkVertex(node);
break;
case FileDataSource:
vertex=generateDataSourceVertex(node);
break;
case FileDataSink:
vertex=generateDataSinkVertex(node);
break;
default :
throw new Exception("Unknown PACT type: " + node.getPactType());
}
}
 catch (Exception e) {
throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
}
int pd=node.getDegreeOfParallelism();
vertex.setNumberOfSubtasks(pd);
if (maxDegreeVertex == null || maxDegreeVertex.getNumberOfSubtasks() < pd) {
maxDegreeVertex=vertex;
}
if (node.getInstancesPerMachine() >= 1) {
vertex.setNumberOfSubtasksPerInstance(node.getInstancesPerMachine());
}
this.vertices.put(node,vertex);
return true;
}
