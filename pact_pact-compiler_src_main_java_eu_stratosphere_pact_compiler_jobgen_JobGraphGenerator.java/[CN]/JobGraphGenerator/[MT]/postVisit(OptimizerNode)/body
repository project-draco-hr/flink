{
  try {
    final AbstractJobVertex inputVertex=this.vertices.get(node);
    final List<PactConnection> incomingConns=node.getIncomingConnections();
    if (inputVertex == null) {
      if (incomingConns.size() != 1)       throw new IllegalStateException("Chained task with more than one input!");
      final TaskInChain chainedTask=this.chainedTasks.get(node);
      AbstractJobVertex container=chainedTask.getContainingVertex();
      if (container == null) {
        final PactConnection connection=incomingConns.get(0);
        final OptimizerNode sourceNode=connection.getSourcePact();
        container=this.vertices.get(sourceNode);
        if (container == null) {
          container=this.chainedTasks.get(sourceNode).getContainingVertex();
          if (container == null)           throw new IllegalStateException("Chained task predecessor has not been assigned its containing vertex.");
        }
 else {
          new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategy.FORWARD);
        }
        chainedTask.setContainingVertex(container);
      }
      this.chainedTasksInSequence.add(chainedTask);
      return;
    }
    if (incomingConns == null || incomingConns.isEmpty()) {
      return;
    }
    TaskConfig inputVertexConfig=new TaskConfig(inputVertex.getConfiguration());
    for (int i=0; i < incomingConns.size(); i++) {
      final PactConnection connection=incomingConns.get(i);
      final OptimizerNode sourceNode=connection.getSourcePact();
      AbstractJobVertex outputVertex=this.vertices.get(sourceNode);
      TaskConfig outputVertexConfig;
      if (outputVertex == null) {
        final TaskInChain chainedTask=this.chainedTasks.get(sourceNode);
        if (chainedTask.getContainingVertex() == null)         throw new IllegalStateException("Chained task predecessor has not been assigned its containing vertex.");
        outputVertex=chainedTask.getContainingVertex();
        outputVertexConfig=chainedTask.getTaskConfig();
      }
 else {
        outputVertexConfig=new TaskConfig(outputVertex.getConfiguration());
      }
switch (connection.getShipStrategy()) {
case FORWARD:
        connectWithForwardStrategy(connection,i,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
      break;
case PARTITION_LOCAL_HASH:
case PARTITION_HASH:
    connectWithPartitionStrategy(connection,i,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
  break;
case BROADCAST:
connectWithBroadcastStrategy(connection,i,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
break;
case PARTITION_RANGE:
if (isDistributionGiven(connection)) {
connectWithGivenDistributionPartitionRangeStrategy(connection,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
}
 else {
connectWithSamplingPartitionRangeStrategy(connection,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
}
break;
case SFR:
connectWithSFRStrategy(connection,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
default :
throw new Exception("Invalid ship strategy: " + connection.getShipStrategy());
}
}
}
 catch (Exception e) {
throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
}
}
