{
  try {
    AbstractJobVertex inputVertex=this.vertices.get(node);
    List<PactConnection> inConns=node.getIncomingConnections();
    if (inConns == null) {
      return;
    }
    if (inputVertex == null) {
      if (inConns.size() != 1) {
        throw new IllegalStateException("Chained task with more than one input!");
      }
      PactConnection inConn=inConns.get(0);
      final TaskInChain chainedTask=this.chainedTasks.get(node);
      AbstractJobVertex container=chainedTask.getContainingVertex();
      if (container == null) {
        final PactConnection connection=inConn;
        final OptimizerNode sourceNode=connection.getSourcePact();
        container=this.vertices.get(sourceNode);
        if (container == null) {
          container=this.chainedTasks.get(sourceNode).getContainingVertex();
          if (container == null)           throw new IllegalStateException("Chained task predecessor has not been assigned its containing vertex.");
        }
 else {
          new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategy.FORWARD);
        }
        chainedTask.setContainingVertex(container);
      }
      this.chainedTasksInSequence.add(chainedTask);
      return;
    }
    final TaskConfig inputVertexConfig=new TaskConfig(inputVertex.getConfiguration());
    int inputIndex=1;
    for (    PactConnection inConn : inConns) {
      boolean firstRun=true;
      final OptimizerNode sourceNode=inConn.getSourcePact();
      AbstractJobVertex outputVertex=this.vertices.get(sourceNode);
      TaskConfig outputVertexConfig;
      if (outputVertex == null) {
        final TaskInChain chainedTask=this.chainedTasks.get(sourceNode);
        if (chainedTask.getContainingVertex() == null)         throw new IllegalStateException("Chained task predecessor has not been assigned its containing vertex.");
        outputVertex=chainedTask.getContainingVertex();
        outputVertexConfig=chainedTask.getTaskConfig();
      }
 else {
        outputVertexConfig=new TaskConfig(outputVertex.getConfiguration());
      }
switch (inConn.getShipStrategy()) {
case FORWARD:
        connectWithForwardStrategy(inConn,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
      break;
case PARTITION_LOCAL_HASH:
case PARTITION_HASH:
    connectWithPartitionStrategy(inConn,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
  break;
case BROADCAST:
connectWithBroadcastStrategy(inConn,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
break;
case PARTITION_RANGE:
if (isDistributionGiven(inConn)) {
connectWithGivenDistributionPartitionRangeStrategy(inConn,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
}
 else {
connectWithSamplingPartitionRangeStrategy(inConn,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig,firstRun);
}
break;
case SFR:
connectWithSFRStrategy(inConn,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
default :
throw new Exception("Invalid ship strategy: " + inConn.getShipStrategy());
}
firstRun=false;
++inputIndex;
}
}
 catch (Exception e) {
throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
}
}
