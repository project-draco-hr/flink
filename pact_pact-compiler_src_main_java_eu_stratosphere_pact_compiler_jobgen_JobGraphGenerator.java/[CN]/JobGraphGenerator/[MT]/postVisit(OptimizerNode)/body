{
  try {
    AbstractJobVertex inputVertex=this.vertices.get(node);
    List<List<PactConnection>> incomingConns=node.getIncomingConnections();
    if (incomingConns == null) {
      return;
    }
    if (inputVertex == null) {
      if (incomingConns.size() != 1) {
        throw new IllegalStateException("Chained task with more than one input!");
      }
      List<PactConnection> connections=incomingConns.get(0);
      if (connections.size() != 1) {
        throw new IllegalStateException("Chained task with more than one input!");
      }
      final TaskInChain chainedTask=this.chainedTasks.get(node);
      AbstractJobVertex container=chainedTask.getContainingVertex();
      if (container == null) {
        final PactConnection connection=connections.get(0);
        final OptimizerNode sourceNode=connection.getSourcePact();
        container=this.vertices.get(sourceNode);
        if (container == null) {
          container=this.chainedTasks.get(sourceNode).getContainingVertex();
          if (container == null)           throw new IllegalStateException("Chained task predecessor has not been assigned its containing vertex.");
        }
 else {
          new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategy.FORWARD);
        }
        chainedTask.setContainingVertex(container);
      }
      this.chainedTasksInSequence.add(chainedTask);
      return;
    }
    final TaskConfig inputVertexConfig=new TaskConfig(inputVertex.getConfiguration());
    int inputIndex=1;
    for (    List<PactConnection> cl : incomingConns) {
      boolean firstRun=true;
      for (      PactConnection connection : cl) {
        final OptimizerNode sourceNode=connection.getSourcePact();
        AbstractJobVertex outputVertex=this.vertices.get(sourceNode);
        TaskConfig outputVertexConfig;
        if (outputVertex == null) {
          final TaskInChain chainedTask=this.chainedTasks.get(sourceNode);
          if (chainedTask.getContainingVertex() == null)           throw new IllegalStateException("Chained task predecessor has not been assigned its containing vertex.");
          outputVertex=chainedTask.getContainingVertex();
          outputVertexConfig=chainedTask.getTaskConfig();
        }
 else {
          outputVertexConfig=new TaskConfig(outputVertex.getConfiguration());
        }
switch (connection.getShipStrategy()) {
case FORWARD:
          connectWithForwardStrategy(connection,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
        break;
case PARTITION_LOCAL_HASH:
case PARTITION_HASH:
      connectWithPartitionStrategy(connection,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
    break;
case BROADCAST:
  connectWithBroadcastStrategy(connection,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
break;
case PARTITION_RANGE:
if (isDistributionGiven(connection)) {
connectWithGivenDistributionPartitionRangeStrategy(connection,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
}
 else {
connectWithSamplingPartitionRangeStrategy(connection,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig,firstRun);
}
break;
case SFR:
connectWithSFRStrategy(connection,inputIndex,outputVertex,outputVertexConfig,inputVertex,inputVertexConfig);
default :
throw new Exception("Invalid ship strategy: " + connection.getShipStrategy());
}
firstRun=false;
}
++inputIndex;
}
}
 catch (Exception e) {
throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
}
}
