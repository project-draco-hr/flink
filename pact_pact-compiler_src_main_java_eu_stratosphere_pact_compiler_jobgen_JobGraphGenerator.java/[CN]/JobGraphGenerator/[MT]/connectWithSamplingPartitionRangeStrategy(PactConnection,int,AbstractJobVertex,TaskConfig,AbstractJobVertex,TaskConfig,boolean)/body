{
  int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceIPM=connection.getSourcePact().getInstancesPerMachine();
  int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
  Class<?> sourceStub=connection.getSourcePact().getPactContract().getUserCodeClass();
  if (targetDOP == 1) {
    if (sourceDOP == 1) {
      outputVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    }
 else {
      outputVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    }
    outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
    inputConfig.addInputShipStrategy(ShipStrategy.FORWARD,inputNumber);
    return;
  }
  JobTaskVertex sampleVertex=new JobTaskVertex("Range partition - sampling",this.jobGraph);
  this.auxVertices.add(sampleVertex);
  sampleVertex.setTaskClass(SampleTask.class);
  TaskConfig sampleConfig=new TaskConfig(sampleVertex.getConfiguration());
  sampleVertex.setNumberOfSubtasks(sourceDOP);
  if (sourceIPM >= 1) {
    sampleVertex.setNumberOfSubtasksPerInstance(sourceIPM);
  }
  sampleConfig.setStubClass(sourceStub);
  outputVertex.connectTo(sampleVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  sampleConfig.addInputShipStrategy(ShipStrategy.FORWARD,1);
  TaskConfig histogramConfig;
  if (firstCall) {
    this.histogramVertex=new JobTaskVertex("Range partition - histograming",this.jobGraph);
    this.auxVertices.add(this.histogramVertex);
    this.histogramVertex.setTaskClass(HistogramTask.class);
    this.histogramVertex.setNumberOfSubtasks(1);
    this.numberOfHistogramInputs=0;
    histogramConfig=new TaskConfig(this.histogramVertex.getConfiguration());
    histogramConfig.setStubClass(sourceStub);
    histogramConfig.setLocalStrategy(LocalStrategy.SORT);
    Configuration histogramStubConfig=new Configuration();
    histogramStubConfig.setInteger(HistogramTask.NUMBER_OF_BUCKETS,targetDOP);
    histogramConfig.setStubParameters(histogramStubConfig);
    assignMemory(histogramConfig,outputConfig.getStubParameters().getInteger(HistogramTask.HISTOGRAM_MEMORY,-1));
  }
 else {
    histogramConfig=new TaskConfig(this.histogramVertex.getConfiguration());
  }
  histogramConfig.addInputShipStrategy(ShipStrategy.FORWARD,++this.numberOfHistogramInputs);
  sampleConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  sampleVertex.connectTo(this.histogramVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  JobTaskVertex partitionVertex=new JobTaskVertex("Range partition - partitioning",this.jobGraph);
  this.auxVertices.add(partitionVertex);
  partitionVertex.setTaskClass(PartitionTask.class);
  partitionVertex.setNumberOfSubtasks(sourceDOP);
  if (sourceIPM >= 1) {
    partitionVertex.setNumberOfSubtasksPerInstance(sourceIPM);
  }
  TaskConfig partitionConfig=new TaskConfig(partitionVertex.getConfiguration());
  partitionConfig.setStubClass(sourceStub);
  Configuration partitionStubConfig=new Configuration();
  partitionStubConfig.setString(PartitionTask.GLOBAL_PARTITIONING_ORDER,connection.getTargetPact().getGlobalProperties().getKeyOrder().name());
  partitionConfig.setStubParameters(partitionStubConfig);
  JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),sourceDOP,sourceIPM);
  tempVertex.setVertexToShareInstancesWith(outputVertex);
  TaskConfig tempConfig=new TaskConfig(tempVertex.getConfiguration());
  outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  tempConfig.addInputShipStrategy(ShipStrategy.FORWARD,1);
  outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  tempVertex.connectTo(partitionVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  partitionConfig.addInputShipStrategy(ShipStrategy.FORWARD,2);
  tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  this.histogramVertex.connectTo(partitionVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  partitionConfig.addInputShipStrategy(ShipStrategy.BROADCAST,1);
  histogramConfig.addOutputShipStrategy(ShipStrategy.BROADCAST);
  partitionVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  inputConfig.addInputShipStrategy(ShipStrategy.PARTITION_RANGE,inputNumber);
  partitionConfig.addOutputShipStrategy(ShipStrategy.PARTITION_RANGE);
}
