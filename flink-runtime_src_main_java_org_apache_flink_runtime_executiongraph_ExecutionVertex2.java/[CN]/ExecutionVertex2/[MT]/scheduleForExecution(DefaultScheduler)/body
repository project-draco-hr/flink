{
  if (scheduler == null) {
    throw new NullPointerException();
  }
  if (STATE_UPDATER.compareAndSet(this,CREATED,SCHEDULED)) {
    getExecutionGraph().notifyExecutionChange(getJobvertexId(),subTaskIndex,SCHEDULED,null);
    ScheduledUnit toSchedule=new ScheduledUnit(this,jobVertex.getSlotSharingGroup());
    boolean queued=jobVertex.getGraph().isQueuedSchedulingAllowed();
    if (queued) {
      SlotAllocationFuture future=scheduler.scheduleQueued(toSchedule);
      future.setFutureAction(new SlotAllocationFutureAction(){
        @Override public void slotAllocated(        AllocatedSlot slot){
          try {
            deployToSlot(slot);
          }
 catch (          Throwable t) {
            try {
              slot.releaseSlot();
            }
  finally {
              fail(t);
            }
          }
        }
      }
);
    }
 else {
      AllocatedSlot slot=scheduler.scheduleImmediately(toSchedule);
      try {
        deployToSlot(slot);
      }
 catch (      Throwable t) {
        try {
          slot.releaseSlot();
        }
  finally {
          fail(t);
        }
      }
    }
  }
 else   if (this.state == CANCELED) {
    return;
  }
 else {
    throw new IllegalStateException("The vertex must be in CREATED state to be scheduled.");
  }
}
