{
  if (slot == null) {
    throw new NullPointerException();
  }
  if (!slot.isAlive()) {
    throw new IllegalArgumentException("Cannot deploy to a slot that is not alive.");
  }
  ExecutionState2 previous=this.state;
  if (previous == SCHEDULED || previous == CREATED) {
    if (!STATE_UPDATER.compareAndSet(this,previous,DEPLOYING)) {
      throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.");
    }
    getExecutionGraph().notifyExecutionChange(getJobvertexId(),subTaskIndex,DEPLOYING,null);
  }
 else {
    throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous);
  }
  if (!slot.setExecutedVertex(this)) {
    throw new JobException("Could not assign the ExecutionVertex to the slot " + slot);
  }
  setAssignedSlot(slot);
  final TaskDeploymentDescriptor deployment=createDeploymentDescriptor();
  Runnable deployaction=new Runnable(){
    @Override public void run(){
      try {
        Instance instance=slot.getInstance();
        instance.checkLibraryAvailability(getJobId());
        TaskOperationResult result=instance.getTaskManagerProxy().submitTask(deployment);
        if (result.isSuccess()) {
          switchToRunning();
        }
 else {
          fail(new Exception("Failed to deploy the tast to slot " + slot + ": "+ result.getDescription()));
        }
      }
 catch (      Throwable t) {
        fail(t);
      }
    }
  }
;
  execute(deployaction);
}
