{
  final int NUM_TASKS=20;
  try {
    final AbstractJobVertex sender=new AbstractJobVertex("Sender");
    final AbstractJobVertex receiver=new AbstractJobVertex("Receiver");
    sender.setInvokableClass(Sender.class);
    receiver.setInvokableClass(BlockingReceiver.class);
    sender.setParallelism(NUM_TASKS);
    receiver.setParallelism(NUM_TASKS);
    receiver.connectNewDataSetAsInput(sender,DistributionPattern.POINTWISE);
    SlotSharingGroup sharingGroup=new SlotSharingGroup();
    sender.setSlotSharingGroup(sharingGroup);
    receiver.setSlotSharingGroup(sharingGroup);
    final JobGraph jobGraph=new JobGraph("Pointwise Job",sender,receiver);
    final JobManager jm=startJobManager(2,NUM_TASKS / 2);
    final TaskManager tm1=((LocalInstanceManager)jm.getInstanceManager()).getTaskManagers()[0];
    final TaskManager tm2=((LocalInstanceManager)jm.getInstanceManager()).getTaskManagers()[1];
    final GlobalBufferPool bp1=tm1.getChannelManager().getGlobalBufferPool();
    final GlobalBufferPool bp2=tm2.getChannelManager().getGlobalBufferPool();
    try {
      LibraryCacheManager.register(jobGraph.getJobID(),new String[0]);
      JobSubmissionResult result=jm.submitJob(jobGraph);
      if (result.getReturnCode() != AbstractJobResult.ReturnCode.SUCCESS) {
        System.out.println(result.getDescription());
      }
      assertEquals(AbstractJobResult.ReturnCode.SUCCESS,result.getReturnCode());
      ExecutionGraph eg=jm.getCurrentJobs().get(jobGraph.getJobID());
      long deadline=System.currentTimeMillis() + 2000;
      while (System.currentTimeMillis() < deadline) {
        boolean allrunning=true;
        for (        ExecutionVertex v : eg.getJobVertex(receiver.getID()).getTaskVertices()) {
          if (v.getCurrentExecutionAttempt().getState() != ExecutionState.RUNNING) {
            allrunning=false;
            break;
          }
        }
        if (allrunning) {
          break;
        }
        Thread.sleep(200);
      }
      TaskManager tm=((LocalInstanceManager)jm.getInstanceManager()).getTaskManagers()[0];
      tm.shutdown();
      eg.waitForJobEnd();
      waitForTaskThreadsToBeTerminated();
      assertTrue(bp1.isDestroyed() || bp1.numBuffers() == bp1.numAvailableBuffers());
      assertTrue(bp2.isDestroyed() || bp2.numBuffers() == bp2.numAvailableBuffers());
    }
  finally {
      jm.shutdown();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
