{
  SopremoModule module=new SopremoModule(getName(),1,1);
  RecordLinkageInput recordLinkageInput=this.recordLinkageInput.clone();
  recordLinkageInput.setSource(module.getInput(0).getSource());
  EvaluationExpression resultProjection=this.recordLinkageInput.getResultProjection();
  if (this.linkageMode.ordinal() >= LinkageMode.TRANSITIVE_LINKS.ordinal() && !recordLinkageInput.getResultProjection().equals(recordLinkageInput.getIdProjection()))   recordLinkageInput.setResultProjection(recordLinkageInput.getIdProjection());
  Operator duplicatePairs;
  if (this.algorithm instanceof IntraSourceRecordLinkageAlgorithm)   duplicatePairs=((IntraSourceRecordLinkageAlgorithm)this.algorithm).getIntraSource(this.similarityCondition,recordLinkageInput);
 else   duplicatePairs=this.simulateIntraSource();
  if (this.linkageMode == LinkageMode.LINKS_ONLY) {
    module.getOutput(0).setInput(0,duplicatePairs);
    return module;
  }
  Operator output;
  final TransitiveClosure closure=new TransitiveClosure(duplicatePairs);
  ClosureMode closureMode=this.linkageMode.getClosureMode();
  if (closureMode.isCluster())   closureMode=ClosureMode.CLUSTER;
  closure.setClosureMode(closureMode);
  output=closure;
  if (recordLinkageInput.getResultProjection() != resultProjection) {
    Operator reverseLookup=new Lookup().withDictionaryKeyExtraction(this.recordLinkageInput.getIdProjection()).withDictionaryValueExtraction(this.recordLinkageInput.getResultProjection()).withArrayElementsReplacement(true).withInputs(closure,module.getInput(0));
    output=reverseLookup;
  }
  if (!this.linkageMode.isWithSingles()) {
    module.getOutput(0).setInput(0,output);
    return module;
  }
  ValueSplitter allTuples=new ValueSplitter(closure).withArrayProjection(EvaluationExpression.VALUE).withKeyProjection(new ArrayAccess(0)).withValueProjection(EvaluationExpression.NULL);
  allTuples.setName("all tuples");
  Operator singleRecords=new Difference().withKeyProjection(0,this.recordLinkageInput.getIdProjection()).withValueProjection(0,this.recordLinkageInput.getResultProjection()).withKeyProjection(1,EvaluationExpression.KEY).withInputs(module.getInput(0),allTuples);
  singleRecords.setName("singleRecords");
  final Operator wrappedInArray=new Projection().withValueTransformation(new ArrayCreation(EvaluationExpression.VALUE)).withInputs(singleRecords);
  module.getOutput(0).setInput(0,new UnionAll().withInputs(wrappedInArray,output));
  return module;
}
