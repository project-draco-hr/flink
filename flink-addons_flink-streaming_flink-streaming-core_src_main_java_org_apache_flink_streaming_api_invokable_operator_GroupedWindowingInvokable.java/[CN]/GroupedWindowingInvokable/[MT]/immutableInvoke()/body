{
  if ((reuse=recordIterator.next(reuse)) == null) {
    throw new RuntimeException("DataStream must not be empty");
  }
  while (reuse != null) {
    WindowingInvokable<IN> groupInvokable=windowingGroups.get(keySelector.getKey(reuse.getObject()));
    if (groupInvokable == null) {
      groupInvokable=makeNewGroup(reuse);
    }
    for (    ActiveTriggerPolicy<IN> trigger : activeCentralTriggerPolicies) {
      IN[] result=trigger.preNotifyTrigger(reuse.getObject());
      for (      IN in : result) {
        for (        WindowingInvokable<IN> group : windowingGroups.values()) {
          group.processFakeElement(in,trigger);
        }
      }
    }
    for (    TriggerPolicy<IN> triggerPolicy : centralTriggerPolicies) {
      if (triggerPolicy.notifyTrigger(reuse.getObject())) {
        currentTriggerPolicies.add(triggerPolicy);
      }
    }
    if (currentTriggerPolicies.isEmpty()) {
      groupInvokable.processRealElement(reuse.getObject());
    }
 else {
      for (      WindowingInvokable<IN> group : windowingGroups.values()) {
        if (group == groupInvokable) {
          group.processRealElement(reuse.getObject(),currentTriggerPolicies);
        }
 else {
          group.externalTriggerFakeElement(reuse.getObject(),currentTriggerPolicies);
        }
      }
    }
    currentTriggerPolicies.clear();
    resetReuse();
    reuse=recordIterator.next(reuse);
  }
  for (  Thread t : activePolicyThreads) {
    t.interrupt();
  }
  for (  WindowingInvokable<IN> group : windowingGroups.values()) {
    group.emitFinalWindow(centralTriggerPolicies);
  }
}
