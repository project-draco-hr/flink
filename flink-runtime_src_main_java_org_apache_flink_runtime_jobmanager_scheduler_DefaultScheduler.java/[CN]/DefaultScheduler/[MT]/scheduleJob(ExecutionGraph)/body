{
  final int requiredSlots=executionGraph.getRequiredSlots();
  final int availableSlots=this.getInstanceManager().getNumberOfSlots();
  if (requiredSlots > availableSlots) {
    throw new SchedulingException(String.format("Not enough available task slots to run job %s (%s). Required: %d Available: %d . " + "Either reduce the parallelism of your program, wait for other programs to finish, or increase " + "the number of task slots in the cluster by adding more machines or increasing the number of slots "+ "per machine in conf/flink-conf.yaml .",executionGraph.getJobName(),executionGraph.getJobID(),requiredSlots,availableSlots));
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    vertex.registerExecutionListener(new DefaultExecutionListener(this,vertex));
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    final String exceptionMessage=StringUtils.stringifyException(e);
    LOG.error(exceptionMessage);
    this.jobQueue.remove(executionGraph);
    throw new SchedulingException(exceptionMessage);
  }
}
