{
  try {
    while (running) {
      try {
        Thread.sleep(commitInterval);
        long[] currentOffsets=Arrays.copyOf(consumer.lastOffsets,consumer.lastOffsets.length);
        Map<TopicPartition,Long> offsetsToCommit=new HashMap<>();
        for (        TopicPartition tp : (List<TopicPartition>)consumer.subscribedPartitions) {
          int partition=tp.partition();
          long offset=currentOffsets[partition];
          long lastCommitted=consumer.commitedOffsets[partition];
          if (offset != OFFSET_NOT_SET) {
            if (offset > lastCommitted) {
              offsetsToCommit.put(tp,offset);
              LOG.debug("Committing offset {} for partition {}",offset,partition);
            }
 else {
              LOG.debug("Ignoring offset {} for partition {} because it is already committed",offset,partition);
            }
          }
        }
        consumer.offsetHandler.commit(offsetsToCommit);
      }
 catch (      InterruptedException e) {
        if (running) {
          throw e;
        }
        break;
      }
    }
  }
 catch (  Throwable t) {
    LOG.warn("Periodic checkpoint committer is stopping the fetcher because of an error",t);
    consumer.fetcher.stopWithError(t);
  }
}
