{
  if (highDop < lowDop) {
    throw new IllegalArgumentException();
  }
  final int factor=highDop / lowDop;
  final int delta=highDop % lowDop == 0 ? 0 : 1;
  AbstractJobVertex v1=new AbstractJobVertex("vertex1");
  AbstractJobVertex v2=new AbstractJobVertex("vertex2");
  v1.setParallelism(lowDop);
  v2.setParallelism(highDop);
  v2.connectNewDataSetAsInput(v1,DistributionPattern.POINTWISE);
  List<AbstractJobVertex> ordered=new ArrayList<AbstractJobVertex>(Arrays.asList(v1,v2));
  ExecutionGraph eg=new ExecutionGraph(jobId,jobName,cfg);
  try {
    eg.attachJobGraph(ordered);
  }
 catch (  JobException e) {
    e.printStackTrace();
    fail("Job failed with exception: " + e.getMessage());
  }
  ExecutionJobVertex target=eg.getAllVertices().get(v2.getID());
  int[] timesUsed=new int[lowDop];
  for (  ExecutionVertex ev : target.getTaskVertices()) {
    assertEquals(1,ev.getNumberOfInputs());
    ExecutionEdge[] inEdges=ev.getInputEdges(0);
    assertEquals(1,inEdges.length);
    timesUsed[inEdges[0].getSource().getPartitionNumber()]++;
  }
  for (int i=0; i < timesUsed.length; i++) {
    assertTrue(timesUsed[i] >= factor && timesUsed[i] <= factor + delta);
  }
}
