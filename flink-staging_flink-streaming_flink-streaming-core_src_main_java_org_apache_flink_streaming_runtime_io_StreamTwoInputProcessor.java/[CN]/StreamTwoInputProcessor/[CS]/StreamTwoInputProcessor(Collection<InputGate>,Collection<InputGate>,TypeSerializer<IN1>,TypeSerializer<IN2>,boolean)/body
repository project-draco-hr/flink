{
  super(InputGateUtil.createInputGate(inputGates1,inputGates2));
  barrierBuffer=new BarrierBuffer(inputGate,this);
  StreamRecordSerializer<IN1> inputRecordSerializer1;
  if (enableWatermarkMultiplexing) {
    inputRecordSerializer1=new MultiplexingStreamRecordSerializer<IN1>(inputSerializer1);
  }
 else {
    inputRecordSerializer1=new StreamRecordSerializer<IN1>(inputSerializer1);
  }
  this.deserializationDelegate1=new NonReusingDeserializationDelegate(inputRecordSerializer1);
  StreamRecordSerializer<IN2> inputRecordSerializer2;
  if (enableWatermarkMultiplexing) {
    inputRecordSerializer2=new MultiplexingStreamRecordSerializer<IN2>(inputSerializer2);
  }
 else {
    inputRecordSerializer2=new StreamRecordSerializer<IN2>(inputSerializer2);
  }
  this.deserializationDelegate2=new NonReusingDeserializationDelegate(inputRecordSerializer2);
  this.recordDeserializers=new SpillingAdaptiveSpanningRecordDeserializer[inputGate.getNumberOfInputChannels()];
  for (int i=0; i < recordDeserializers.length; i++) {
    recordDeserializers[i]=new SpillingAdaptiveSpanningRecordDeserializer();
  }
  numInputChannels1=0;
  for (  InputGate gate : inputGates1) {
    numInputChannels1+=gate.getNumberOfInputChannels();
  }
  numInputChannels2=inputGate.getNumberOfInputChannels() - numInputChannels1;
  watermarks1=new long[numInputChannels1];
  for (int i=0; i < numInputChannels1; i++) {
    watermarks1[i]=Long.MIN_VALUE;
  }
  lastEmittedWatermark1=Long.MIN_VALUE;
  watermarks2=new long[numInputChannels2];
  for (int i=0; i < numInputChannels2; i++) {
    watermarks2[i]=Long.MIN_VALUE;
  }
  lastEmittedWatermark2=Long.MIN_VALUE;
}
