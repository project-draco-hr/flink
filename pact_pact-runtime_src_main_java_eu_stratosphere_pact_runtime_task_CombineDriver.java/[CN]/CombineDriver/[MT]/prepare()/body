{
  final TaskConfig config=this.taskContext.getTaskConfig();
  final long availableMemory=config.getMemorySize();
  LocalStrategy ls=config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case COMBININGSORT:
    strategyMinMem=MIN_REQUIRED_MEMORY;
  break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException("The Combine task was initialized with too little memory for local strategy " + config.getLocalStrategy() + " : "+ availableMemory+ " bytes."+ "Required is at least "+ strategyMinMem+ " bytes.");
}
final MemoryManager memoryManager=this.taskContext.getMemoryManager();
final MutableObjectIterator<T> in=this.taskContext.getInput(0);
this.serializer=this.taskContext.getInputSerializer(0);
this.comparator=this.taskContext.getInputComparator(0);
switch (ls) {
case COMBININGSORT:
input=new AsynchronousPartialSorter<T>(memoryManager,in,this.taskContext.getOwningNepheleTask(),this.serializer,this.comparator.duplicate(),availableMemory);
break;
default :
throw new RuntimeException("Invalid local strategy provided for CombineTask.");
}
}
