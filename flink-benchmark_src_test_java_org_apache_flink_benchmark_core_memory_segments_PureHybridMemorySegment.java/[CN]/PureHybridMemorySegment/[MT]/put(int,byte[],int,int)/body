{
  if ((offset | length | (offset + length)| (src.length - (offset + length))) < 0) {
    throw new IndexOutOfBoundsException();
  }
  long pos=address + index;
  if (index >= 0 && pos <= addressLimit - length) {
    long arrayAddress=BYTE_ARRAY_BASE_OFFSET + offset;
    while (length > 0) {
      long toCopy=Math.min(length,COPY_PER_BATCH);
      UNSAFE.copyMemory(src,arrayAddress,heapMemory,pos,toCopy);
      length-=toCopy;
      pos+=toCopy;
      arrayAddress+=toCopy;
    }
  }
 else   if (address > addressLimit) {
    throw new IllegalStateException("This segment has been freed.");
  }
 else {
    throw new IndexOutOfBoundsException();
  }
}
