{
  this.inputSplitManager.registerJob(verticesToBeDeployed.get(0).getExecutionGraph());
  for (  final ExecutionVertex vertex : verticesToBeDeployed)   vertex.updateExecutionState(ExecutionState.STARTING,null);
  final Runnable deploymentRunnable=new Runnable(){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
      final List<TaskSubmissionWrapper> submissionList=new SerializableArrayList<TaskSubmissionWrapper>();
      for (      final ExecutionVertex vertex : verticesToBeDeployed) {
        Environment environment=vertex.getEnvironment();
        environment.setInputSplitProvider(new MockInputSplitProvider(vertex));
        submissionList.add(new TaskSubmissionWrapper(vertex.getID(),environment,vertex.getExecutionGraph().getJobConfiguration(),vertex.constructInitialActiveOutputChannelsSet()));
      }
      List<TaskSubmissionResult> submissionResultList=null;
      try {
        submissionResultList=instance.submitTasks(submissionList);
      }
 catch (      final IOException ioe) {
        for (        final ExecutionVertex vertex : verticesToBeDeployed)         Assert.fail(ioe.getMessage() + " @ " + vertex);
        return;
      }
      int count=0;
      for (      final TaskSubmissionResult tsr : submissionResultList) {
        ExecutionVertex vertex=verticesToBeDeployed.get(count++);
        if (tsr.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR)         vertex.updateExecutionState(ExecutionState.FAILED,tsr.getDescription());
      }
    }
  }
;
  ConcurrentUtil.invokeLater(deploymentRunnable);
}
