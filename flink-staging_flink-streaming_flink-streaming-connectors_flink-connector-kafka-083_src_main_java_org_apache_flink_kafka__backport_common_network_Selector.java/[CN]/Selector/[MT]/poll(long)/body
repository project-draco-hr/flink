{
  clear();
  long startSelect=time.nanoseconds();
  int readyKeys=select(timeout);
  long endSelect=time.nanoseconds();
  currentTimeNanos=endSelect;
  this.sensors.selectTime.record(endSelect - startSelect,time.milliseconds());
  if (readyKeys > 0) {
    Set<SelectionKey> keys=this.nioSelector.selectedKeys();
    Iterator<SelectionKey> iter=keys.iterator();
    while (iter.hasNext()) {
      SelectionKey key=iter.next();
      iter.remove();
      Transmissions transmissions=transmissions(key);
      SocketChannel channel=channel(key);
      sensors.maybeRegisterConnectionMetrics(transmissions.id);
      lruConnections.put(transmissions.id,currentTimeNanos);
      try {
        if (key.isConnectable()) {
          channel.finishConnect();
          key.interestOps(key.interestOps() & ~SelectionKey.OP_CONNECT | SelectionKey.OP_READ);
          this.connected.add(transmissions.id);
          this.sensors.connectionCreated.record();
          log.debug("Connection {} created",transmissions.id);
        }
        if (key.isReadable()) {
          if (!transmissions.hasReceive())           transmissions.receive=new NetworkReceive(maxReceiveSize,transmissions.id);
          try {
            transmissions.receive.readFrom(channel);
          }
 catch (          InvalidReceiveException e) {
            log.error("Invalid data received from " + transmissions.id + " closing connection",e);
            close(transmissions.id);
            this.disconnected.add(transmissions.id);
            throw e;
          }
          if (transmissions.receive.complete()) {
            transmissions.receive.payload().rewind();
            this.completedReceives.add(transmissions.receive);
            this.sensors.recordBytesReceived(transmissions.id,transmissions.receive.payload().limit());
            transmissions.clearReceive();
          }
        }
        if (key.isWritable()) {
          transmissions.send.writeTo(channel);
          if (transmissions.send.completed()) {
            this.completedSends.add(transmissions.send);
            this.sensors.recordBytesSent(transmissions.id,transmissions.send.size());
            transmissions.clearSend();
            key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);
          }
        }
        if (!key.isValid()) {
          close(transmissions.id);
          this.disconnected.add(transmissions.id);
        }
      }
 catch (      IOException e) {
        String desc=socketDescription(channel);
        if (e instanceof EOFException || e instanceof ConnectException)         log.debug("Connection {} disconnected",desc);
 else         log.warn("Error in I/O with connection to {}",desc,e);
        close(transmissions.id);
        this.disconnected.add(transmissions.id);
      }
    }
  }
  long endIo=time.nanoseconds();
  this.sensors.ioTime.record(endIo - endSelect,time.milliseconds());
  maybeCloseOldestConnection();
}
