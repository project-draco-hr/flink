{
  try {
    final JobGraph jobGraph=getJobGraph(plan);
    final Thread currentThread=Thread.currentThread();
    final AtomicReference<Throwable> error=new AtomicReference<Throwable>();
    boolean jobSuccessfullyCancelled=false;
    new Thread(){
      @Override public void run(){
        try {
          Thread.sleep(msecsTillCanceling);
          executor.getLeaderGateway(TestingUtils.TESTING_DURATION()).tell(new JobManagerMessages.CancelJob(jobGraph.getJobID()));
        }
 catch (        Throwable t) {
          error.set(t);
          currentThread.interrupt();
        }
      }
    }
.run();
    try {
      executor.submitJobAndWait(jobGraph,false);
    }
 catch (    JobCancellationException exception) {
      jobSuccessfullyCancelled=true;
    }
catch (    Exception e) {
      throw new IllegalStateException("Job failed.",e);
    }
    if (!jobSuccessfullyCancelled) {
      throw new IllegalStateException("Job was not successfully cancelled.");
    }
  }
 catch (  Exception e) {
    LOG.error("Exception found in runAndCancelJob.",e);
    Assert.fail(StringUtils.stringifyException(e));
  }
}
