{
  try {
    final JobGraph jobGraph=getJobGraph(plan);
    final long startingTime=System.currentTimeMillis();
    long cancelTime=-1L;
    final JobClient client=this.executor.getJobClient(jobGraph);
    final JobSubmissionResult submissionResult=client.submitJob();
    if (submissionResult.getReturnCode() != AbstractJobResult.ReturnCode.SUCCESS) {
      throw new IllegalStateException(submissionResult.getDescription());
    }
    final int interval=client.getRecommendedPollingInterval();
    final long sleep=interval * 1000L;
    Thread.sleep(sleep / 2);
    long lastProcessedEventSequenceNumber=-1L;
    while (true) {
      if (Thread.interrupted()) {
        throw new IllegalStateException("Job client has been interrupted");
      }
      final long now=System.currentTimeMillis();
      if (cancelTime < 0L) {
        if (startingTime + msecsTillCanceling < now) {
          LOG.info("Issuing cancel request");
          final JobCancelResult jcr=client.cancelJob();
          if (jcr == null) {
            throw new IllegalStateException("Return value of cancelJob is null!");
          }
          if (jcr.getReturnCode() != AbstractJobResult.ReturnCode.SUCCESS) {
            throw new IllegalStateException(jcr.getDescription());
          }
          cancelTime=now;
        }
      }
 else {
        if (cancelTime + maxTimeTillCanceled < now) {
          throw new IllegalStateException("Cancelling of job took " + (now - cancelTime) + " milliseconds, only "+ maxTimeTillCanceled+ " milliseconds are allowed");
        }
      }
      final JobProgressResult jobProgressResult=client.getJobProgress();
      if (jobProgressResult == null) {
        throw new IllegalStateException("Returned job progress is unexpectedly null!");
      }
      if (jobProgressResult.getReturnCode() == AbstractJobResult.ReturnCode.ERROR) {
        throw new IllegalStateException("Could not retrieve job progress: " + jobProgressResult.getDescription());
      }
      boolean exitLoop=false;
      final Iterator<AbstractEvent> it=jobProgressResult.getEvents();
      while (it.hasNext()) {
        final AbstractEvent event=it.next();
        if (lastProcessedEventSequenceNumber >= event.getSequenceNumber()) {
          continue;
        }
        lastProcessedEventSequenceNumber=event.getSequenceNumber();
        if (event instanceof JobEvent) {
          final JobEvent jobEvent=(JobEvent)event;
          final JobStatus jobStatus=jobEvent.getCurrentJobStatus();
switch (jobStatus) {
case FINISHED:
            throw new IllegalStateException("Job finished successfully");
case FAILED:
          throw new IllegalStateException("Job failed");
case CANCELED:
        exitLoop=true;
      break;
case RUNNING:
    break;
default :
  throw new Exception("Bug: Unrecognized Job Status.");
}
}
if (exitLoop) {
break;
}
}
if (exitLoop) {
break;
}
Thread.sleep(sleep);
}
}
 catch (Exception e) {
LOG.error("Exception while running runAndCancelJob.",e);
Assert.fail(StringUtils.stringifyException(e));
return;
}
}
