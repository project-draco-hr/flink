{
  CommandLine line;
  try {
    line=parser.parse(LIST_OPTIONS,args,false);
    evaluateGeneralOptions(line);
  }
 catch (  MissingOptionException e) {
    return handleArgException(e);
  }
catch (  MissingArgumentException e) {
    return handleArgException(e);
  }
catch (  UnrecognizedOptionException e) {
    return handleArgException(e);
  }
catch (  Exception e) {
    return handleError(e);
  }
  if (printHelp) {
    printHelpForList();
    return 0;
  }
  boolean running=line.hasOption(RUNNING_OPTION.getOpt());
  boolean scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    running=true;
    scheduled=true;
  }
  try {
    ActorRef jobManager=getJobManager(line,getGlobalConfiguration());
    if (jobManager == null) {
      return 1;
    }
    final Future<Object> response=Patterns.ask(jobManager,JobManagerMessages.getRequestRunningJobs(),new Timeout(getAkkaTimeout()));
    Object result;
    try {
      result=Await.result(response,getAkkaTimeout());
    }
 catch (    Exception exception) {
      throw new IOException("Could not retrieve running jobs from job manager.",exception);
    }
    if (!(result instanceof RunningJobs)) {
      throw new RuntimeException("ReqeustRunningJobs requires a response of type " + "RunningJobs. Instead the response is of type " + result.getClass() + ".");
    }
 else {
      Iterable<ExecutionGraph> jobs=((RunningJobs)result).asJavaIterable();
      ArrayList<ExecutionGraph> runningJobs=null;
      ArrayList<ExecutionGraph> scheduledJobs=null;
      if (running) {
        runningJobs=new ArrayList<ExecutionGraph>();
      }
      if (scheduled) {
        scheduledJobs=new ArrayList<ExecutionGraph>();
      }
      for (      ExecutionGraph rj : jobs) {
        if (running && rj.getState().equals(JobStatus.RUNNING)) {
          runningJobs.add(rj);
        }
        if (scheduled && rj.getState().equals(JobStatus.CREATED)) {
          scheduledJobs.add(rj);
        }
      }
      SimpleDateFormat df=new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");
      Comparator<ExecutionGraph> njec=new Comparator<ExecutionGraph>(){
        @Override public int compare(        ExecutionGraph o1,        ExecutionGraph o2){
          return (int)(o1.getStatusTimestamp(o1.getState()) - o2.getStatusTimestamp(o2.getState()));
        }
      }
;
      if (running) {
        if (runningJobs.size() == 0) {
          System.out.println("No running jobs.");
        }
 else {
          Collections.sort(runningJobs,njec);
          System.out.println("------------------------ Running Jobs ------------------------");
          for (          ExecutionGraph rj : runningJobs) {
            System.out.println(df.format(new Date(rj.getStatusTimestamp(rj.getState()))) + " : " + rj.getJobID().toString()+ " : "+ rj.getJobName());
          }
          System.out.println("--------------------------------------------------------------");
        }
      }
      if (scheduled) {
        if (scheduledJobs.size() == 0) {
          System.out.println("No scheduled jobs.");
        }
 else {
          Collections.sort(scheduledJobs,njec);
          System.out.println("----------------------- Scheduled Jobs -----------------------");
          for (          ExecutionGraph rj : scheduledJobs) {
            System.out.println(df.format(new Date(rj.getStatusTimestamp(rj.getState()))) + " : " + rj.getJobID().toString()+ " : "+ rj.getJobName());
          }
          System.out.println("--------------------------------------------------------------");
        }
      }
      return 0;
    }
  }
 catch (  Throwable t) {
    return handleError(t);
  }
}
