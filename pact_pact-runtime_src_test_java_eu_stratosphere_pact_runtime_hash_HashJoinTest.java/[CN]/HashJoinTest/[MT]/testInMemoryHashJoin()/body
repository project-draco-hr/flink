{
  final int NUM_KEYS=100000;
  final int BUILD_VALS_PER_KEY=3;
  final int PROBE_VALS_PER_KEY=10;
  Iterator<KeyValuePair<PactInteger,PactInteger>> buildInput=new RegularlyGeneratedInputGenerator(NUM_KEYS,BUILD_VALS_PER_KEY,false);
  Iterator<KeyValuePair<PactInteger,PactInteger>> probeInput=new RegularlyGeneratedInputGenerator(NUM_KEYS,PROBE_VALS_PER_KEY,true);
  MemoryManager memMan;
  List<MemorySegment> memSegments;
  try {
    memMan=new DefaultMemoryManager(32 * 1024 * 1024);
    memSegments=memMan.allocate(MEM_OWNER,28 * 1024 * 1024,896,32 * 1024);
  }
 catch (  MemoryAllocationException maex) {
    fail("Memory for the Join could not be provided.");
    return;
  }
  IOManager ioManager=new IOManager();
  final KeyValuePair<PactInteger,PactInteger> pair=new KeyValuePair<PactInteger,PactInteger>(new PactInteger(),new PactInteger());
  HashJoin<PactInteger,PactInteger,PactInteger> join=new HashJoin<PactInteger,PactInteger,PactInteger>(buildInput,probeInput,PactInteger.class,PactInteger.class,PactInteger.class,memSegments,ioManager);
  join.open();
  int numKeys=0;
  while (join.nextKey()) {
    numKeys++;
    int numBuildValues=0;
    int numProbeValues=0;
    Iterator<KeyValuePair<PactInteger,PactInteger>> probeIter=join.getProbeSideIterator();
    while (probeIter.hasNext()) {
      numProbeValues++;
      probeIter.next();
    }
    Assert.assertEquals("Wrong number of values from probe-side for a key",PROBE_VALS_PER_KEY,numProbeValues);
    HashBucketIterator<PactInteger,PactInteger> buildSide=join.getBuildSideIterator();
    while (buildSide.next(pair)) {
      numBuildValues++;
    }
    Assert.assertEquals("Wrong number of values from build-side for a key",BUILD_VALS_PER_KEY,numBuildValues);
  }
  Assert.assertEquals("Wrong number of keys",NUM_KEYS,numKeys);
  join.close();
  memMan.release(memSegments);
  ioManager.shutdown();
  if (!ioManager.isProperlyShutDown()) {
    fail("I/O manager was not property shut down.");
  }
  if (!memMan.verifyEmpty()) {
    fail("Not all memory was properly released to the memory manager --> Memory Leak.");
  }
}
