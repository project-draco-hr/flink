{
  final int REPEATED_VALUE_1=40559;
  final int REPEATED_VALUE_2=92882;
  final int REPEATED_VALUE_COUNT=3000000;
  final int NUM_KEYS=1000000;
  final int BUILD_VALS_PER_KEY=3;
  final int PROBE_VALS_PER_KEY=10;
  ReadingIterator<PactRecord> build1=new RegularlyGeneratedInputGenerator(NUM_KEYS,BUILD_VALS_PER_KEY,false);
  ReadingIterator<PactRecord> build2=new ConstantsKeyValuePairsIterator(REPEATED_VALUE_1,17,REPEATED_VALUE_COUNT);
  ReadingIterator<PactRecord> build3=new ConstantsKeyValuePairsIterator(REPEATED_VALUE_2,23,REPEATED_VALUE_COUNT);
  List<ReadingIterator<PactRecord>> builds=new ArrayList<ReadingIterator<PactRecord>>();
  builds.add(build1);
  builds.add(build2);
  builds.add(build3);
  ReadingIterator<PactRecord> buildInput=new UnionIterator<PactRecord>(builds);
  ReadingIterator<PactRecord> probe1=new RegularlyGeneratedInputGenerator(NUM_KEYS,PROBE_VALS_PER_KEY,true);
  ReadingIterator<PactRecord> probe2=new ConstantsKeyValuePairsIterator(REPEATED_VALUE_1,17,REPEATED_VALUE_COUNT);
  ReadingIterator<PactRecord> probe3=new ConstantsKeyValuePairsIterator(REPEATED_VALUE_2,23,REPEATED_VALUE_COUNT);
  List<ReadingIterator<PactRecord>> probes=new ArrayList<ReadingIterator<PactRecord>>();
  probes.add(probe1);
  probes.add(probe2);
  probes.add(probe3);
  ReadingIterator<PactRecord> probeInput=new UnionIterator<PactRecord>(probes);
  MemoryManager memMan;
  List<MemorySegment> memSegments;
  try {
    memMan=new DefaultMemoryManager(32 * 1024 * 1024);
    memSegments=memMan.allocate(MEM_OWNER,28 * 1024 * 1024,896,32 * 1024);
  }
 catch (  MemoryAllocationException maex) {
    fail("Memory for the Join could not be provided.");
    return;
  }
  IOManager ioManager=new IOManager();
  @SuppressWarnings("unchecked") final HashJoin join=new HashJoin(buildInput,probeInput,new int[]{0},new Class[]{PactInteger.class},memSegments,ioManager);
  join.open();
  final PactRecord record=new PactRecord();
  try {
    while (join.nextRecord()) {
      HashBucketIterator buildSide=join.getBuildSideIterator();
      if (!buildSide.next(record)) {
        fail("No build side values found for a probe key.");
      }
      while (buildSide.next(record))       ;
    }
    fail("Hash Join must have failed due to too many recursions.");
  }
 catch (  Exception ex) {
  }
  join.close();
  memMan.release(memSegments);
  ioManager.shutdown();
  if (!ioManager.isProperlyShutDown()) {
    fail("I/O manager was not property shut down.");
  }
  if (!memMan.verifyEmpty()) {
    fail("Not all memory was properly released to the memory manager --> Memory Leak.");
  }
}
