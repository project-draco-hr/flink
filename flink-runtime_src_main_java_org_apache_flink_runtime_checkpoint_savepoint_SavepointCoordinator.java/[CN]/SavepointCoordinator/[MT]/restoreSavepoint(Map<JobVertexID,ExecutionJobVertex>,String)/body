{
  checkNotNull(savepointPath,"Savepoint path");
synchronized (lock) {
    if (isShutdown()) {
      throw new IllegalStateException("CheckpointCoordinator is shut down");
    }
    LOG.info("Rolling back to savepoint '{}'.",savepointPath);
    Savepoint savepoint=savepointStore.loadSavepoint(savepointPath);
    long recoveryTimestamp=System.currentTimeMillis();
    for (    TaskState taskState : savepoint.getTaskStates()) {
      ExecutionJobVertex executionJobVertex=tasks.get(taskState.getJobVertexID());
      if (executionJobVertex != null) {
        if (executionJobVertex.getParallelism() != taskState.getParallelism()) {
          String msg=String.format("Failed to rollback to savepoint %s. " + "Parallelism mismatch between savepoint state and new program. " + "Cannot map operator %s with parallelism %d to new program with "+ "parallelism %d. This indicates that the program has been changed "+ "in a non-compatible way after the savepoint.",savepoint,taskState.getJobVertexID(),taskState.getParallelism(),executionJobVertex.getParallelism());
          throw new IllegalStateException(msg);
        }
        List<Set<Integer>> keyGroupPartitions=createKeyGroupPartitions(numberKeyGroups,executionJobVertex.getParallelism());
        for (int i=0; i < executionJobVertex.getTaskVertices().length; i++) {
          SubtaskState subtaskState=taskState.getState(i);
          SerializedValue<StateHandle<?>> state=null;
          if (subtaskState != null) {
            state=subtaskState.getState();
          }
          Map<Integer,SerializedValue<StateHandle<?>>> kvStateForTaskMap=taskState.getUnwrappedKvStates(keyGroupPartitions.get(i));
          Execution currentExecutionAttempt=executionJobVertex.getTaskVertices()[i].getCurrentExecutionAttempt();
          currentExecutionAttempt.setInitialState(state,kvStateForTaskMap);
        }
      }
 else {
        String msg=String.format("Failed to rollback to savepoint %s. " + "Cannot map old state for task %s to the new program. " + "This indicates that the program has been changed in a "+ "non-compatible way  after the savepoint.",savepointPath,taskState.getJobVertexID());
        throw new IllegalStateException(msg);
      }
    }
    long nextCheckpointId=savepoint.getCheckpointId() + 1;
    checkpointIdCounter.start();
    checkpointIdCounter.setCount(nextCheckpointId);
    LOG.info("Reset the checkpoint ID to {}",nextCheckpointId);
    if (savepointRestorePath == null) {
      savepointRestorePath=savepointPath;
    }
  }
}
