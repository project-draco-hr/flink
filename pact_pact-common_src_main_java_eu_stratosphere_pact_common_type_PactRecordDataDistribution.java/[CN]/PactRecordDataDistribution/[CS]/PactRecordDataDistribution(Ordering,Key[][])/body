{
  int[] keyPositions=ordering.getFieldPositions();
  Class<? extends Key>[] keyTypes=ordering.getTypes();
  Order[] orders=ordering.getFieldOrders();
  int numBoundaryKeys=0;
  for (  Key[] boundaryKey : boundaryKeys) {
    if (numBoundaryKeys == 0) {
      numBoundaryKeys=boundaryKey.length;
      if (numBoundaryKeys > keyPositions.length) {
        throw new IllegalArgumentException("Boundary keys must be a subset of the ordering keys");
      }
    }
 else     if (numBoundaryKeys != boundaryKey.length) {
      throw new IllegalArgumentException("All boundaries need the same number of keys.");
    }
    for (int i=0; i < boundaryKey.length; i++) {
      if (!boundaryKey[i].getClass().equals(keyTypes[i])) {
        throw new IllegalArgumentException("Boundary keys do not match the ordering key types.");
      }
    }
  }
  this.keyPositions=new int[numBoundaryKeys];
  this.keyTypes=(Class<? extends Key>[])new Class[numBoundaryKeys];
  this.keyOrders=new Order[numBoundaryKeys];
  for (int i=0; i < numBoundaryKeys; i++) {
    this.keyPositions[i]=ordering.getFieldNumber(i);
    this.keyTypes[i]=ordering.getType(i);
    this.keyOrders[i]=ordering.getOrder(i);
  }
  this.boundaryRecords=new PactRecord[boundaryKeys.length];
  for (int i=0; i < boundaryKeys.length; i++) {
    this.boundaryRecords[i]=new PactRecord();
    for (int j=0; j < boundaryKeys[i].length; j++) {
      this.boundaryRecords[i].setField(keyPositions[j],boundaryKeys[i][j]);
    }
  }
  for (int i=1; i < this.boundaryRecords.length; i++) {
    for (int j=0; j < keyPositions.length; j++) {
      final Key prevKey=this.boundaryRecords[i - 1].getField(keyPositions[j],keyTypes[j]);
      final Key thisKey=this.boundaryRecords[i].getField(keyPositions[j],keyTypes[j]);
      final int comp=prevKey.compareTo(thisKey);
      if (orders[j] == Order.ANY || orders[j] == Order.NONE) {
        continue;
      }
      if (comp == 0) {
        continue;
      }
      if (orders[j] == Order.ASCENDING) {
        if (comp < 0) {
          break;
        }
 else {
          throw new IllegalArgumentException("Ordering and order of boundary keys inconsistent");
        }
      }
      if (orders[j] == Order.DESCENDING) {
        if (comp > 0) {
          break;
        }
 else {
          throw new IllegalArgumentException("Ordering and order of boundary keys inconsistent");
        }
      }
    }
  }
}
