{
  if (this.wrappedInvokable != null) {
    return this.wrappedInvokable;
  }
  final Configuration conf=getEnvironment().getTaskConfiguration();
  final JobID jobID=getEnvironment().getJobID();
  final String className=conf.getString(WRAPPED_CLASS_KEY,null);
  if (className == null) {
    throw new IllegalStateException("Cannot find name of wrapped class");
  }
  try {
    final ClassLoader cl=LibraryCacheManager.getClassLoader(jobID);
    @SuppressWarnings("unchecked") final Class<? extends AbstractInvokable> invokableClass=(Class<? extends AbstractInvokable>)Class.forName(className,true,cl);
    this.wrappedInvokable=invokableClass.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(StringUtils.stringifyException(e));
  }
  this.wrappedInvokable.setEnvironment(new StreamingEnvironment(getEnvironment()));
  return this.wrappedInvokable;
}
