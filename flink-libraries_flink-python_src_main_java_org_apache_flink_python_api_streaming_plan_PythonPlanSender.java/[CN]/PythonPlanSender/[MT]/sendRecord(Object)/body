{
  String className=record.getClass().getSimpleName().toUpperCase();
  if (className.startsWith("TUPLE")) {
    className="TUPLE";
  }
  if (className.startsWith("BYTE[]")) {
    className="BYTES";
  }
  SupportedTypes type=SupportedTypes.valueOf(className);
switch (type) {
case TUPLE:
    output.write(TYPE_TUPLE);
  int arity=((Tuple)record).getArity();
output.writeInt(arity);
for (int x=0; x < arity; x++) {
sendRecord(((Tuple)record).getField(x));
}
return;
case BOOLEAN:
output.write(TYPE_BOOLEAN);
output.write(((Boolean)record) ? (byte)1 : (byte)0);
return;
case BYTE:
output.write(TYPE_BYTE);
output.write((Byte)record);
return;
case BYTES:
output.write(TYPE_BYTES);
output.write((byte[])record,0,((byte[])record).length);
return;
case CHARACTER:
output.write(TYPE_STRING);
output.writeChars(((Character)record) + "");
return;
case SHORT:
output.write(TYPE_SHORT);
output.writeShort((Short)record);
return;
case INTEGER:
output.write(TYPE_INTEGER);
output.writeInt((Integer)record);
return;
case LONG:
output.write(TYPE_LONG);
output.writeLong((Long)record);
return;
case STRING:
output.write(TYPE_STRING);
output.writeBytes((String)record);
return;
case FLOAT:
output.write(TYPE_FLOAT);
output.writeFloat((Float)record);
return;
case DOUBLE:
output.write(TYPE_DOUBLE);
output.writeDouble((Double)record);
return;
case NULL:
output.write(TYPE_NULL);
return;
case CUSTOMTYPEWRAPPER:
output.write(((CustomTypeWrapper)record).getType());
output.write(((CustomTypeWrapper)record).getData());
return;
default :
throw new IllegalArgumentException("Unknown Type encountered: " + type);
}
}
