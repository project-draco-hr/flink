{
  FileDataSourceContract<PactInteger,PactInteger> source=new FileDataSourceContract<PactInteger,PactInteger>(DummyInputFormat.class,IN_FILE_1,"Source");
  source.setDegreeOfParallelism(defaultParallelism);
  source.setOutputContract(UniqueKey.class);
  MapContract<PactInteger,PactInteger,PactInteger,PactInteger> map1=new MapContract<PactInteger,PactInteger,PactInteger,PactInteger>(IdentityMap.class,"Map1");
  map1.setDegreeOfParallelism(1);
  map1.addInput(source);
  ReduceContract<PactInteger,PactInteger,PactInteger,PactInteger> reduce1=new ReduceContract<PactInteger,PactInteger,PactInteger,PactInteger>(IdentityReduce.class,"Reduce1");
  reduce1.setDegreeOfParallelism(defaultParallelism);
  reduce1.addInput(map1);
  FileDataSinkContract<PactInteger,PactInteger> sink=new FileDataSinkContract<PactInteger,PactInteger>(DummyOutputFormat.class,OUT_FILE_1,"Sink");
  sink.setDegreeOfParallelism(defaultParallelism);
  sink.addInput(reduce1);
  Plan plan=new Plan(sink,"Test Temp Task");
  OptimizedPlan oPlan=this.compiler.compile(plan,this.instanceType);
  oPlan.accept(new Visitor<OptimizerNode>(){
    @Override public boolean preVisit(    OptimizerNode visitable){
      if (visitable instanceof ReduceNode) {
        ShipStrategy strategy=visitable.getIncomingConnections().get(0).get(0).getShipStrategy();
        Assert.assertEquals(ShipStrategy.PARTITION_LOCAL_HASH,strategy);
        return false;
      }
      return true;
    }
    @Override public void postVisit(    OptimizerNode visitable){
    }
  }
);
  JobGraphGenerator jobGen=new JobGraphGenerator();
  jobGen.compileJobGraph(oPlan);
}
