{
  final ExecutionGraph eg=this.executionVertex.getExecutionGraph();
  if (newExecutionState == ExecutionState.FINISHING) {
    final ExecutionPipeline pipeline=this.executionVertex.getExecutionPipeline();
    if (!pipeline.isFinishing()) {
      return;
    }
    final ExecutionGroupVertex groupVertex=this.executionVertex.getGroupVertex();
    for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); ++i) {
      final ExecutionVertex groupMember=groupVertex.getGroupMember(i);
      if (groupMember.compareAndUpdateExecutionState(ExecutionState.SCHEDULED,ExecutionState.ASSIGNED)) {
        final ExecutionPipeline pipelineToBeDeployed=groupMember.getExecutionPipeline();
        pipelineToBeDeployed.setAllocatedResource(this.executionVertex.getAllocatedResource());
        pipelineToBeDeployed.updateExecutionState(ExecutionState.ASSIGNED);
        this.scheduler.deployAssignedPipeline(pipelineToBeDeployed);
        return;
      }
    }
  }
  if (newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FINISHED) {
synchronized (eg) {
      if (this.scheduler.getVerticesToBeRestarted().remove(this.executionVertex.getID()) != null) {
        if (eg.getJobStatus() == InternalJobStatus.FAILING) {
          return;
        }
        this.executionVertex.updateExecutionState(ExecutionState.ASSIGNED,"Restart as part of recovery");
        this.scheduler.deployAssignedVertices(this.executionVertex);
        return;
      }
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
    this.scheduler.checkAndReleaseAllocatedResource(eg,this.executionVertex.getAllocatedResource());
  }
  if (newExecutionState == ExecutionState.FAILED) {
    if (this.executionVertex.decrementRetriesLeftAndCheck()) {
      final Set<ExecutionVertex> assignedVertices=new HashSet<ExecutionVertex>();
      boolean recover=false;
      try {
        recover=RecoveryLogic.recover(this.executionVertex,this.scheduler.getVerticesToBeRestarted(),assignedVertices);
      }
 catch (      InterruptedException ie) {
        return;
      }
      if (recover) {
        if (RecoveryLogic.hasInstanceAssigned(this.executionVertex)) {
          this.scheduler.deployAssignedVertices(assignedVertices);
        }
      }
 else {
synchronized (eg) {
          final Iterator<ExecutionVertex> it=this.scheduler.getVerticesToBeRestarted().values().iterator();
          while (it.hasNext()) {
            if (eg.equals(it.next().getExecutionGraph())) {
              it.remove();
            }
          }
        }
      }
    }
  }
}
