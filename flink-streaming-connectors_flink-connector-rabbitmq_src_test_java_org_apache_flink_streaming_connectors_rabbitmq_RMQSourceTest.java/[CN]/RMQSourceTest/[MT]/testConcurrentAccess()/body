{
  source.autoAck=false;
  sourceThread.start();
  final Tuple1<Throwable> error=new Tuple1<>(null);
  Thread.sleep(5);
  Thread snapshotThread=new Thread(new Runnable(){
    public long id=0;
    @Override public void run(){
      while (!Thread.interrupted()) {
        try {
          source.snapshotState(id++,0);
        }
 catch (        Exception e) {
          error.f0=e;
          break;
        }
      }
    }
  }
);
  Thread notifyThread=new Thread(new Runnable(){
    @Override public void run(){
      while (!Thread.interrupted()) {
        try {
          source.notifyCheckpointComplete(Long.MAX_VALUE);
        }
 catch (        Exception e) {
          error.f0=e;
          break;
        }
      }
    }
  }
);
  snapshotThread.start();
  notifyThread.start();
  long deadline=System.currentTimeMillis() + 1000L;
  while (System.currentTimeMillis() < deadline) {
    if (!snapshotThread.isAlive()) {
      notifyThread.interrupt();
      break;
    }
    if (!notifyThread.isAlive()) {
      snapshotThread.interrupt();
      break;
    }
    Thread.sleep(10);
  }
  if (snapshotThread.isAlive()) {
    snapshotThread.interrupt();
    snapshotThread.join();
  }
  if (notifyThread.isAlive()) {
    notifyThread.interrupt();
    notifyThread.join();
  }
  if (error.f0 != null) {
    error.f0.printStackTrace();
    Assert.fail("Test failed with " + error.f0.getClass().getCanonicalName());
  }
}
