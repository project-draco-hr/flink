{
  if (node instanceof SinkPlanNode) {
    final SinkPlanNode sn=(SinkPlanNode)node;
    sn.setSerializer(PactRecordSerializerFactory.get());
    final Channel inchannel=sn.getInput();
    final KeySchema schema=new KeySchema();
    sn.postPassHelper=schema;
    final GenericDataSink pactSink=sn.getSinkNode().getPactContract();
    final Ordering partitioning=pactSink.getPartitionOrdering();
    final Ordering sorting=pactSink.getLocalOrder();
    try {
      if (partitioning != null) {
        addOrderingToSchema(partitioning,schema);
      }
      if (sorting != null) {
        addOrderingToSchema(sorting,schema);
      }
    }
 catch (    ConflictingFieldTypeInfoException ex) {
      throw new CompilerPostPassException("BUG: Conflicting information found when adding data sink types");
    }
    propagateToChannel(schema,inchannel);
  }
 else   if (node instanceof SingleInputPlanNode) {
    final SingleInputPlanNode sn=(SingleInputPlanNode)node;
    final KeySchema schema;
    if (sn.postPassHelper == null) {
      schema=new KeySchema();
      sn.postPassHelper=schema;
    }
 else {
      schema=(KeySchema)sn.postPassHelper;
    }
    schema.increaseNumConnectionsThatContributed();
    final SingleInputNode optNode=sn.getSingleInputNode();
    for (    Map.Entry<Integer,Class<? extends Key>> entry : parentSchema) {
      final Integer pos=entry.getKey();
      if (optNode.isFieldConstant(0,pos)) {
        schema.addKeyType(pos,entry.getValue());
      }
    }
    if (schema.getNumConnectionsThatContributed() <= sn.getOutgoingChannels().size()) {
      return;
    }
    final SingleInputContract<?> contract=optNode.getPactContract();
    final int[] localPositions=contract.getKeyColumnNumbers(0);
    final Class<? extends Key>[] types=contract.getKeyClasses();
    for (int i=0; i < localPositions.length; i++) {
      schema.addKeyType(localPositions[i],types[i]);
    }
    sn.setSerializer(PactRecordSerializerFactory.get());
    if (sn.getDriverStrategy().requiresComparator()) {
      sn.setComparator(createComparator(sn.getKeys(),sn.getSortOrders(),schema));
    }
    propagateToChannel(schema,sn.getInput());
  }
 else   if (node instanceof SourcePlanNode) {
  }
 else {
    throw new CompilerPostPassException("Unknown node type encountered: " + node.getClass().getName());
  }
}
