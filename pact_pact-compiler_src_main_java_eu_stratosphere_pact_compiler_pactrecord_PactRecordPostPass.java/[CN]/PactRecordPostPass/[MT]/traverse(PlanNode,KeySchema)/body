{
  if (node instanceof SinkPlanNode) {
    final SinkPlanNode sn=(SinkPlanNode)node;
    sn.setSerializer(PactRecordSerializerFactory.get());
    final Channel inchannel=sn.getInput();
    final KeySchema schema=new KeySchema();
    sn.postPassHelper=schema;
    final GenericDataSink pactSink=sn.getSinkNode().getPactContract();
    final Ordering partitioning=pactSink.getPartitionOrdering();
    final Ordering sorting=pactSink.getLocalOrder();
    try {
      if (partitioning != null) {
        addOrderingToSchema(partitioning,schema);
      }
      if (sorting != null) {
        addOrderingToSchema(sorting,schema);
      }
    }
 catch (    ConflictingFieldTypeInfoException ex) {
      throw new CompilerPostPassException("BUG: Conflicting information found when adding data sink types");
    }
    try {
      propagateToChannel(schema,inchannel);
    }
 catch (    MissingFieldTypeInfoException ex) {
      throw new CompilerPostPassException("BUG: Missing key type infomation for input to to data sink.");
    }
  }
 else   if (node instanceof SingleInputPlanNode) {
    final SingleInputPlanNode sn=(SingleInputPlanNode)node;
    final KeySchema schema;
    if (sn.postPassHelper == null) {
      schema=new KeySchema();
      sn.postPassHelper=schema;
    }
 else {
      schema=(KeySchema)sn.postPassHelper;
    }
    schema.increaseNumConnectionsThatContributed();
    final SingleInputNode optNode=sn.getSingleInputNode();
    try {
      for (      Map.Entry<Integer,Class<? extends Key>> entry : parentSchema) {
        final Integer pos=entry.getKey();
        if (optNode.isFieldConstant(0,pos)) {
          schema.addKeyType(pos,entry.getValue());
        }
      }
    }
 catch (    ConflictingFieldTypeInfoException ex) {
      throw new CompilerPostPassException("Conflicting key type information for field " + ex.getFieldNumber() + " in node '"+ optNode.getPactContract().getName()+ "' propagated from successor node. "+ "Conflicting types: "+ ex.getPreviousType().getName()+ " and "+ ex.getNewType().getName()+ ". Most probably cause: Invalid constant field annotations.");
    }
    if (schema.getNumConnectionsThatContributed() < sn.getOutgoingChannels().size()) {
      return;
    }
    final SingleInputContract<?> contract=optNode.getPactContract();
    if (!(contract instanceof RecordContract)) {
      throw new CompilerPostPassException("Error: Contract is not a Pact Record based contract. Wrong compiler invokation.");
    }
    final RecordContract recContract=(RecordContract)contract;
    final int[] localPositions=contract.getKeyColumns(0);
    final Class<? extends Key>[] types=recContract.getKeyClasses();
    try {
      for (int i=0; i < localPositions.length; i++) {
        schema.addKeyType(localPositions[i],types[i]);
      }
    }
 catch (    ConflictingFieldTypeInfoException ex) {
      throw new CompilerPostPassException("Conflicting key type information for field " + ex.getFieldNumber() + " in node '"+ optNode.getPactContract().getName()+ "' between types declared in the node's "+ "contract and types inferred from successor contracts. Conflicting types: "+ ex.getPreviousType().getName()+ " and "+ ex.getNewType().getName()+ ". Most probably cause: Invalid constant field annotations.");
    }
    sn.setSerializer(PactRecordSerializerFactory.get());
    if (sn.getDriverStrategy().requiresComparator()) {
      try {
        sn.setComparator(createComparator(sn.getKeys(),sn.getSortOrders(),schema));
      }
 catch (      MissingFieldTypeInfoException ex) {
        throw new CompilerPostPassException("Could not set up runtime strategy for node '" + contract.getName() + "'. Missing type information for key field "+ ex.getFieldNumber());
      }
    }
    try {
      propagateToChannel(schema,sn.getInput());
    }
 catch (    MissingFieldTypeInfoException ex) {
      throw new CompilerPostPassException("Could not set up runtime strategy for input channel to node '" + contract.getName() + "'. Missing type information for key field "+ ex.getFieldNumber());
    }
  }
 else   if (node instanceof SourcePlanNode) {
  }
 else {
    throw new CompilerPostPassException("Unknown node type encountered: " + node.getClass().getName());
  }
}
