{
  this.registeredHosts=new HashMap<InstanceConnectionInfo,ClusterInstance>();
  this.slicesOfJobs=new HashMap<JobID,List<AllocatedSlice>>();
  this.rpcService=rpcService;
  this.availableInstanceTypes=populateInstanceTypeArray();
  this.instanceAccommodationMatrix=calculateInstanceAccommodationMatrix();
  this.instanceTypeDescriptionMap=new HashMap<InstanceType,InstanceTypeDescription>();
  long tmpCleanUpInterval=(long)GlobalConfiguration.getInteger(CLEANUP_INTERVAL_KEY,DEFAULT_CLEANUP_INTERVAL) * 1000;
  if (tmpCleanUpInterval < 10) {
    LOG.warn("Invalid clean up interval. Reverting to default cleanup interval of " + DEFAULT_CLEANUP_INTERVAL + " secs.");
    tmpCleanUpInterval=DEFAULT_CLEANUP_INTERVAL;
  }
  this.cleanUpInterval=tmpCleanUpInterval;
  int tmpDefaultInstanceTypeIndex=GlobalConfiguration.getInteger(DEFAULT_INSTANCE_TYPE_INDEX_KEY,ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
  if (tmpDefaultInstanceTypeIndex > this.availableInstanceTypes.length) {
    LOG.warn("Incorrect index to for default instance type (" + tmpDefaultInstanceTypeIndex + "), switching to default index "+ ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
    tmpDefaultInstanceTypeIndex=ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX;
  }
  this.defaultInstanceType=this.availableInstanceTypes[tmpDefaultInstanceTypeIndex - 1];
  sortAvailableInstancesByNumberOfCPUCores();
  this.networkTopology=loadNetworkTopology();
  loadIPToInstanceTypeMapping();
  final boolean runTimerAsDaemon=true;
  new Timer(runTimerAsDaemon).schedule(cleanupStaleMachines,1000,1000);
  updateInstaceTypeDescriptionMap();
}
