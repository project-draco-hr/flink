{
  int i=startPos;
  final int delimLimit=limit - delimiter.length + 1;
  while (i < limit) {
    if (i < delimLimit && delimiterNext(bytes,i,delimiter)) {
      if (i == startPos) {
        setErrorState(ParseErrorState.EMPTY_COLUMN);
        return -1;
      }
      break;
    }
    i++;
  }
  if (i > startPos && (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[(i - 1)]))) {
    setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
    return -1;
  }
  try {
    final int length=i - startPos;
    if (reuse == null || reuse.length < length) {
      reuse=new char[length];
    }
    for (int j=0; j < length; j++) {
      final byte b=bytes[startPos + j];
      if ((b < '0' || b > '9') && b != '-' && b != '+' && b != '.' && b != 'E' && b != 'e') {
        throw new NumberFormatException();
      }
      reuse[j]=(char)bytes[startPos + j];
    }
    this.result=new BigDecimal(reuse,0,length);
    return (i == limit) ? limit : i + delimiter.length;
  }
 catch (  NumberFormatException e) {
    setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);
    return -1;
  }
}
