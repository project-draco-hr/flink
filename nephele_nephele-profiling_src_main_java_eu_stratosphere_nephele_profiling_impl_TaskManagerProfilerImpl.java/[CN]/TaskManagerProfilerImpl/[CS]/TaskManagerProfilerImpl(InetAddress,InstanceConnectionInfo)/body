{
  try {
    this.rpcService=new RPCService(ProfilingTypeUtils.getRPCTypesToRegister());
  }
 catch (  IOException e) {
    throw new ProfilingException(StringUtils.stringifyException(e));
  }
  final InetSocketAddress profilingAddress=new InetSocketAddress(jobManagerAddress,GlobalConfiguration.getInteger(ProfilingUtils.JOBMANAGER_RPC_PORT_KEY,ProfilingUtils.JOBMANAGER_DEFAULT_RPC_PORT));
  try {
    this.jobManagerProfiler=this.rpcService.getProxy(profilingAddress,ProfilerImplProtocol.class);
  }
 catch (  IOException e) {
    throw new ProfilingException(StringUtils.stringifyException(e));
  }
  this.tmx=ManagementFactory.getThreadMXBean();
  if (this.tmx.isThreadContentionMonitoringSupported()) {
    this.tmx.setThreadContentionMonitoringEnabled(true);
  }
 else {
    throw new ProfilingException("The thread contention monitoring is not supported.");
  }
  this.instanceProfiler=new InstanceProfiler(instanceConnectionInfo);
  this.timerInterval=(long)(GlobalConfiguration.getInteger(ProfilingUtils.TASKMANAGER_REPORTINTERVAL_KEY,ProfilingUtils.DEFAULT_TASKMANAGER_REPORTINTERVAL) * 1000);
  final long initialDelay=(long)(Math.random() * this.timerInterval);
  this.timer=new Timer(true);
  this.timer.schedule(this,initialDelay,this.timerInterval);
}
