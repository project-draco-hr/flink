{
  HandlerInfo<InputType,OutputBase,TypeHandler<InputType,OutputBase>> handlerInfo=this.getHandlerInfo(in.getClass());
  for (  TypeHandlerListener<InputType,OutputBase> listener : this.handlerListeners)   listener.beforeHierarchicalConversion(in,params);
  List<OutputBase> childTypes=new ArrayList<OutputBase>();
  if (handlerInfo == null || !handlerInfo.stopRecursion)   for (  InputType child : navigator.getConnectedNodes(in)) {
    OutputBase handledResult=this.handleRecursively(navigator,child,params);
    if (this.flattenCollection && handledResult instanceof Collection<?>)     childTypes.addAll((Collection<? extends OutputBase>)handledResult);
 else     if (handledResult != null)     childTypes.add(handledResult);
  }
  childTypes.addAll(this.lastChildren);
  Object[] parameters=new Object[params.length + 1];
  parameters[0]=childTypes;
  this.lastChildren=handlerInfo != null && handlerInfo.shouldAppendChildren() ? childTypes.subList(handlerInfo.getAppendIndex(),childTypes.size()) : Collections.EMPTY_LIST;
  System.arraycopy(params,0,parameters,1,params.length);
  OutputBase convertedType=this.handle(in,parameters);
  for (  TypeHandlerListener<InputType,OutputBase> listener : this.handlerListeners)   listener.afterHierarchicalConversion(in,params,convertedType);
  if (convertedType == null && this.passthroughChildren) {
    if (Collection.class.isAssignableFrom(this.outputBase))     return (OutputBase)childTypes;
    return childTypes.isEmpty() ? null : childTypes.get(0);
  }
  return convertedType;
}
