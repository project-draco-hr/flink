{
  super.configure(config);
  if (configured) {
    return;
  }
  final String fieldDelimStr=config.getString(FIELD_DELIMITER_PARAMETER,null);
  if (fieldDelimStr != null) {
    if (fieldDelimStr.length() != 1) {
      throw new IllegalArgumentException("Invalid configuration for CsvInputFormat: " + "Field delimiter must be a single character");
    }
 else {
      setFieldDelimiter(fieldDelimStr.charAt(0));
    }
  }
  int numConfigFields=config.getInteger(NUM_FIELDS_PARAMETER,-1);
  if (numConfigFields != -1) {
    if (numConfigFields <= 0) {
      throw new IllegalConfigurationException("The number of fields for the CsvInputFormat is invalid.");
    }
    if (getNumberOfNonNullFields() > 0) {
      throw new IllegalConfigurationException("Mixing configuration via instance parameters and config parameters is not possible.");
    }
    int[] textPosIdx=new int[numConfigFields];
    boolean anyTextPosSet=false;
    boolean allTextPosSet=true;
    int maxTextPos=-1;
    for (int i=0; i < numConfigFields; i++) {
      int pos=config.getInteger(TEXT_POSITION_PARAMETER_PREFIX + i,-1);
      if (pos == -1) {
        allTextPosSet=false;
        textPosIdx[i]=i;
        maxTextPos=i;
      }
 else {
        anyTextPosSet=true;
        textPosIdx[i]=pos;
        maxTextPos=pos > maxTextPos ? pos : maxTextPos;
      }
    }
    if (anyTextPosSet && !allTextPosSet) {
      throw new IllegalArgumentException("Invalid configuration for CsvInputFormat: " + "Not all text positions set");
    }
    @SuppressWarnings("unchecked") Class<? extends Value>[] types=(Class<? extends Value>[])new Class[maxTextPos + 1];
    int[] targetPos=new int[maxTextPos + 1];
    ClassLoader cl=Thread.currentThread().getContextClassLoader();
    try {
      for (int i=0; i < numConfigFields; i++) {
        int pos=textPosIdx[i];
        Class<? extends Value> clazz=config.getClass(FIELD_TYPE_PARAMETER_PREFIX + i,null,cl).asSubclass(Value.class);
        if (clazz == null) {
          throw new IllegalConfigurationException("Invalid configuration for CsvInputFormat: " + "No field parser class for parameter " + i);
        }
        types[pos]=clazz;
        targetPos[pos]=i;
      }
    }
 catch (    ClassNotFoundException e) {
      throw new RuntimeException("Could not resolve type classes",e);
    }
    setFieldTypes(types);
    this.targetPositions=new int[numConfigFields];
    for (int i=0, k=0; i < targetPos.length; i++) {
      if (types[i] != null) {
        this.targetPositions[k++]=targetPos[i];
      }
    }
  }
 else {
    if (this.targetPositions.length == 0) {
      this.targetPositions=new int[getNumberOfNonNullFields()];
      for (int i=0; i < this.targetPositions.length; i++) {
        this.targetPositions[i]=i;
      }
    }
  }
  if (getNumberOfNonNullFields() == 0) {
    throw new IllegalConfigurationException("No fields configured in the CsvInputFormat.");
  }
  this.configured=true;
}
