{
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  final Class<Key> keyClass=this.keyType;
  final Class<? extends Value> valueClass=PactNull.class;
  final SerializationFactory<Key> keySerialization=new WritableSerializationFactory<Key>(keyClass);
  final SerializationFactory<Value> valSerialization=new WritableSerializationFactory<Value>((Class<Value>)valueClass);
switch (this.config.getLocalStrategy()) {
case NONE:
{
      Iterator<KeyValuePair<Key,Value>> iter=new Iterator<KeyValuePair<Key,Value>>(){
        @Override public boolean hasNext(){
          return HistogramTask.this.reader.hasNext();
        }
        @Override public KeyValuePair<Key,Value> next(){
          try {
            return (KeyValuePair<Key,Value>)HistogramTask.this.reader.next();
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
        @Override public void remove(){
        }
      }
;
      return new SimpleCloseableInputProvider<KeyValuePair<Key,Value>>(iter);
    }
case SORT:
{
    final Comparator<Key> keyComparator=new Comparator<Key>(){
      @Override public int compare(      Key k1,      Key k2){
        return k1.compareTo(k2);
      }
    }
;
    try {
      SortMerger<Key,Value> sortMerger=new UnilateralSortMerger<Key,Value>(memoryManager,ioManager,this.availableMemory,this.maxFileHandles,keySerialization,valSerialization,keyComparator,this.reader,this,this.spillThreshold);
      return sortMerger;
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException("MemoryManager is not able to provide the required amount of memory for ReduceTask",mae);
    }
catch (    IOException ioe) {
      throw new RuntimeException("IOException caught when obtaining SortMerger for ReduceTask",ioe);
    }
  }
default :
throw new RuntimeException("Invalid local strategy provided for ReduceTask.");
}
}
