{
  super(flinkConfig);
  this.akkaDuration=AkkaUtils.getTimeout(flinkConfig);
  this.akkaTimeout=Timeout.durationToTimeout(akkaDuration);
  this.clusterDescriptor=clusterDescriptor;
  this.yarnClient=yarnClient;
  this.hadoopConfig=yarnClient.getConfig();
  this.sessionFilesDir=sessionFilesDir;
  this.applicationId=appReport;
  this.appId=appReport.getApplicationId();
  this.trackingURL=appReport.getTrackingUrl();
  try {
    leaderRetrievalService=LeaderRetrievalUtils.createLeaderRetrievalService(flinkConfig);
  }
 catch (  Exception e) {
    throw new IOException("Could not create the leader retrieval service.",e);
  }
  if (isConnected) {
    throw new IllegalStateException("Already connected to the cluster.");
  }
  LOG.info("Start application client.");
  applicationClient=actorSystem.actorOf(Props.create(ApplicationClient.class,flinkConfig,leaderRetrievalService),"applicationClient");
  actorRunner=new Thread(new Runnable(){
    @Override public void run(){
      actorSystem.awaitTermination();
      try {
        ApplicationReport appReport=yarnClient.getApplicationReport(appId);
        LOG.info("Application " + appId + " finished with state "+ appReport.getYarnApplicationState()+ " and final state "+ appReport.getFinalApplicationStatus()+ " at "+ appReport.getFinishTime());
        if (appReport.getYarnApplicationState() == YarnApplicationState.FAILED || appReport.getYarnApplicationState() == YarnApplicationState.KILLED) {
          LOG.warn("Application failed. Diagnostics " + appReport.getDiagnostics());
          LOG.warn("If log aggregation is activated in the Hadoop cluster, we recommend to retrieve " + "the full application log using this command:\n" + "\tyarn logs -applicationId " + appReport.getApplicationId() + "\n"+ "(It sometimes takes a few seconds until the logs are aggregated)");
        }
      }
 catch (      Exception e) {
        LOG.warn("Error while getting final application report",e);
      }
    }
  }
);
  actorRunner.setDaemon(true);
  actorRunner.start();
  pollingRunner=new PollingThread(yarnClient,appId);
  pollingRunner.setDaemon(true);
  pollingRunner.start();
  Runtime.getRuntime().addShutdownHook(clientShutdownHook);
  isConnected=true;
  logAndSysout("Waiting until all TaskManagers have connected");
  while (true) {
    GetClusterStatusResponse status=getClusterStatus();
    if (status != null) {
      if (status.numRegisteredTaskManagers() < clusterDescriptor.getTaskManagerCount()) {
        logAndSysout("TaskManager status (" + status.numRegisteredTaskManagers() + "/"+ clusterDescriptor.getTaskManagerCount()+ ")");
      }
 else {
        logAndSysout("All TaskManagers are connected");
        break;
      }
    }
 else {
      logAndSysout("No status updates from the YARN cluster received so far. Waiting ...");
    }
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException e) {
      LOG.error("Interrupted while waiting for TaskManagers");
      System.err.println("Thread is interrupted");
      throw new IOException("Interrupted while waiting for TaskManagers",e);
    }
  }
}
