{
  final BulkIterationPlanNode bulkNode=(BulkIterationPlanNode)descr.getIterationNode();
  final JobTaskVertex headVertex=descr.getHeadTask();
  final TaskConfig headConfig=new TaskConfig(headVertex.getConfiguration());
  final TaskConfig headFinalOutputConfig=descr.getHeadFinalResultConfig();
  final int numStepFunctionOuts=headConfig.getNumOutputs();
  final int numFinalOuts=headFinalOutputConfig.getNumOutputs();
  headConfig.setIterationHeadFinalOutputConfig(headFinalOutputConfig);
  headConfig.setIterationHeadIndexOfSyncOutput(numStepFunctionOuts + numFinalOuts);
  final double relativeMemForBackChannel=bulkNode.getRelativeMemoryPerSubTask();
  if (relativeMemForBackChannel <= 0) {
    throw new CompilerException("Bug: No memory has been assigned to the iteration back channel.");
  }
  headConfig.setRelativeBackChannelMemory(relativeMemForBackChannel);
  final SimpleOutputVertex sync=new SimpleOutputVertex("Sync(" + bulkNode.getNodeName() + ")",this.jobGraph);
  sync.setInvokableClass(IterationSynchronizationSinkTask.class);
  sync.setNumberOfSubtasks(1);
  this.auxVertices.add(sync);
  final TaskConfig syncConfig=new TaskConfig(sync.getConfiguration());
  syncConfig.setGateIterativeWithNumberOfEventsUntilInterrupt(0,headVertex.getNumberOfSubtasks());
  final int maxNumIterations=bulkNode.getIterationNode().getIterationContract().getMaximumNumberOfIterations();
  if (maxNumIterations < 1) {
    throw new CompilerException("Cannot create bulk iteration with unspecified maximum number of iterations.");
  }
  syncConfig.setNumberOfIterations(maxNumIterations);
  try {
    headVertex.connectTo(sync,ChannelType.NETWORK,DistributionPattern.POINTWISE);
  }
 catch (  JobGraphDefinitionException e) {
    throw new CompilerException("Bug: Cannot connect head vertex to sync task.");
  }
  final PlanNode rootOfTerminationCriterion=bulkNode.getRootOfTerminationCriterion();
  final PlanNode rootOfStepFunction=bulkNode.getRootOfStepFunction();
  final TaskConfig tailConfig;
  JobTaskVertex rootOfStepFunctionVertex=(JobTaskVertex)this.vertices.get(rootOfStepFunction);
  if (rootOfStepFunctionVertex == null) {
    final TaskInChain taskInChain=this.chainedTasks.get(rootOfStepFunction);
    if (taskInChain == null) {
      throw new CompilerException("Bug: Tail of step function not found as vertex or chained task.");
    }
    rootOfStepFunctionVertex=(JobTaskVertex)taskInChain.getContainingVertex();
    tailConfig=taskInChain.getTaskConfig();
  }
 else {
    tailConfig=new TaskConfig(rootOfStepFunctionVertex.getConfiguration());
  }
  tailConfig.setIsWorksetUpdate();
  if (rootOfStepFunction.getOutgoingChannels().isEmpty()) {
    rootOfStepFunctionVertex.setInvokableClass(IterationTailPactTask.class);
    tailConfig.setOutputSerializer(bulkNode.getSerializerForIterationChannel());
    tailConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
    SimpleOutputVertex fakeTail=new SimpleOutputVertex("Fake Tail",this.jobGraph);
    fakeTail.setInvokableClass(FakeOutputTask.class);
    fakeTail.setNumberOfSubtasks(headVertex.getNumberOfSubtasks());
    this.auxVertices.add(fakeTail);
    try {
      rootOfStepFunctionVertex.connectTo(fakeTail,ChannelType.IN_MEMORY,DistributionPattern.POINTWISE);
    }
 catch (    JobGraphDefinitionException e) {
      throw new CompilerException("Bug: Cannot connect iteration tail vertex fake tail task");
    }
  }
  final TaskConfig tailConfigOfTerminationCriterion;
  if (rootOfTerminationCriterion != null && rootOfTerminationCriterion.getOutgoingChannels().isEmpty()) {
    JobTaskVertex rootOfTerminationCriterionVertex=(JobTaskVertex)this.vertices.get(rootOfTerminationCriterion);
    if (rootOfTerminationCriterionVertex == null) {
      final TaskInChain taskInChain=this.chainedTasks.get(rootOfTerminationCriterion);
      if (taskInChain == null) {
        throw new CompilerException("Bug: Tail of termination criterion not found as vertex or chained task.");
      }
      rootOfTerminationCriterionVertex=(JobTaskVertex)taskInChain.getContainingVertex();
      tailConfigOfTerminationCriterion=taskInChain.getTaskConfig();
    }
 else {
      tailConfigOfTerminationCriterion=new TaskConfig(rootOfTerminationCriterionVertex.getConfiguration());
    }
    rootOfTerminationCriterionVertex.setInvokableClass(IterationTailPactTask.class);
    tailConfigOfTerminationCriterion.setIsSolutionSetUpdate();
    tailConfigOfTerminationCriterion.setOutputSerializer(bulkNode.getSerializerForIterationChannel());
    tailConfigOfTerminationCriterion.addOutputShipStrategy(ShipStrategyType.FORWARD);
    SimpleOutputVertex fakeTailTerminationCriterion=new SimpleOutputVertex("Fake Tail for Termination Criterion",this.jobGraph);
    fakeTailTerminationCriterion.setInvokableClass(FakeOutputTask.class);
    fakeTailTerminationCriterion.setNumberOfSubtasks(headVertex.getNumberOfSubtasks());
    this.auxVertices.add(fakeTailTerminationCriterion);
    try {
      rootOfTerminationCriterionVertex.connectTo(fakeTailTerminationCriterion,ChannelType.IN_MEMORY,DistributionPattern.POINTWISE);
    }
 catch (    JobGraphDefinitionException e) {
      throw new CompilerException("Bug: Cannot connect iteration tail vertex fake tail task for termination criterion");
    }
    headConfig.setWaitForSolutionSetUpdate();
  }
  AggregatorRegistry aggs=bulkNode.getIterationNode().getIterationContract().getAggregators();
  Collection<AggregatorWithName<?>> allAggregators=aggs.getAllRegisteredAggregators();
  headConfig.addIterationAggregators(allAggregators);
  syncConfig.addIterationAggregators(allAggregators);
  String convAggName=aggs.getConvergenceCriterionAggregatorName();
  ConvergenceCriterion<?> convCriterion=aggs.getConvergenceCriterion();
  if (convCriterion != null || convAggName != null) {
    if (convCriterion == null) {
      throw new CompilerException("Error: Convergence criterion aggregator set, but criterion is null.");
    }
    if (convAggName == null) {
      throw new CompilerException("Error: Aggregator convergence criterion set, but aggregator is null.");
    }
    syncConfig.setConvergenceCriterion(convAggName,convCriterion);
  }
}
