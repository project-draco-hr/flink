{
  this.vertices=new HashMap<PlanNode,AbstractJobVertex>();
  this.chainedTasks=new HashMap<PlanNode,TaskInChain>();
  this.chainedTasksInSequence=new ArrayList<TaskInChain>();
  this.auxVertices=new ArrayList<AbstractJobVertex>();
  this.iterations=new HashMap<IterationPlanNode,IterationDescriptor>();
  this.iterationStack=new ArrayList<IterationPlanNode>();
  this.sharingGroup=new SlotSharingGroup();
  program.accept(this);
  if (this.currentIteration != null) {
    throw new CompilerException("The graph translation ended prematurely, leaving an unclosed iteration.");
  }
  for (  IterationDescriptor iteration : this.iterations.values()) {
    if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {
      finalizeBulkIteration(iteration);
    }
 else     if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {
      finalizeWorksetIteration(iteration);
    }
 else {
      throw new CompilerException();
    }
  }
  for (int i=0; i < this.chainedTasksInSequence.size(); i++) {
    TaskInChain tic=this.chainedTasksInSequence.get(i);
    TaskConfig t=new TaskConfig(tic.getContainingVertex().getConfiguration());
    t.addChainedTask(tic.getChainedTask(),tic.getTaskConfig(),tic.getTaskName());
  }
  JobGraph graph=new JobGraph(program.getJobName());
  graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries());
  graph.setAllowQueuedScheduling(false);
  for (  AbstractJobVertex vertex : this.vertices.values()) {
    graph.addVertex(vertex);
  }
  for (  AbstractJobVertex vertex : this.auxVertices) {
    graph.addVertex(vertex);
    vertex.setSlotSharingGroup(sharingGroup);
  }
  for (  Entry<String,DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {
    DistributedCache.writeFileInfoToConfig(e.getKey(),e.getValue(),graph.getJobConfiguration());
  }
  this.vertices=null;
  this.chainedTasks=null;
  this.chainedTasksInSequence=null;
  this.auxVertices=null;
  this.iterations=null;
  this.iterationStack=null;
  return graph;
}
