{
  final JobID jobID=tdd.getJobID();
  final JobVertexID vertexId=tdd.getVertexID();
  final ExecutionAttemptID executionId=tdd.getExecutionId();
  final int taskIndex=tdd.getIndexInSubtaskGroup();
  final int numSubtasks=tdd.getCurrentNumberOfSubtasks();
  Task task=null;
  boolean jarsRegistered=false;
  if (shutdownStarted.get()) {
    return new TaskOperationResult(executionId,false,"TaskManager is shut down.");
  }
  if (registeredId == null) {
    return new TaskOperationResult(executionId,false,"TaskManager lost connection to JobManager.");
  }
  try {
    libraryCacheManager.register(jobID,tdd.getRequiredJarFiles());
    jarsRegistered=true;
    final ClassLoader userCodeClassLoader=libraryCacheManager.getClassLoader(jobID);
    if (userCodeClassLoader == null) {
      throw new Exception("No user code ClassLoader available.");
    }
    task=new Task(jobID,vertexId,taskIndex,numSubtasks,executionId,tdd.getTaskName(),this);
    if (this.runningTasks.putIfAbsent(executionId,task) != null) {
      throw new Exception("TaskManager contains already a task with executionId " + executionId);
    }
    final InputSplitProvider splitProvider=new TaskInputSplitProvider(this.globalInputSplitProvider,jobID,vertexId,executionId);
    final RuntimeEnvironment env=new RuntimeEnvironment(task,tdd,userCodeClassLoader,this.memoryManager,this.ioManager,splitProvider,this.accumulatorProtocolProxy);
    task.setEnvironment(env);
    this.channelManager.register(task);
    final Configuration jobConfig=tdd.getJobConfiguration();
    boolean enableProfiling=this.profiler != null && jobConfig.getBoolean(ProfilingUtils.PROFILE_JOB_KEY,true);
    if (enableProfiling) {
      task.registerProfiler(this.profiler,jobConfig);
    }
    Map<String,FutureTask<Path>> cpTasks=new HashMap<String,FutureTask<Path>>();
    for (    Entry<String,DistributedCacheEntry> e : DistributedCache.readFileInfoFromConfig(tdd.getJobConfiguration())) {
      FutureTask<Path> cp=this.fileCache.createTmpFile(e.getKey(),e.getValue(),jobID);
      cpTasks.put(e.getKey(),cp);
    }
    env.addCopyTasksForCacheFile(cpTasks);
    if (!task.startExecution()) {
      throw new CancelTaskException();
    }
    if (shutdownStarted.get() || this.registeredId == null) {
      throw new Exception("Task Manager is shut down or is not connected to a JobManager.");
    }
    return new TaskOperationResult(executionId,true);
  }
 catch (  Throwable t) {
    String message;
    if (t instanceof CancelTaskException) {
      message="Task was canceled";
    }
 else {
      LOG.error("Could not instantiate task",t);
      message=ExceptionUtils.stringifyException(t);
    }
    try {
      try {
        task.failExternally(t);
      }
 catch (      Throwable t2) {
        LOG.error("Error during cleanup of task deployment",t2);
      }
      this.runningTasks.remove(executionId);
      if (task != null) {
        removeAllTaskResources(task);
      }
      if (jarsRegistered) {
        libraryCacheManager.unregister(jobID);
      }
    }
 catch (    Throwable t2) {
      LOG.error("Error during cleanup of task deployment",t2);
    }
    return new TaskOperationResult(executionId,false,message);
  }
}
