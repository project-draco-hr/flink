{
  final JobID jobID=tdd.getJobID();
  final JobVertexID vertexId=tdd.getVertexID();
  final ExecutionAttemptID executionId=tdd.getExecutionId();
  final int taskIndex=tdd.getIndexInSubtaskGroup();
  final int numSubtasks=tdd.getCurrentNumberOfSubtasks();
  boolean jarsRegistered=false;
  try {
    LibraryCacheManager.register(jobID,tdd.getRequiredJarFiles());
    jarsRegistered=true;
    final ClassLoader userCodeClassLoader=LibraryCacheManager.getClassLoader(jobID);
    if (userCodeClassLoader == null) {
      throw new Exception("No user code ClassLoader available.");
    }
    final Task task=new Task(jobID,vertexId,taskIndex,numSubtasks,executionId,tdd.getTaskName(),this);
    if (this.runningTasks.putIfAbsent(executionId,task) != null) {
      throw new Exception("TaskManager contains already a task with executionId " + executionId);
    }
    boolean success=false;
    try {
      final InputSplitProvider splitProvider=new TaskInputSplitProvider(this.globalInputSplitProvider,jobID,vertexId);
      final RuntimeEnvironment env=new RuntimeEnvironment(task,tdd,userCodeClassLoader,this.memoryManager,this.ioManager,splitProvider,this.accumulatorProtocolProxy);
      task.setEnvironment(env);
      this.channelManager.register(task);
      final Configuration jobConfig=tdd.getJobConfiguration();
      boolean enableProfiling=this.profiler != null && jobConfig.getBoolean(ProfilingUtils.PROFILE_JOB_KEY,true);
      if (enableProfiling) {
        task.registerProfiler(this.profiler,jobConfig);
      }
      Map<String,FutureTask<Path>> cpTasks=new HashMap<String,FutureTask<Path>>();
      for (      Entry<String,DistributedCacheEntry> e : DistributedCache.readFileInfoFromConfig(tdd.getJobConfiguration())) {
        FutureTask<Path> cp=this.fileCache.createTmpFile(e.getKey(),e.getValue(),jobID);
        cpTasks.put(e.getKey(),cp);
      }
      env.addCopyTasksForCacheFile(cpTasks);
      if (!task.startExecution()) {
        throw new Exception("Cannot start task. Task was canceled or failed.");
      }
      if (shutdownStarted.get()) {
        throw new Exception("Task Manager is shut down.");
      }
      success=true;
      return new TaskOperationResult(executionId,true);
    }
  finally {
      if (!success) {
        this.runningTasks.remove(executionId);
        for (        Entry<String,DistributedCacheEntry> e : DistributedCache.readFileInfoFromConfig(tdd.getJobConfiguration())) {
          this.fileCache.deleteTmpFile(e.getKey(),e.getValue(),jobID);
        }
      }
    }
  }
 catch (  Throwable t) {
    LOG.error("Could not instantiate task",t);
    if (jarsRegistered) {
      try {
        LibraryCacheManager.unregister(jobID);
      }
 catch (      IOException e) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Unregistering the execution " + executionId + " caused an IOException");
        }
      }
    }
    return new TaskOperationResult(executionId,false,ExceptionUtils.stringifyException(t));
  }
}
