{
  final int requiredSlots=executionGraph.getRequiredSlots();
  final int availableSlots=this.getInstanceManager().getNumberOfSlots();
  if (requiredSlots > availableSlots) {
    throw new SchedulingException("Not enough slots to schedule job " + executionGraph.getJobID());
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    vertex.registerExecutionListener(new DefaultExecutionListener(this,vertex));
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    final String exceptionMessage=StringUtils.stringifyException(e);
    LOG.error(exceptionMessage);
    this.jobQueue.remove(executionGraph);
    throw new SchedulingException(exceptionMessage);
  }
}
