{
  final Pattern removeNonInt=Pattern.compile("[^0-9+-]");
  final Pattern removeNonFloat=Pattern.compile("[^0-9+-.]");
  for (  final Class<? extends NumericNode> type : TypeCoercer.NUMERIC_TYPES) {
    this.add(type,new Parser(STRICT){
      @Override public JsonNode parse(      TextNode textNode){
        return TypeCoercer.INSTANCE.coerce(textNode,type);
      }
    }
);
    final NumericNode defaultValue=TypeCoercer.INSTANCE.coerce(TextNode.valueOf("0"),type);
    this.add(type,new TextualParser(ELIMINATE_NOISE){
      Pattern removePattern=defaultValue.isIntegralNumber() ? removeNonInt : removeNonFloat;
      @Override public JsonNode parse(      final String textualValue){
        StringBuilder cleanedValue=new StringBuilder(this.removePattern.matcher(textualValue).replaceAll(""));
        if (!removeSuperfluxSigns(cleanedValue))         return null;
        if (defaultValue.isFloatingPointNumber())         remomveSuperfluxDots(cleanedValue);
        return TypeCoercer.INSTANCE.coerce(TextNode.valueOf(cleanedValue.toString()),type);
      }
      private void remomveSuperfluxDots(      StringBuilder cleanedValue){
        int lastDotIndex=cleanedValue.lastIndexOf(".");
        while (lastDotIndex > 0 && (lastDotIndex=cleanedValue.lastIndexOf(".",lastDotIndex - 1)) != -1)         cleanedValue.deleteCharAt(lastDotIndex);
      }
      private boolean removeSuperfluxSigns(      StringBuilder cleanedValue){
        int numberStart=-1;
        for (int index=0; index < cleanedValue.length(); index++)         if (Character.isDigit(cleanedValue.charAt(index))) {
          numberStart=index;
          break;
        }
        if (numberStart == -1)         return false;
        if (numberStart > 1)         cleanedValue.delete(0,numberStart - 1);
        return true;
      }
    }
);
    this.add(type,new TextualParser(FORCE_PARSING){
      @Override public JsonNode parse(      final String textualValue){
        return defaultValue;
      }
    }
);
  }
}
