{
  LOG.debug("repartition build side #1: repartition hash map contents");
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  int partition;
  for (  K key : hashMap.keys()) {
    partition=partitioner.getPartition(key);
    for (    VB value : hashMap.get(key)) {
      partitionWriters.get(partition).write(new KeyValuePair<K,VB>(key,value));
    }
  }
  hashMap.clear();
  ChannelReader partitionZeroReader=ioManager.createChannelReader(buildPartitionIDs.get(0),partitionWriters.get(0).close());
  while (partitionZeroReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  partitionWriters.set(0,ioManager.createChannelWriter(buildPartitionIDs.get(0),partitionZeroReader.close()));
  LOG.debug("repartition build side #2: repartition record causing hash map overflow");
  pair=overflowCause;
  partition=partitioner.getPartition(pair.getKey());
  if (partition == 0) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
 else {
    partitionWriters.get(partition).write(pair);
  }
  LOG.debug("repartition build side #3: repartition remaining records from reader");
  while (readerBuild.hasNext()) {
    pair=readerBuild.next();
    partition=partitioner.getPartition(pair.getKey());
    if (partition == 0) {
      hashMap.put(pair.getKey(),pair.getValue());
    }
 else {
      partitionWriters.get(partition).write(pair);
    }
  }
}
