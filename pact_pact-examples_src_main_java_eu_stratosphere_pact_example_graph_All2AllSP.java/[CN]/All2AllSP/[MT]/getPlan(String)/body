{
  if (args.length != 3) {
    return null;
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String paths=args[1];
  String output=args[2];
  DataSourceContract<Edge,ConnectionInfo> pathsInput=new DataSourceContract<Edge,ConnectionInfo>(PathInFormat.class,paths);
  pathsInput.setFormatParameter("delimiter","\n");
  pathsInput.setDegreeOfParallelism(noSubTasks);
  pathsInput.setOutputContract(UniqueKey.class);
  MapContract<Edge,ConnectionInfo,PactInteger,ConnectionInfo> pathStarts=new MapContract<Edge,ConnectionInfo,PactInteger,ConnectionInfo>(ProjectPathStart.class,"Project Starts");
  pathStarts.setDegreeOfParallelism(noSubTasks);
  MapContract<Edge,ConnectionInfo,PactInteger,ConnectionInfo> pathEnds=new MapContract<Edge,ConnectionInfo,PactInteger,ConnectionInfo>(ProjectPathEnd.class,"Project Ends");
  pathEnds.setDegreeOfParallelism(noSubTasks);
  MatchContract<PactInteger,ConnectionInfo,ConnectionInfo,Edge,ConnectionInfo> concatPaths=new MatchContract<PactInteger,ConnectionInfo,ConnectionInfo,Edge,ConnectionInfo>(ConcatPath.class,"Concat Paths");
  concatPaths.setDegreeOfParallelism(noSubTasks);
  CoGroupContract<Edge,ConnectionInfo,ConnectionInfo,Edge,ConnectionInfo> findShortestPaths=new CoGroupContract<Edge,ConnectionInfo,ConnectionInfo,Edge,ConnectionInfo>(FindShortestPath.class,"Find Shortest Paths");
  findShortestPaths.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<Edge,ConnectionInfo> result=new DataSinkContract<Edge,ConnectionInfo>(PathOutFormat.class,output);
  result.setDegreeOfParallelism(noSubTasks);
  result.setInput(findShortestPaths);
  findShortestPaths.setFirstInput(pathsInput);
  findShortestPaths.setSecondInput(concatPaths);
  concatPaths.setFirstInput(pathStarts);
  pathStarts.setInput(pathsInput);
  concatPaths.setSecondInput(pathEnds);
  pathEnds.setInput(pathsInput);
  return new Plan(result,"All2All Shortest Paths");
}
