{
  this.owner=checkNotNull(owner);
  this.memoryManager=checkNotNull(memoryManager);
  this.ioManager=checkNotNull(ioManager);
  this.inputSplitProvider=checkNotNull(inputSplitProvider);
  this.jobManager=checkNotNull(jobManager);
  this.broadcastVariableManager=checkNotNull(broadcastVariableManager);
  try {
    final List<ResultPartitionDeploymentDescriptor> partitions=tdd.getProducedPartitions();
    this.producedPartitions=new ResultPartition[partitions.size()];
    this.writers=new ResultPartitionWriter[partitions.size()];
    for (int i=0; i < this.producedPartitions.length; i++) {
      ResultPartitionDeploymentDescriptor desc=partitions.get(i);
      ResultPartitionID partitionId=new ResultPartitionID(desc.getPartitionId(),owner.getExecutionId());
      this.producedPartitions[i]=new ResultPartition(this,owner.getJobID(),partitionId,desc.getPartitionType(),desc.getNumberOfSubpartitions(),networkEnvironment.getPartitionManager(),networkEnvironment.getPartitionConsumableNotifier(),ioManager,networkEnvironment.getDefaultIOMode());
      writers[i]=new ResultPartitionWriter(this.producedPartitions[i]);
    }
    final List<InputGateDeploymentDescriptor> consumedPartitions=tdd.getInputGates();
    this.inputGates=new SingleInputGate[consumedPartitions.size()];
    for (int i=0; i < inputGates.length; i++) {
      inputGates[i]=SingleInputGate.create(this,consumedPartitions.get(i),networkEnvironment);
      inputGatesById.put(inputGates[i].getConsumedResultId(),inputGates[i]);
    }
    this.jobConfiguration=tdd.getJobConfiguration();
    this.taskConfiguration=tdd.getTaskConfiguration();
    this.userCodeClassLoader=checkNotNull(userCodeClassLoader);
    Class<? extends AbstractInvokable> invokableClass;
    try {
      final String className=tdd.getInvokableClassName();
      invokableClass=Class.forName(className,true,userCodeClassLoader).asSubclass(AbstractInvokable.class);
    }
 catch (    Throwable t) {
      throw new Exception("Could not load invokable class.",t);
    }
    try {
      this.invokable=invokableClass.newInstance();
    }
 catch (    Throwable t) {
      throw new Exception("Could not instantiate the invokable class.",t);
    }
    this.invokable.setEnvironment(this);
    this.invokable.registerInputOutput();
  }
 catch (  Throwable t) {
    throw new Exception("Error setting up runtime environment: " + t.getMessage(),t);
  }
}
