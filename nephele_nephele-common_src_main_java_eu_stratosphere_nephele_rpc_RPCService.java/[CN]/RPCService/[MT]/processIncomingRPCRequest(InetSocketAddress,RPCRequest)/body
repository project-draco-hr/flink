{
  final Integer messageID=Integer.valueOf(rpcRequest.getMessageID());
  final CachedResponse cachedResponse=this.cachedResponses.get(messageID);
  if (cachedResponse != null) {
    try {
      sendPackets(cachedResponse.packets);
    }
 catch (    IOException e) {
      Log.error("Caught exception while trying to send RPC response: ",e);
    }
    return;
  }
  final Runnable runnable=new Runnable(){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
      final RPCProtocol callbackHandler=callbackHandlers.get(rpcRequest.getInterfaceName());
      if (callbackHandler == null) {
        Log.error("Cannot find callback handler for protocol " + rpcRequest.getInterfaceName());
        return;
      }
      Method method=null;
      try {
        method=callbackHandler.getClass().getMethod(rpcRequest.getMethodName(),rpcRequest.getParameterTypes());
      }
 catch (      Exception e) {
        e.printStackTrace();
        Log.error("Error while processing incoming RPC request: ",e);
        return;
      }
      RPCResponse rpcResponse=null;
      try {
        final Object retVal=method.invoke(callbackHandler,rpcRequest.getArgs());
        rpcResponse=new RPCReturnValue(rpcRequest.getMessageID(),retVal);
      }
 catch (      InvocationTargetException ite) {
        rpcResponse=new RPCThrowable(rpcRequest.getMessageID(),ite.getTargetException());
      }
catch (      Exception e) {
        e.printStackTrace();
        Log.error("Error while processing incoming RPC request: ",e);
        return;
      }
      final DatagramPacket[] packets=messageToPackets(remoteSocketAddress,rpcResponse);
      cachedResponses.put(messageID,new CachedResponse(System.currentTimeMillis(),packets));
      try {
        sendPackets(packets);
      }
 catch (      IOException e) {
        Log.error("Caught exception while trying to send RPC response: ",e);
      }
    }
  }
;
  this.rpcHandlers.execute(runnable);
}
