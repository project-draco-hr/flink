{
  if (this.shutdownRequested.get()) {
    throw new IOException("Shutdown of RPC service has already been requested");
  }
  DatagramPacket[] packets=messageToPackets(remoteSocketAddress,request);
  final Integer messageID=Integer.valueOf(request.getMessageID());
  final RPCRequestMonitor requestMonitor=new RPCRequestMonitor();
  this.pendingRequests.put(messageID,requestMonitor);
  for (int i=0; i < RETRY_LIMIT; ++i) {
    sendPackets(packets);
    RPCResponse rpcResponse;
    try {
synchronized (requestMonitor) {
        if (requestMonitor.rpcResponse == null) {
          requestMonitor.wait(this.statistics.calculateTimeout(packets.length,i));
        }
        rpcResponse=requestMonitor.rpcResponse;
      }
    }
 catch (    InterruptedException ie) {
      Log.debug("Caught interrupted exception while waiting for RPC request to complete: ",ie);
      return null;
    }
    if (rpcResponse == null) {
      Log.debug("Timeout, retransmitting request " + request.getMessageID());
      continue;
    }
    this.pendingRequests.remove(messageID);
    packets=messageToPackets(remoteSocketAddress,new RPCCleanup(request.getMessageID()));
    sendPackets(packets);
    if (rpcResponse instanceof RPCReturnValue) {
      return ((RPCReturnValue)rpcResponse).getRetVal();
    }
    throw ((RPCThrowable)rpcResponse).getThrowable();
  }
  this.pendingRequests.remove(messageID);
  throw new IOException("Unable to complete RPC of method " + request.getMethodName() + " on "+ remoteSocketAddress);
}
