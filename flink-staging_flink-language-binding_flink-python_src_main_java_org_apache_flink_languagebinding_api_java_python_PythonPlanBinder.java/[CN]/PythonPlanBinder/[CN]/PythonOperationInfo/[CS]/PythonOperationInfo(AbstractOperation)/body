{
  Object tmpType;
  setID=(Integer)receiver.getRecord(true);
  parentID=(Integer)receiver.getRecord(true);
switch (identifier) {
case COGROUP:
    otherID=(Integer)receiver.getRecord(true);
  keys1=tupleToIntArray((Tuple)receiver.getRecord(true));
keys2=tupleToIntArray((Tuple)receiver.getRecord(true));
operator=(byte[])receiver.getRecord();
meta=(String)receiver.getRecord();
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)receiver.getRecord();
break;
case CROSS:
case CROSS_H:
case CROSS_T:
otherID=(Integer)receiver.getRecord(true);
operator=(byte[])receiver.getRecord();
meta=(String)receiver.getRecord();
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
int cProjectCount=(Integer)receiver.getRecord(true);
projections=new ProjectionEntry[cProjectCount];
for (int x=0; x < cProjectCount; x++) {
String side=(String)receiver.getRecord();
int[] keys=tupleToIntArray((Tuple)receiver.getRecord(true));
projections[x]=new ProjectionEntry(ProjectionSide.valueOf(side.toUpperCase()),keys);
}
name=(String)receiver.getRecord();
break;
case REDUCE:
case GROUPREDUCE:
operator=(byte[])receiver.getRecord();
combineOperator=(byte[])receiver.getRecord();
meta=(String)receiver.getRecord();
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
combine=(Boolean)receiver.getRecord();
name=(String)receiver.getRecord();
break;
case JOIN:
case JOIN_H:
case JOIN_T:
keys1=tupleToIntArray((Tuple)receiver.getRecord(true));
keys2=tupleToIntArray((Tuple)receiver.getRecord(true));
otherID=(Integer)receiver.getRecord(true);
operator=(byte[])receiver.getRecord();
meta=(String)receiver.getRecord();
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
int jProjectCount=(Integer)receiver.getRecord(true);
projections=new ProjectionEntry[jProjectCount];
for (int x=0; x < jProjectCount; x++) {
String side=(String)receiver.getRecord();
int[] keys=tupleToIntArray((Tuple)receiver.getRecord(true));
projections[x]=new ProjectionEntry(ProjectionSide.valueOf(side.toUpperCase()),keys);
}
name=(String)receiver.getRecord();
break;
case MAPPARTITION:
case FLATMAP:
case MAP:
case FILTER:
operator=(byte[])receiver.getRecord();
meta=(String)receiver.getRecord();
tmpType=receiver.getRecord();
types=tmpType == null ? null : getForObject(tmpType);
name=(String)receiver.getRecord();
break;
default :
throw new UnsupportedOperationException("This operation is not implemented in the Python API: " + identifier);
}
}
