{
  String name="Partition";
  if (pMethod == PartitionMethod.REBALANCE) {
    UnaryOperatorInformation<IN,IN> operatorInfo=new UnaryOperatorInformation<IN,IN>(dataSet.getType(),dataSet.getType());
    PartitionOperatorBase<IN> noop=new PartitionOperatorBase<IN>(operatorInfo,pMethod,name);
    noop.setInput(input);
    noop.setDegreeOfParallelism(partitionDop);
    return noop;
  }
 else   if (pMethod == PartitionMethod.HASH) {
    if (pKeys instanceof Keys.FieldPositionKeys) {
      int[] logicalKeyPositions=pKeys.computeLogicalKeyPositions();
      UnaryOperatorInformation<IN,IN> operatorInfo=new UnaryOperatorInformation<IN,IN>(dataSet.getType(),dataSet.getType());
      PartitionOperatorBase<IN> noop=new PartitionOperatorBase<IN>(operatorInfo,pMethod,logicalKeyPositions,name);
      noop.setInput(input);
      noop.setDegreeOfParallelism(partitionDop);
      return noop;
    }
 else     if (pKeys instanceof Keys.SelectorFunctionKeys) {
      @SuppressWarnings("unchecked") Keys.SelectorFunctionKeys<IN,?> selectorKeys=(Keys.SelectorFunctionKeys<IN,?>)pKeys;
      MapOperatorBase<?,IN,?> po=translateSelectorFunctionReducer(selectorKeys,pMethod,dataSet.getType(),name,input,partitionDop);
      return po;
    }
 else {
      throw new UnsupportedOperationException("Unrecognized key type.");
    }
  }
 else   if (pMethod == PartitionMethod.RANGE) {
    throw new UnsupportedOperationException("Range partitioning not yet supported");
  }
  return null;
}
