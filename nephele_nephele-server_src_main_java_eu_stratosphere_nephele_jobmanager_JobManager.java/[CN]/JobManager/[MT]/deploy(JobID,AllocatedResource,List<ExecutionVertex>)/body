{
  final Runnable deploymentRunnable=new Runnable(){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
      try {
        allocatedResource.getInstance().checkLibraryAvailability(jobID);
      }
 catch (      IOException ioe) {
        LOG.error("Cannot check library availability: " + StringUtils.stringifyException(ioe));
      }
      final Iterator<ExecutionVertex> it=verticesToBeDeployed.iterator();
      while (it.hasNext()) {
        final ExecutionVertex vertex=it.next();
        if (vertex.getExecutionState() != ExecutionState.READY) {
          LOG.error("Expected vertex " + vertex + " to be in state READY but it is in state "+ vertex.getExecutionState());
        }
        if (vertex.isInputVertex() && vertex.getEnvironment().getInputSplits().length == 0 && vertex.getGroupVertex().getStageNumber() == 0) {
          try {
            if (!InputSplitAssigner.assignInputSplits(vertex)) {
              continue;
            }
          }
 catch (          ExecutionFailureException e) {
            LOG.error(e);
          }
        }
        LOG.info("Starting task " + vertex + " on "+ vertex.getAllocatedResource().getInstance());
        final TaskSubmissionResult submissionResult=vertex.startTask();
        it.remove();
        if (submissionResult.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
          vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,submissionResult.getDescription());
        }
      }
    }
  }
;
  this.executorService.execute(deploymentRunnable);
}
