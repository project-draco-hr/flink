{
  if (verticesToBeDeployed.isEmpty()) {
    LOG.error("Method 'deploy' called but list of vertices to be deployed is empty");
    return;
  }
  final Runnable deploymentRunnable=new Runnable(){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
      try {
        instance.checkLibraryAvailability(jobID);
      }
 catch (      IOException ioe) {
        LOG.error("Cannot check library availability: " + StringUtils.stringifyException(ioe));
      }
      final List<TaskSubmissionWrapper> submissionList=new SerializableArrayList<TaskSubmissionWrapper>();
      for (      final ExecutionVertex vertex : verticesToBeDeployed) {
        if (vertex.getExecutionState() != ExecutionState.READY) {
          LOG.error("Expected vertex " + vertex + " to be in state READY but it is in state "+ vertex.getExecutionState());
        }
        submissionList.add(new TaskSubmissionWrapper(vertex.getID(),vertex.getEnvironment(),vertex.getExecutionGraph().getJobConfiguration()));
        LOG.info("Starting task " + vertex + " on "+ vertex.getAllocatedResource().getInstance());
      }
      List<TaskSubmissionResult> submissionResultList=null;
      try {
        submissionResultList=instance.submitTasks(submissionList);
      }
 catch (      final IOException ioe) {
        final String errorMsg=StringUtils.stringifyException(ioe);
        for (        final ExecutionVertex vertex : verticesToBeDeployed) {
          vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,errorMsg);
        }
      }
      if (verticesToBeDeployed.size() != submissionResultList.size()) {
        LOG.error("size of submission result list does not match size of list with vertices to be deployed");
      }
      int count=0;
      for (      final TaskSubmissionResult tsr : submissionResultList) {
        ExecutionVertex vertex=verticesToBeDeployed.get(count++);
        if (!vertex.getID().equals(tsr.getVertexID())) {
          LOG.error("Expected different order of objects in task result list");
          vertex=null;
          for (          final ExecutionVertex candVertex : verticesToBeDeployed) {
            if (tsr.getVertexID().equals(candVertex.getID())) {
              vertex=candVertex;
              break;
            }
          }
          if (vertex == null) {
            LOG.error("Cannot find execution vertex for vertex ID " + tsr.getVertexID());
            continue;
          }
        }
        if (tsr.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
          vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,tsr.getDescription());
        }
      }
    }
  }
;
  this.executorService.execute(deploymentRunnable);
}
