{
  final Set<ExecutionVertex> readyVertices=this.scheduler.getVerticesReadyToBeExecuted();
synchronized (this.verticesReadyToRun) {
    this.verticesReadyToRun.addAll(readyVertices);
    final Iterator<ExecutionVertex> it=this.verticesReadyToRun.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() != ExecutionState.READY) {
        LOG.error("Expected vertex " + vertex + " to be in state READY but it is in state "+ vertex.getExecutionState());
      }
      if (vertex.isInputVertex() && vertex.getEnvironment().getInputSplits().length == 0 && vertex.getGroupVertex().getStageNumber() == 0) {
        try {
          FileInputSplitAssigner assigner=new FileInputSplitAssigner();
          if (!assigner.assignInputSplits(vertex.getGroupVertex())) {
            continue;
          }
        }
 catch (        Exception e) {
          LOG.error(e);
        }
      }
      if (LOG.isInfoEnabled())       LOG.info("Starting task " + vertex + " on "+ vertex.getAllocatedResource().getInstance());
      final TaskSubmissionResult submissionResult=vertex.startTask();
      it.remove();
      if (submissionResult.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
        vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,submissionResult.getDescription());
      }
    }
  }
}
