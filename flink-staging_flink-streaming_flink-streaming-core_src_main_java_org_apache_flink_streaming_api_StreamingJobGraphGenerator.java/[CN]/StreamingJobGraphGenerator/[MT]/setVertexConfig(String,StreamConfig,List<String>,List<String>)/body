{
  config.setVertexName(vertexName);
  config.setBufferTimeout(streamGraph.getBufferTimeout(vertexName));
  config.setTypeSerializerIn1(streamGraph.getInSerializer1(vertexName));
  config.setTypeSerializerIn2(streamGraph.getInSerializer2(vertexName));
  config.setTypeSerializerOut1(streamGraph.getOutSerializer1(vertexName));
  config.setTypeSerializerOut2(streamGraph.getOutSerializer2(vertexName));
  config.setUserInvokable(streamGraph.getInvokable(vertexName));
  config.setOutputSelectors(streamGraph.getOutputSelector(vertexName));
  config.setOperatorStates(streamGraph.getState(vertexName));
  config.setNumberOfOutputs(nonChainableOutputs.size());
  config.setOutputs(nonChainableOutputs);
  config.setChainedOutputs(chainableOutputs);
  Class<? extends AbstractInvokable> vertexClass=streamGraph.getJobVertexClass(vertexName);
  if (vertexClass.equals(StreamIterationHead.class) || vertexClass.equals(StreamIterationTail.class)) {
    config.setIterationId(streamGraph.getIterationID(vertexName));
    config.setIterationWaitTime(streamGraph.getIterationTimeout(vertexName));
  }
  List<String> allOutputs=new ArrayList<String>(chainableOutputs);
  allOutputs.addAll(nonChainableOutputs);
  for (  String output : allOutputs) {
    config.setSelectedNames(output,streamGraph.getSelectedNames(vertexName,output));
  }
  vertexConfigs.put(vertexName,config);
}
