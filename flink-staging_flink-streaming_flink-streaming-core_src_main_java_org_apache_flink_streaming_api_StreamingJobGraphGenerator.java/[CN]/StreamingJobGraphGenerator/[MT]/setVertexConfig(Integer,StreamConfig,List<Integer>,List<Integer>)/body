{
  config.setVertexID(vertexID);
  config.setBufferTimeout(streamGraph.getBufferTimeout(vertexID));
  config.setTypeSerializerIn1(streamGraph.getInSerializer1(vertexID));
  config.setTypeSerializerIn2(streamGraph.getInSerializer2(vertexID));
  config.setTypeSerializerOut1(streamGraph.getOutSerializer1(vertexID));
  config.setTypeSerializerOut2(streamGraph.getOutSerializer2(vertexID));
  config.setUserInvokable(streamGraph.getInvokable(vertexID));
  config.setOutputSelectors(streamGraph.getOutputSelector(vertexID));
  config.setOperatorStates(streamGraph.getState(vertexID));
  config.setNumberOfOutputs(nonChainableOutputs.size());
  config.setOutputs(nonChainableOutputs);
  config.setChainedOutputs(chainableOutputs);
  Class<? extends AbstractInvokable> vertexClass=streamGraph.getJobVertexClass(vertexID);
  if (vertexClass.equals(StreamIterationHead.class) || vertexClass.equals(StreamIterationTail.class)) {
    config.setIterationId(streamGraph.getIterationID(vertexID));
    config.setIterationWaitTime(streamGraph.getIterationTimeout(vertexID));
  }
  List<Integer> allOutputs=new ArrayList<Integer>(chainableOutputs);
  allOutputs.addAll(nonChainableOutputs);
  for (  Integer output : allOutputs) {
    config.setSelectedNames(output,streamGraph.getSelectedNames(vertexID,output));
  }
  vertexConfigs.put(vertexID,config);
}
