{
  StreamNode vertex=streamGraph.getVertex(vertexID);
  config.setVertexID(vertexID);
  config.setBufferTimeout(vertex.getBufferTimeout());
  config.setTypeSerializerIn1(vertex.getTypeSerializerIn1());
  config.setTypeSerializerIn2(vertex.getTypeSerializerIn2());
  config.setTypeSerializerOut1(vertex.getTypeSerializerOut());
  config.setUserInvokable(vertex.getInvokable());
  config.setOutputSelectorWrapper(vertex.getOutputSelectorWrapper());
  config.setNumberOfOutputs(nonChainableOutputs.size());
  config.setNonChainedOutputs(nonChainableOutputs);
  config.setChainedOutputs(chainableOutputs);
  config.setStateMonitoring(streamGraph.isCheckpointingEnabled());
  Class<? extends AbstractInvokable> vertexClass=vertex.getJobVertexClass();
  if (vertexClass.equals(StreamIterationHead.class) || vertexClass.equals(StreamIterationTail.class)) {
    config.setIterationId(streamGraph.getLoopID(vertexID));
    config.setIterationWaitTime(streamGraph.getLoopTimeout(vertexID));
  }
  List<StreamEdge> allOutputs=new ArrayList<StreamEdge>(chainableOutputs);
  allOutputs.addAll(nonChainableOutputs);
  for (  StreamEdge output : allOutputs) {
    config.setSelectedNames(output.getTargetID(),streamGraph.getEdge(vertexID,output.getTargetID()).getSelectedNames());
  }
  vertexConfigs.put(vertexID,config);
}
