{
  config.setVertexID(vertexID);
  config.setBufferTimeout(streamGraph.getBufferTimeout(vertexID));
  config.setTypeSerializerIn1(streamGraph.getInSerializer1(vertexID));
  config.setTypeSerializerIn2(streamGraph.getInSerializer2(vertexID));
  config.setTypeSerializerOut1(streamGraph.getOutSerializer1(vertexID));
  config.setTypeSerializerOut2(streamGraph.getOutSerializer2(vertexID));
  config.setUserInvokable(streamGraph.getInvokable(vertexID));
  config.setOutputSelectors(streamGraph.getOutputSelector(vertexID));
  config.setNumberOfOutputs(nonChainableOutputs.size());
  config.setNonChainedOutputs(nonChainableOutputs);
  config.setChainedOutputs(chainableOutputs);
  config.setStateMonitoring(streamGraph.isMonitoringEnabled());
  Class<? extends AbstractInvokable> vertexClass=streamGraph.getJobVertexClass(vertexID);
  if (vertexClass.equals(StreamIterationHead.class) || vertexClass.equals(StreamIterationTail.class)) {
    config.setIterationId(streamGraph.getIterationID(vertexID));
    config.setIterationWaitTime(streamGraph.getIterationTimeout(vertexID));
  }
  List<StreamEdge> allOutputs=new ArrayList<StreamEdge>(chainableOutputs);
  allOutputs.addAll(nonChainableOutputs);
  for (  StreamEdge output : allOutputs) {
    config.setSelectedNames(output.getTargetVertex(),streamGraph.getEdge(vertexID,output.getTargetVertex()).getSelectedNames());
  }
  vertexConfigs.put(vertexID,config);
}
