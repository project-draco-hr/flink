{
  if (!builtVertices.contains(startNode)) {
    List<Tuple2<Integer,Integer>> transitiveOutEdges=new ArrayList<Tuple2<Integer,Integer>>();
    List<StreamEdge> chainableOutputs=new ArrayList<StreamEdge>();
    List<StreamEdge> nonChainableOutputs=new ArrayList<StreamEdge>();
    for (    StreamEdge outEdge : streamGraph.getOutEdges(current)) {
      if (isChainable(outEdge)) {
        chainableOutputs.add(outEdge);
      }
 else {
        nonChainableOutputs.add(outEdge);
      }
    }
    for (    StreamEdge chainable : chainableOutputs) {
      transitiveOutEdges.addAll(createChain(startNode,chainable.getTargetVertex()));
    }
    for (    StreamEdge nonChainable : nonChainableOutputs) {
      transitiveOutEdges.add(new Tuple2<Integer,Integer>(current,nonChainable.getTargetVertex()));
      createChain(nonChainable.getTargetVertex(),nonChainable.getTargetVertex());
    }
    chainedNames.put(current,createChainedName(current,chainableOutputs));
    StreamConfig config=current.equals(startNode) ? createProcessingVertex(startNode) : new StreamConfig(new Configuration());
    setVertexConfig(current,config,chainableOutputs,nonChainableOutputs);
    if (current.equals(startNode)) {
      config.setChainStart();
      config.setOutEdgesInOrder(transitiveOutEdges);
      config.setOutEdges(streamGraph.getOutEdges(current));
      config.setInEdges(streamGraph.getInEdges(current));
      for (      Tuple2<Integer,Integer> edge : transitiveOutEdges) {
        connect(startNode,edge);
      }
      config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNode));
    }
 else {
      Map<Integer,StreamConfig> chainedConfs=chainedConfigs.get(startNode);
      if (chainedConfs == null) {
        chainedConfigs.put(startNode,new HashMap<Integer,StreamConfig>());
      }
      chainedConfigs.get(startNode).put(current,config);
    }
    return transitiveOutEdges;
  }
 else {
    return new ArrayList<Tuple2<Integer,Integer>>();
  }
}
