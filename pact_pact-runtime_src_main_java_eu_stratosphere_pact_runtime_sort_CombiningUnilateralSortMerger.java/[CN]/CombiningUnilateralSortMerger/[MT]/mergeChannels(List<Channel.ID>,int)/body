{
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
    freeSegmentsAtShutdown(inputSegments);
    final ChannelReader reader=ioManager.createChannelReader(id,inputSegments,true);
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
  freeSegmentsAtShutdown(outputSegments);
  ChannelWriter writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  outputSegments=writer.close();
  memoryManager.release(outputSegments);
  return mergedChannelID;
}
