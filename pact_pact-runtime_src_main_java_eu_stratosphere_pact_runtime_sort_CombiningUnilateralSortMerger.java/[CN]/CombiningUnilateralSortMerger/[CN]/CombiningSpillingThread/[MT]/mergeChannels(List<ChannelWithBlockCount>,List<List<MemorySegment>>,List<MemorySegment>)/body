{
  final List<BlockChannelAccess<?,?>> channelAccesses=new ArrayList<BlockChannelAccess<?,?>>(channelIDs.size());
  final MergeIterator<E> mergeIterator=getMergingIterator(channelIDs,readBuffers,channelAccesses);
  final KeyGroupedIterator<E> groupedIter=new KeyGroupedIterator<E>(mergeIterator,this.serializer,this.comparator2);
  final Channel.ID mergedChannelID=this.ioManager.createChannel();
  registerChannelToBeRemovedAtShudown(mergedChannelID);
  final BlockChannelWriter writer=this.ioManager.createBlockChannelWriter(mergedChannelID,this.numWriteBuffersToCluster);
  registerOpenChannelToBeRemovedAtShudown(writer);
  final ChannelWriterOutputView output=new ChannelWriterOutputView(writer,writeBuffers,this.memManager.getPageSize());
  final WriterCollector<E> collector=new WriterCollector<E>(output,this.serializer);
  final GenericReducer<E,?> combineStub=CombiningUnilateralSortMerger.this.combineStub;
  try {
    while (groupedIter.nextKey()) {
      combineStub.combine(groupedIter.getValues(),collector);
    }
  }
 catch (  Exception e) {
    throw new IOException("An error occurred in the combiner user code.");
  }
  output.close();
  final int numBlocksWritten=output.getBlockCount();
  unregisterOpenChannelToBeRemovedAtShudown(writer);
  for (int i=0; i < channelAccesses.size(); i++) {
    BlockChannelAccess<?,?> access=channelAccesses.get(i);
    access.closeAndDelete();
    unregisterOpenChannelToBeRemovedAtShudown(access);
  }
  return new ChannelWithBlockCount(mergedChannelID,numBlocksWritten);
}
