{
  final List<Channel> sourceNewOutputChannels=new ArrayList<>();
  final PlanNode sourceNode=channel.getSource();
  final PlanNode targetNode=channel.getTarget();
  final int sourceParallelism=sourceNode.getParallelism();
  final int targetParallelism=targetNode.getParallelism();
  final Costs defaultZeroCosts=new Costs(0,0,0);
  final TypeComparatorFactory<?> comparator=Utils.getShipComparator(channel,this.plan.getOriginalPlan().getExecutionConfig());
  final int sampleSize=SAMPLES_PER_PARTITION * targetParallelism;
  final SampleInPartition sampleInPartition=new SampleInPartition(false,sampleSize,SEED);
  final TypeInformation<?> sourceOutputType=sourceNode.getOptimizerNode().getOperator().getOperatorInfo().getOutputType();
  final TypeInformation<IntermediateSampleData> isdTypeInformation=TypeExtractor.getForClass(IntermediateSampleData.class);
  final UnaryOperatorInformation sipOperatorInformation=new UnaryOperatorInformation(sourceOutputType,isdTypeInformation);
  final MapPartitionOperatorBase sipOperatorBase=new MapPartitionOperatorBase(sampleInPartition,sipOperatorInformation,SIP_NAME);
  final MapPartitionNode sipNode=new MapPartitionNode(sipOperatorBase);
  final Channel sipChannel=new Channel(sourceNode,TempMode.NONE);
  sipChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);
  final SingleInputPlanNode sipPlanNode=new SingleInputPlanNode(sipNode,SIP_NAME,sipChannel,DriverStrategy.MAP_PARTITION);
  sipNode.setParallelism(sourceParallelism);
  sipPlanNode.setParallelism(sourceParallelism);
  sipPlanNode.initProperties(new GlobalProperties(),new LocalProperties());
  sipPlanNode.setCosts(defaultZeroCosts);
  sipChannel.setTarget(sipPlanNode);
  this.plan.getAllNodes().add(sipPlanNode);
  sourceNewOutputChannels.add(sipChannel);
  final SampleInCoordinator sampleInCoordinator=new SampleInCoordinator(false,sampleSize,SEED);
  final UnaryOperatorInformation sicOperatorInformation=new UnaryOperatorInformation(isdTypeInformation,sourceOutputType);
  final GroupReduceOperatorBase sicOperatorBase=new GroupReduceOperatorBase(sampleInCoordinator,sicOperatorInformation,SIC_NAME);
  final GroupReduceNode sicNode=new GroupReduceNode(sicOperatorBase);
  final Channel sicChannel=new Channel(sipPlanNode,TempMode.NONE);
  sicChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);
  final SingleInputPlanNode sicPlanNode=new SingleInputPlanNode(sicNode,SIC_NAME,sicChannel,DriverStrategy.ALL_GROUP_REDUCE);
  sicNode.setParallelism(1);
  sicPlanNode.setParallelism(1);
  sicPlanNode.initProperties(new GlobalProperties(),new LocalProperties());
  sicPlanNode.setCosts(defaultZeroCosts);
  sicChannel.setTarget(sicPlanNode);
  sipPlanNode.addOutgoingChannel(sicChannel);
  this.plan.getAllNodes().add(sicPlanNode);
  final RangeBoundaryBuilder rangeBoundaryBuilder=new RangeBoundaryBuilder(comparator,targetParallelism);
  final TypeInformation<CommonRangeBoundaries> rbTypeInformation=TypeExtractor.getForClass(CommonRangeBoundaries.class);
  final UnaryOperatorInformation rbOperatorInformation=new UnaryOperatorInformation(sourceOutputType,rbTypeInformation);
  final MapPartitionOperatorBase rbOperatorBase=new MapPartitionOperatorBase(rangeBoundaryBuilder,rbOperatorInformation,RB_NAME);
  final MapPartitionNode rbNode=new MapPartitionNode(rbOperatorBase);
  final Channel rbChannel=new Channel(sicPlanNode,TempMode.NONE);
  rbChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);
  final SingleInputPlanNode rbPlanNode=new SingleInputPlanNode(rbNode,RB_NAME,rbChannel,DriverStrategy.MAP_PARTITION);
  rbNode.setParallelism(1);
  rbPlanNode.setParallelism(1);
  rbPlanNode.initProperties(new GlobalProperties(),new LocalProperties());
  rbPlanNode.setCosts(defaultZeroCosts);
  rbChannel.setTarget(rbPlanNode);
  sicPlanNode.addOutgoingChannel(rbChannel);
  this.plan.getAllNodes().add(rbPlanNode);
  final AssignRangeIndex assignRangeIndex=new AssignRangeIndex(comparator);
  final TypeInformation<Tuple2> ariOutputTypeInformation=new TupleTypeInfo<>(BasicTypeInfo.INT_TYPE_INFO,sourceOutputType);
  final UnaryOperatorInformation ariOperatorInformation=new UnaryOperatorInformation(sourceOutputType,ariOutputTypeInformation);
  final MapPartitionOperatorBase ariOperatorBase=new MapPartitionOperatorBase(assignRangeIndex,ariOperatorInformation,ARI_NAME);
  final MapPartitionNode ariNode=new MapPartitionNode(ariOperatorBase);
  final Channel ariChannel=new Channel(sourceNode,TempMode.NONE);
  ariChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.BATCH);
  final SingleInputPlanNode ariPlanNode=new SingleInputPlanNode(ariNode,ARI_NAME,ariChannel,DriverStrategy.MAP_PARTITION);
  ariNode.setParallelism(sourceParallelism);
  ariPlanNode.setParallelism(sourceParallelism);
  ariPlanNode.initProperties(new GlobalProperties(),new LocalProperties());
  ariPlanNode.setCosts(defaultZeroCosts);
  ariChannel.setTarget(ariPlanNode);
  this.plan.getAllNodes().add(ariPlanNode);
  sourceNewOutputChannels.add(ariChannel);
  final NamedChannel broadcastChannel=new NamedChannel("RangeBoundaries",rbPlanNode);
  broadcastChannel.setShipStrategy(ShipStrategyType.BROADCAST,DataExchangeMode.PIPELINED);
  broadcastChannel.setTarget(ariPlanNode);
  List<NamedChannel> broadcastChannels=new ArrayList<>(1);
  broadcastChannels.add(broadcastChannel);
  ariPlanNode.setBroadcastInputs(broadcastChannels);
  final Channel partChannel=new Channel(ariPlanNode,TempMode.NONE);
  final FieldList keys=new FieldList(0);
  partChannel.setShipStrategy(ShipStrategyType.PARTITION_CUSTOM,keys,idPartitioner,DataExchangeMode.PIPELINED);
  ariPlanNode.addOutgoingChannel(partChannel);
  final RemoveRangeIndex partitionIDRemoveWrapper=new RemoveRangeIndex();
  final UnaryOperatorInformation prOperatorInformation=new UnaryOperatorInformation(ariOutputTypeInformation,sourceOutputType);
  final MapOperatorBase prOperatorBase=new MapOperatorBase(partitionIDRemoveWrapper,prOperatorInformation,PR_NAME);
  final MapNode prRemoverNode=new MapNode(prOperatorBase);
  final SingleInputPlanNode prPlanNode=new SingleInputPlanNode(prRemoverNode,PR_NAME,partChannel,DriverStrategy.MAP);
  partChannel.setTarget(prPlanNode);
  prRemoverNode.setParallelism(targetParallelism);
  prPlanNode.setParallelism(targetParallelism);
  GlobalProperties globalProperties=new GlobalProperties();
  globalProperties.setRangePartitioned(new Ordering(0,null,Order.ASCENDING));
  prPlanNode.initProperties(globalProperties,new LocalProperties());
  prPlanNode.setCosts(defaultZeroCosts);
  this.plan.getAllNodes().add(prPlanNode);
  channel.setSource(prPlanNode);
  channel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);
  prPlanNode.addOutgoingChannel(channel);
  return sourceNewOutputChannels;
}
