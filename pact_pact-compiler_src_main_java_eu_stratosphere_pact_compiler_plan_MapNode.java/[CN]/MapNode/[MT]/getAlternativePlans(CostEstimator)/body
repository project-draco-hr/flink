{
  if (this.cachedPlans != null) {
    return this.cachedPlans;
  }
  List<OptimizerNode> allPreds=new ArrayList<OptimizerNode>(this.input.size());
  for (  PactConnection c : this.input) {
    allPreds.add(c.getSourcePact());
  }
  List<MapNode> outputPlans=new ArrayList<MapNode>();
  for (  PactConnection c : this.input) {
    List<? extends OptimizerNode> inPlans=c.getSourcePact().getAlternativePlans(estimator);
    for (    OptimizerNode pred : inPlans) {
      ShipStrategy ss=c.getShipStrategy() == ShipStrategy.NONE ? ShipStrategy.FORWARD : c.getShipStrategy();
      GlobalProperties gp=PactConnection.getGlobalPropertiesAfterConnection(pred,this,ss);
      LocalProperties lp=PactConnection.getLocalPropertiesAfterConnection(pred,this,ss);
      MapNode nMap=new MapNode(this,allPreds,this.input,gp,lp);
      for (      PactConnection cc : nMap.getInputConnections()) {
        cc.setShipStrategy(ss);
      }
      nMap.getGlobalProperties().filterByOutputContract(getOutputContract());
      nMap.getLocalProperties().filterByOutputContract(getOutputContract());
      estimator.costOperator(nMap);
      outputPlans.add(nMap);
    }
  }
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
