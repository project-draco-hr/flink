{
  final Buffer buffer=transferEnvelope.getBuffer();
  if (buffer != null) {
    if (buffer.isBackedByMemory()) {
      final Buffer fileBuffer=BufferFactory.createFromFile(buffer.size(),this.vertexID,this.fileBufferManager);
      buffer.copyToBuffer(fileBuffer);
      transferEnvelope.setBuffer(fileBuffer);
      buffer.recycleBuffer();
    }
  }
  if (this.numberOfSerializedTransferEnvelopes % ENVELOPES_PER_META_DATA_FILE == 0) {
    if (this.metaDataFileChannel != null) {
      this.metaDataFileChannel.close();
      this.metaDataFileChannel=null;
      ++this.metaDataSuffix;
    }
  }
  if (this.metaDataFileChannel == null) {
    final String checkpointDir=GlobalConfiguration.getString(CheckpointManager.CHECKPOINT_DIRECTORY_KEY,CheckpointManager.DEFAULT_CHECKPOINT_DIRECTORY);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Writing checkpointing meta data to directory " + checkpointDir);
    }
    final FileOutputStream fos=new FileOutputStream(checkpointDir + File.separator + CheckpointManager.METADATA_PREFIX+ "_"+ this.vertexID+ "_"+ this.metaDataSuffix);
    this.metaDataFileChannel=fos.getChannel();
  }
  this.transferEnvelopeSerializer.setTransferEnvelope(transferEnvelope);
  while (this.transferEnvelopeSerializer.write(this.metaDataFileChannel)) {
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (eventList != null) {
    final Iterator<AbstractEvent> it=eventList.iterator();
    while (it.hasNext()) {
      if (it.next() instanceof ByteBufferedChannelCloseEvent) {
        ++this.numberOfClosedChannels;
      }
    }
  }
  ++this.numberOfSerializedTransferEnvelopes;
  if (this.numberOfClosedChannels == this.numberOfConnectedChannels) {
    if (this.metaDataFileChannel != null) {
      this.metaDataFileChannel.close();
    }
    final String checkpointDir=GlobalConfiguration.getString(CheckpointManager.CHECKPOINT_DIRECTORY_KEY,CheckpointManager.DEFAULT_CHECKPOINT_DIRECTORY);
    new FileOutputStream(checkpointDir + File.separator + CheckpointManager.METADATA_PREFIX+ "_"+ this.vertexID+ "_final").close();
    this.fileBufferManager.forceCloseOfWritableSpillingFile(this.vertexID);
    LOG.info("Finished persistent checkpoint for vertex " + this.vertexID);
  }
}
