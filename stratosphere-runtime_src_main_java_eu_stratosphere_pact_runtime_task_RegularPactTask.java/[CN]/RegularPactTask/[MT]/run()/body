{
  if (!this.running) {
    return;
  }
  boolean stubOpen=false;
  try {
    try {
      this.driver.prepare();
    }
 catch (    Throwable t) {
      throw new Exception("The data preparation for task '" + this.getEnvironment().getTaskName() + "' , caused an error: "+ t.getMessage(),t);
    }
    if (!this.running) {
      return;
    }
    for (int i=0; i < this.config.getNumBroadcastInputs(); i++) {
      final String name=this.config.getBroadcastInputName(i);
      @SuppressWarnings("unchecked") final MutableObjectIterator<Object> reader=(MutableObjectIterator<Object>)this.broadcastInputIterators[i];
      @SuppressWarnings("unchecked") final TypeSerializer<Object> serializer=(TypeSerializer<Object>)this.broadcastInputSerializers[i];
      Collection<Object> collection=new ArrayList<Object>();
      Object record=serializer.createInstance();
      while (this.running && reader.next(record)) {
        collection.add(record);
        record=serializer.createInstance();
      }
      this.stub.getRuntimeContext().setBroadcastVariable(name,collection);
    }
    RegularPactTask.openChainedTasks(this.chainedTasks,this);
    if (this.stub != null) {
      try {
        Configuration stubConfig=this.config.getStubParameters();
        this.stub.open(stubConfig);
        stubOpen=true;
      }
 catch (      Throwable t) {
        throw new Exception("The user defined 'open()' method caused an exception: " + t.getMessage(),t);
      }
    }
    this.driver.run();
    if (this.running && this.stub != null) {
      this.stub.close();
      stubOpen=false;
    }
    this.output.close();
    RegularPactTask.closeChainedTasks(this.chainedTasks,this);
    if (this.stub != null) {
      Map<String,Accumulator<?,?>> accumulators=this.stub.getRuntimeContext().getAllAccumulators();
      RegularPactTask.reportAndClearAccumulators(getEnvironment(),accumulators,this.chainedTasks);
    }
  }
 catch (  Exception ex) {
    if (stubOpen) {
      try {
        this.stub.close();
      }
 catch (      Throwable t) {
      }
    }
    RegularPactTask.cancelChainedTasks(this.chainedTasks);
    if (this.running) {
      RegularPactTask.logAndThrowException(ex,this);
    }
  }
 finally {
    this.driver.cleanup();
  }
}
