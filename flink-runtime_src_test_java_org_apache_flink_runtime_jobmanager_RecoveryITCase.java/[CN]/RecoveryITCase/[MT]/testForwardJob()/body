{
  ReceiverFailingOnce.resetFailedBefore();
  final int NUM_TASKS=31;
  JobManager jm=null;
  try {
    final AbstractJobVertex sender=new AbstractJobVertex("Sender");
    final AbstractJobVertex receiver=new AbstractJobVertex("Receiver");
    sender.setInvokableClass(Sender.class);
    receiver.setInvokableClass(ReceiverFailingOnce.class);
    sender.setParallelism(NUM_TASKS);
    receiver.setParallelism(NUM_TASKS);
    receiver.connectNewDataSetAsInput(sender,DistributionPattern.POINTWISE);
    final JobGraph jobGraph=new JobGraph("Pointwise Job",sender,receiver);
    jobGraph.setNumberOfExecutionRetries(1);
    jm=startJobManager(2 * NUM_TASKS);
    final GlobalBufferPool bp=((LocalInstanceManager)jm.getInstanceManager()).getTaskManagers()[0].getChannelManager().getGlobalBufferPool();
    JobSubmissionResult result=jm.submitJob(jobGraph);
    if (result.getReturnCode() != AbstractJobResult.ReturnCode.SUCCESS) {
      System.out.println(result.getDescription());
    }
    assertEquals(AbstractJobResult.ReturnCode.SUCCESS,result.getReturnCode());
    ExecutionGraph eg=jm.getCurrentJobs().get(jobGraph.getJobID());
    if (eg != null) {
      eg.waitForJobEnd();
      if (eg.getState() != JobStatus.FINISHED) {
        Throwable t=eg.getFailureCause();
        String message=null;
        if (t != null) {
          t.printStackTrace();
          message=t.getMessage();
        }
        fail("Execution failed despite recovery: " + message);
      }
    }
 else {
    }
    waitForTaskThreadsToBeTerminated();
    assertEquals(bp.numBuffers(),bp.numAvailableBuffers());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    if (jm != null) {
      jm.shutdown();
    }
  }
}
