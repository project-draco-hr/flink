{
  final int NUM_TASKS=31;
  JobManager jm=null;
  try {
    final AbstractJobVertex sender=new AbstractJobVertex("Sender");
    final AbstractJobVertex receiver=new AbstractJobVertex("Receiver");
    sender.setInvokableClass(Sender.class);
    receiver.setInvokableClass(ReceiverBlockingOnce.class);
    sender.setParallelism(NUM_TASKS);
    receiver.setParallelism(NUM_TASKS);
    receiver.connectNewDataSetAsInput(sender,DistributionPattern.POINTWISE);
    SlotSharingGroup sharingGroup=new SlotSharingGroup();
    sender.setSlotSharingGroup(sharingGroup);
    receiver.setSlotSharingGroup(sharingGroup);
    final JobGraph jobGraph=new JobGraph("Pointwise Job",sender,receiver);
    jobGraph.setNumberOfExecutionRetries(1);
    Configuration cfg=new Configuration();
    cfg.setInteger(ConfigConstants.JOB_MANAGER_DEAD_TASKMANAGER_TIMEOUT_KEY,3000);
    cfg.setInteger(ConfigConstants.TASK_MANAGER_HEARTBEAT_INTERVAL_KEY,1000);
    jm=startJobManager(2,NUM_TASKS,cfg);
    JobSubmissionResult result=jm.submitJob(jobGraph);
    if (result.getReturnCode() != AbstractJobResult.ReturnCode.SUCCESS) {
      System.out.println(result.getDescription());
    }
    assertEquals(AbstractJobResult.ReturnCode.SUCCESS,result.getReturnCode());
    ExecutionGraph eg=jm.getCurrentJobs().get(jobGraph.getJobID());
    Thread.sleep(300);
    ReceiverBlockingOnce.setShouldNotBlock();
    ((LocalInstanceManager)jm.getInstanceManager()).getTaskManagers()[0].shutdown();
    if (eg != null) {
      eg.waitForJobEnd();
      if (eg.getState() != JobStatus.FINISHED) {
        Throwable t=eg.getFailureCause();
        String message=null;
        if (t != null) {
          t.printStackTrace();
          message=t.getMessage();
        }
        fail("Execution failed despite recovery: " + message);
      }
    }
 else {
    }
    waitForTaskThreadsToBeTerminated();
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    if (jm != null) {
      jm.shutdown();
    }
  }
}
