{
  requestPartitionsOnce();
  while (true) {
    if (Thread.interrupted()) {
      throw new InterruptedException();
    }
    InputChannel currentChannel=null;
    while (currentChannel == null) {
      currentChannel=inputChannelsWithData.poll(2000,TimeUnit.MILLISECONDS);
    }
    isTaskEvent=false;
    final Buffer buffer=currentChannel.getNextBuffer();
    if (buffer == null) {
      throw new IllegalStateException("Bug in reader logic: queried for a buffer although none was available.");
    }
    if (buffer.isBuffer()) {
      channelIndexOfLastReadBuffer=currentChannel.getChannelIndex();
      return buffer;
    }
 else {
      try {
        final AbstractEvent event=EventSerializer.fromBuffer(buffer,getClass().getClassLoader());
        if (event.getClass() == EndOfPartitionEvent.class) {
          currentChannel.releaseAllResources();
          return null;
        }
 else         if (event.getClass() == EndOfSuperstepEvent.class) {
          incrementEndOfSuperstepEventAndCheck();
          return null;
        }
 else         if (event instanceof TaskEvent) {
          taskEventHandler.publish((TaskEvent)event);
          isTaskEvent=true;
          return null;
        }
 else {
          throw new IllegalStateException("Received unexpected event " + event + " from input channel "+ currentChannel+ ".");
        }
      }
 catch (      Throwable t) {
        throw new IOException("Error while reading event: " + t.getMessage(),t);
      }
 finally {
        buffer.recycle();
      }
    }
  }
}
