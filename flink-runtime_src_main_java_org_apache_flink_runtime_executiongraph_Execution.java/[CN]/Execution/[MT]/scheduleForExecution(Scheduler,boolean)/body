{
  if (scheduler == null) {
    throw new NullPointerException();
  }
  final SlotSharingGroup sharingGroup=vertex.getJobVertex().getSlotSharingGroup();
  final CoLocationConstraint locationConstraint=vertex.getLocationConstraint();
  if (locationConstraint != null && sharingGroup == null) {
    throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.");
  }
  if (transitionState(CREATED,SCHEDULED)) {
    ScheduledUnit toSchedule=locationConstraint == null ? new ScheduledUnit(this,sharingGroup) : new ScheduledUnit(this,sharingGroup,locationConstraint);
    if (queued) {
      SlotAllocationFuture future=scheduler.scheduleQueued(toSchedule);
      future.setFutureAction(new SlotAllocationFutureAction(){
        @Override public void slotAllocated(        AllocatedSlot slot){
          try {
            deployToSlot(slot);
          }
 catch (          Throwable t) {
            try {
              slot.releaseSlot();
            }
  finally {
              markFailed(t);
            }
          }
        }
      }
);
    }
 else {
      AllocatedSlot slot=scheduler.scheduleImmediately(toSchedule);
      try {
        deployToSlot(slot);
      }
 catch (      Throwable t) {
        try {
          slot.releaseSlot();
        }
  finally {
          markFailed(t);
        }
      }
    }
  }
 else {
    return;
  }
}
