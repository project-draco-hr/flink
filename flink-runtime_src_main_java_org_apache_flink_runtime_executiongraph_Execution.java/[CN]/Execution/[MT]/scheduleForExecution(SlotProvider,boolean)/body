{
  if (slotProvider == null) {
    throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.");
  }
  final SlotSharingGroup sharingGroup=vertex.getJobVertex().getSlotSharingGroup();
  final CoLocationConstraint locationConstraint=vertex.getLocationConstraint();
  if (locationConstraint != null && sharingGroup == null) {
    throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.");
  }
  if (transitionState(CREATED,SCHEDULED)) {
    ScheduledUnit toSchedule=locationConstraint == null ? new ScheduledUnit(this,sharingGroup) : new ScheduledUnit(this,sharingGroup,locationConstraint);
    final Future<SimpleSlot> future=slotProvider.allocateSlot(toSchedule,queued);
    if (queued) {
      future.handleAsync(new BiFunction<SimpleSlot,Throwable,Void>(){
        @Override public Void apply(        SimpleSlot simpleSlot,        Throwable throwable){
          if (simpleSlot != null) {
            try {
              deployToSlot(simpleSlot);
            }
 catch (            Throwable t) {
              try {
                simpleSlot.releaseSlot();
              }
  finally {
                markFailed(t);
              }
            }
          }
 else {
            markFailed(throwable);
          }
          return null;
        }
      }
,ExecutionContext$.MODULE$.global());
    }
 else {
      SimpleSlot slot=null;
      try {
        slot=checkNotNull(future.getNow(null));
        deployToSlot(slot);
      }
 catch (      Throwable t) {
        try {
          if (slot != null) {
            slot.releaseSlot();
          }
        }
  finally {
          markFailed(t);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}
