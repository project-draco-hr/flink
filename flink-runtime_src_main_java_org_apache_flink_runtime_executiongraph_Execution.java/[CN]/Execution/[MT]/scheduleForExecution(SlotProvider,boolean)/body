{
  if (slotProvider == null) {
    throw new IllegalArgumentException("Cannot send null Scheduler when scheduling execution.");
  }
  final SlotSharingGroup sharingGroup=vertex.getJobVertex().getSlotSharingGroup();
  final CoLocationConstraint locationConstraint=vertex.getLocationConstraint();
  if (locationConstraint != null && sharingGroup == null) {
    throw new RuntimeException("Trying to schedule with co-location constraint but without slot sharing allowed.");
  }
  if (transitionState(CREATED,SCHEDULED)) {
    ScheduledUnit toSchedule=locationConstraint == null ? new ScheduledUnit(this,sharingGroup) : new ScheduledUnit(this,sharingGroup,locationConstraint);
    final SlotAllocationFuture future=slotProvider.allocateSlot(toSchedule,queued);
    if (queued) {
      future.setFutureAction(new SlotAllocationFutureAction(){
        @Override public void slotAllocated(        SimpleSlot slot){
          try {
            deployToSlot(slot);
          }
 catch (          Throwable t) {
            try {
              slot.releaseSlot();
            }
  finally {
              markFailed(t);
            }
          }
        }
      }
);
    }
 else {
      SimpleSlot slot=future.get();
      try {
        deployToSlot(slot);
      }
 catch (      Throwable t) {
        try {
          slot.releaseSlot();
        }
  finally {
          markFailed(t);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}
