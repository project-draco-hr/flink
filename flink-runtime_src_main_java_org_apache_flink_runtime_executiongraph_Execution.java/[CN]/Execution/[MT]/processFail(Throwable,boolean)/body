{
  while (true) {
    ExecutionState current=this.state;
    if (current == FAILED) {
      return false;
    }
    if (current == CANCELED || (current == CANCELING && isCallback)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(String.format("Ignoring transition of vertex %s to %s while being %s",getVertexWithAttempt(),FAILED,current));
      }
      return false;
    }
    if (transitionState(current,FAILED)) {
      if (!isCallback && (current == RUNNING || current == DEPLOYING)) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Sending out cancel request, to remove task execution from TaskManager.");
        }
        try {
          if (assignedResource != null) {
            sendCancelRpcCall();
          }
        }
 catch (        Throwable tt) {
          LOG.error("Error triggering cancel call while marking task as failed.",tt);
        }
      }
      try {
        this.failureCause=t;
        vertex.executionFailed(t);
        vertex.notifyStateTransition(attemptId,FAILED,t);
      }
  finally {
        if (assignedResource != null) {
          assignedResource.releaseSlot();
        }
        vertex.getExecutionGraph().deregisterExecution(this);
      }
      return true;
    }
  }
}
