{
  if (slot == null) {
    throw new NullPointerException();
  }
  if (!slot.isAlive()) {
    throw new JobException("Target slot for deployment is not alive.");
  }
  ExecutionState previous=this.state;
  if (previous == SCHEDULED || previous == CREATED) {
    if (!transitionState(previous,DEPLOYING)) {
      throw new IllegalStateException("Cannot deploy task: Concurrent deployment call race.");
    }
  }
 else {
    throw new IllegalStateException("The vertex must be in CREATED or SCHEDULED state to be deployed. Found state " + previous);
  }
  try {
    if (!slot.setExecutedVertex(this)) {
      throw new JobException("Could not assign the ExecutionVertex to the slot " + slot);
    }
    this.assignedResource=slot;
    this.assignedResourceLocation=slot.getInstance().getInstanceConnectionInfo();
    if (this.state != DEPLOYING) {
      slot.releaseSlot();
      return;
    }
    if (LOG.isInfoEnabled()) {
      LOG.info(String.format("Deploying %s (attempt #%d) to %s",vertex.getSimpleName(),attemptNumber,slot.getInstance().getInstanceConnectionInfo().getHostname()));
    }
    final TaskDeploymentDescriptor deployment=vertex.createDeploymentDescriptor(attemptId,slot);
    vertex.getExecutionGraph().registerExecution(this);
    Instance instance=slot.getInstance();
    Future<Object> deployAction=Patterns.ask(instance.getTaskManager(),new TaskManagerMessages.SubmitTask(deployment),new Timeout(timeout));
    deployAction.onComplete(new OnComplete<Object>(){
      @Override public void onComplete(      Throwable failure,      Object success) throws Throwable {
        if (failure != null) {
          markFailed(failure);
        }
 else {
          if (success == null) {
            markFailed(new Exception("Failed to deploy the task to slot " + slot + ": TaskOperationResult was null"));
          }
          if (success instanceof TaskOperationResult) {
            TaskOperationResult result=(TaskOperationResult)success;
            if (!result.executionID().equals(attemptId)) {
              markFailed(new Exception("Answer execution id does not match the request execution id."));
            }
 else             if (result.success()) {
              switchToRunning();
            }
 else {
              markFailed(new Exception("Failed to deploy the task " + getVertexWithAttempt() + " to slot "+ slot+ ": "+ result.description()));
            }
          }
 else {
            markFailed(new Exception("Failed to deploy the task to slot " + slot + ": Response was not of type TaskOperationResult"));
          }
        }
      }
    }
,AkkaUtils.globalExecutionContext());
  }
 catch (  Throwable t) {
    markFailed(t);
    ExceptionUtils.rethrow(t);
  }
}
