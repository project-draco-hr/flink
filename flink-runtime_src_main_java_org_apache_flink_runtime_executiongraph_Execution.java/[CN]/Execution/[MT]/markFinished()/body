{
  while (true) {
    ExecutionState current=this.state;
    if (current == RUNNING || current == DEPLOYING) {
      if (transitionState(current,FINISHED)) {
        try {
          if (getVertex().finishAllBlockingPartitions()) {
            IntermediateResult[] allResults=getVertex().getJobVertex().getProducedDataSets();
            LOG.debug("Finished all produced partitions ({}). Scheduling all receivers " + "of the following datasets: {}.",this,Arrays.toString(allResults));
            for (            IntermediateResult result : allResults) {
              for (              IntermediateResultPartition p : result.getPartitions()) {
                scheduleOrUpdateConsumers(p.getConsumers());
              }
            }
          }
          assignedResource.releaseSlot();
          vertex.getExecutionGraph().deregisterExecution(this);
        }
  finally {
          vertex.executionFinished();
        }
        return;
      }
    }
 else     if (current == CANCELING) {
      cancelingComplete();
      return;
    }
 else     if (current == CANCELED || current == FAILED) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Task FINISHED, but concurrently went to state " + state);
      }
      return;
    }
 else {
      markFailed(new Exception("Vertex received FINISHED message while being in state " + state));
      return;
    }
  }
}
