{
  final int numConsumers=allConsumers.size();
  if (numConsumers > 1) {
    fail(new IllegalStateException("Currently, only a single consumer group per partition is supported."));
  }
 else   if (numConsumers == 0) {
    return;
  }
  for (  ExecutionEdge edge : allConsumers.get(0)) {
    final ExecutionVertex consumerVertex=edge.getTarget();
    final Execution consumer=consumerVertex.getCurrentExecutionAttempt();
    final ExecutionState consumerState=consumer.getState();
    final IntermediateResultPartition partition=edge.getSource();
    if (consumerState == CREATED) {
      final Execution partitionExecution=partition.getProducer().getCurrentExecutionAttempt();
      consumerVertex.cachePartitionInfo(PartialInputChannelDeploymentDescriptor.fromEdge(partition,partitionExecution));
      future(new Callable<Boolean>(){
        @Override public Boolean call() throws Exception {
          try {
            final ExecutionGraph consumerGraph=consumerVertex.getExecutionGraph();
            consumerVertex.scheduleForExecution(consumerVertex.getExecutionGraph().getScheduler(),consumerVertex.getExecutionGraph().isQueuedSchedulingAllowed());
          }
 catch (          Throwable t) {
            fail(new IllegalStateException("Could not schedule consumer " + "vertex " + consumerVertex,t));
          }
          return true;
        }
      }
,AkkaUtils.globalExecutionContext());
      if (consumerVertex.getExecutionState() == RUNNING) {
        consumerVertex.sendPartitionInfos();
      }
    }
 else {
      if (consumerState == RUNNING) {
        final SimpleSlot consumerSlot=consumer.getAssignedResource();
        if (consumerSlot == null) {
          continue;
        }
        final Instance consumerInstance=consumerSlot.getInstance();
        final ResultPartitionID partitionId=new ResultPartitionID(partition.getPartitionId(),attemptId);
        final Instance partitionInstance=partition.getProducer().getCurrentAssignedResource().getInstance();
        final ResultPartitionLocation partitionLocation;
        if (consumerInstance.equals(partitionInstance)) {
          partitionLocation=ResultPartitionLocation.createLocal();
        }
 else {
          final ConnectionID connectionId=new ConnectionID(partitionInstance.getInstanceConnectionInfo(),partition.getIntermediateResult().getConnectionIndex());
          partitionLocation=ResultPartitionLocation.createRemote(connectionId);
        }
        final InputChannelDeploymentDescriptor descriptor=new InputChannelDeploymentDescriptor(partitionId,partitionLocation);
        final UpdatePartitionInfo updateTaskMessage=new UpdateTaskSinglePartitionInfo(consumer.getAttemptId(),partition.getIntermediateResult().getId(),descriptor);
        sendUpdateTaskRpcCall(consumerSlot,updateTaskMessage);
      }
 else       if (consumerState == SCHEDULED || consumerState == DEPLOYING) {
        final Execution partitionExecution=partition.getProducer().getCurrentExecutionAttempt();
        consumerVertex.cachePartitionInfo(PartialInputChannelDeploymentDescriptor.fromEdge(partition,partitionExecution));
        if (consumerVertex.getExecutionState() == RUNNING) {
          consumerVertex.sendPartitionInfos();
        }
      }
    }
  }
}
