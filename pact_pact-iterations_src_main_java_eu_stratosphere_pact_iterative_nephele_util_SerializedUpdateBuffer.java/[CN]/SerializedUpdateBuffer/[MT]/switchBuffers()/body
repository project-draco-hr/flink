{
  for (int i=this.readEnds.size() - 1; i >= 0; --i) {
    final ReadEnd re=this.readEnds.get(i);
    if (re.disposeIfDone()) {
      this.readEnds.remove(i);
    }
  }
  final MemorySegment current=getCurrentSegment();
  current.putInt(0,getCurrentPositionInSegment());
  this.fullBuffers.addLast(current);
  final ReadEnd readEnd;
  if (this.numBuffersSpilled == 0 && this.emptyBuffers.size() >= this.minBuffersForWriteEnd) {
    readEnd=new ReadEnd(this.fullBuffers.removeFirst(),this.emptyBuffers,this.fullBuffers,null,null,this.segmentSize,0);
  }
 else {
    int toSpill=Math.min(this.minBuffersForSpilledReadEnd + this.minBuffersForWriteEnd - this.emptyBuffers.size(),this.fullBuffers.size());
    if (toSpill > 0) {
      if (this.currentWriter == null) {
        this.currentWriter=this.ioManager.createBlockChannelWriter(this.channelEnumerator.next(),this.emptyBuffers);
      }
      for (int i=0; i < toSpill; i++) {
        this.currentWriter.writeBlock(this.fullBuffers.removeFirst());
      }
      this.numBuffersSpilled+=toSpill;
    }
    this.currentWriter.close();
    final BlockChannelReader reader=this.ioManager.createBlockChannelReader(this.currentWriter.getChannelID());
    final ArrayList<MemorySegment> readSegments=new ArrayList<MemorySegment>();
    try {
      while (readSegments.size() < this.minBuffersForSpilledReadEnd) {
        readSegments.add(this.emptyBuffers.take());
      }
      MemorySegment firstSeg=readSegments.remove(readSegments.size() - 1);
      reader.readBlock(firstSeg);
      firstSeg=reader.getReturnQueue().take();
      readEnd=new ReadEnd(firstSeg,this.emptyBuffers,this.fullBuffers,reader,readSegments,this.segmentSize,this.numBuffersSpilled - 1);
    }
 catch (    InterruptedException iex) {
      throw new RuntimeException("SerializedUpdateBuffer was interrupted while reclaiming memory by spilling.");
    }
  }
  this.fullBuffers=new ArrayDeque<MemorySegment>(64);
  this.currentWriter=null;
  this.numBuffersSpilled=0;
  try {
    seekOutput(emptyBuffers.take(),HEADER_LENGTH);
  }
 catch (  InterruptedException iex) {
    throw new RuntimeException("SerializedUpdateBuffer was interrupted while reclaiming memory by spilling.");
  }
  this.readEnds.add(readEnd);
  return readEnd;
}
