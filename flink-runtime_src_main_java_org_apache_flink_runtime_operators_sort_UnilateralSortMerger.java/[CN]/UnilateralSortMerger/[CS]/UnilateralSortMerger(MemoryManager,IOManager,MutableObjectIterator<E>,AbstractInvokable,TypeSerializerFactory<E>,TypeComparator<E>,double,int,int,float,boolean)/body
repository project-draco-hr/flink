{
  if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {
    throw new NullPointerException();
  }
  if (parentTask == null) {
    throw new NullPointerException("Parent Task must not be null.");
  }
  if (maxNumFileHandles < 2) {
    throw new IllegalArgumentException("Merger cannot work with less than two file handles.");
  }
  this.memoryManager=memoryManager;
  final int numPagesTotal=memoryManager.computeNumberOfPages(memoryFraction);
  if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {
    throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " + "Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + " pages. Current page size is "+ memoryManager.getPageSize()+ " bytes.");
  }
  final int numWriteBuffers;
  if (noSpillingMemory) {
    numWriteBuffers=0;
  }
 else {
    final int minBuffers=MIN_NUM_WRITE_BUFFERS + maxNumFileHandles;
    final int desiredBuffers=MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles;
    if (desiredBuffers > numPagesTotal) {
      numWriteBuffers=MIN_NUM_WRITE_BUFFERS;
      if (minBuffers > numPagesTotal) {
        maxNumFileHandles=numPagesTotal - MIN_NUM_WRITE_BUFFERS;
        if (LOG.isDebugEnabled()) {
          LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge");
        }
      }
    }
 else {
      final int designatedWriteBuffers=numPagesTotal / (maxNumFileHandles + 1);
      final int fractional=numPagesTotal / 64;
      final int maximal=numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS;
      numWriteBuffers=Math.max(MIN_NUM_WRITE_BUFFERS,Math.min(Math.min(MAX_NUM_WRITE_BUFFERS,maximal),Math.min(designatedWriteBuffers,fractional)));
    }
  }
  final int sortMemPages=numPagesTotal - numWriteBuffers;
  final long sortMemory=((long)sortMemPages) * memoryManager.getPageSize();
  if (numSortBuffers < 1) {
    if (sortMemory > 96 * 1024 * 1024) {
      numSortBuffers=3;
    }
 else     if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {
      numSortBuffers=2;
    }
 else {
      numSortBuffers=1;
    }
  }
  final int numSegmentsPerSortBuffer=sortMemPages / numSortBuffers;
  if (LOG.isDebugEnabled()) {
    LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (="+ sortMemory+ " bytes total) divided over "+ numSortBuffers+ " sort buffers ("+ numSegmentsPerSortBuffer+ " pages per buffer). Using "+ numWriteBuffers+ " buffers for writing sorted results and merging maximally "+ maxNumFileHandles+ " streams at once.");
  }
  this.writeMemory=new ArrayList<MemorySegment>(numWriteBuffers);
  this.sortReadMemory=new ArrayList<MemorySegment>(sortMemPages);
  memoryManager.allocatePages(parentTask,this.sortReadMemory,sortMemPages);
  if (numWriteBuffers > 0) {
    memoryManager.allocatePages(parentTask,this.writeMemory,numWriteBuffers);
  }
  final CircularQueues<E> circularQueues=new CircularQueues<E>();
  final TypeSerializer<E> serializer=serializerFactory.getSerializer();
  final Iterator<MemorySegment> segments=this.sortReadMemory.iterator();
  for (int i=0; i < numSortBuffers; i++) {
    final List<MemorySegment> sortSegments=new ArrayList<MemorySegment>(numSegmentsPerSortBuffer);
    for (int k=(i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer); k > 0 && segments.hasNext(); k--) {
      sortSegments.add(segments.next());
    }
    final TypeComparator<E> comp=comparator.duplicate();
    final InMemorySorter<E> buffer;
    if (comp.supportsSerializationWithKeyNormalization() && serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING) {
      buffer=new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(),comp,sortSegments);
    }
 else {
      buffer=new NormalizedKeySorter<E>(serializerFactory.getSerializer(),comp,sortSegments);
    }
    CircularElement<E> element=new CircularElement<E>(i,buffer);
    circularQueues.empty.add(element);
  }
  ExceptionHandler<IOException> exceptionHandler=new ExceptionHandler<IOException>(){
    public void handleException(    IOException exception){
      if (!closed) {
        setResultIteratorException(exception);
        close();
      }
    }
  }
;
  this.channelsToDeleteAtShutdown=new HashSet<FileIOChannel.ID>(64);
  this.openChannels=new HashSet<FileIOChannel>(64);
  this.readThread=getReadingThread(exceptionHandler,input,circularQueues,parentTask,serializer,((long)(startSpillingFraction * sortMemory)));
  this.sortThread=getSortingThread(exceptionHandler,circularQueues,parentTask);
  this.spillThread=getSpillingThread(exceptionHandler,circularQueues,parentTask,memoryManager,ioManager,serializerFactory,comparator,this.sortReadMemory,this.writeMemory,maxNumFileHandles);
  startThreads();
}
