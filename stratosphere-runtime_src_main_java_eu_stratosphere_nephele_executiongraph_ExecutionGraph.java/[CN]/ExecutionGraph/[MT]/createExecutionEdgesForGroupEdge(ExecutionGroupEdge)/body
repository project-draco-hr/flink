{
  final ExecutionGroupVertex source=groupEdge.getSourceVertex();
  final int indexOfOutputGate=groupEdge.getIndexOfOutputGate();
  final ExecutionGroupVertex target=groupEdge.getTargetVertex();
  final int indexOfInputGate=groupEdge.getIndexOfInputGate();
  final Map<GateID,List<ExecutionEdge>> inputChannelMap=new HashMap<GateID,List<ExecutionEdge>>();
  final int currentNumberOfSourceNodes=source.getCurrentNumberOfGroupMembers();
  for (int i=0; i < currentNumberOfSourceNodes; ++i) {
    final ExecutionVertex sourceVertex=source.getGroupMember(i);
    final ExecutionGate outputGate=sourceVertex.getOutputGate(indexOfOutputGate);
    if (outputGate == null) {
      throw new IllegalStateException("wire: " + sourceVertex.getName() + " has no output gate with index "+ indexOfOutputGate);
    }
    if (outputGate.getNumberOfEdges() > 0) {
      throw new IllegalStateException("wire: wire called on source " + sourceVertex.getName() + " ("+ i+ "), but number of output channels is "+ outputGate.getNumberOfEdges()+ "!");
    }
    final int currentNumberOfTargetNodes=target.getCurrentNumberOfGroupMembers();
    final List<ExecutionEdge> outputChannels=new ArrayList<ExecutionEdge>();
    for (int j=0; j < currentNumberOfTargetNodes; ++j) {
      final ExecutionVertex targetVertex=target.getGroupMember(j);
      final ExecutionGate inputGate=targetVertex.getInputGate(indexOfInputGate);
      if (inputGate == null) {
        throw new IllegalStateException("wire: " + targetVertex.getName() + " has no input gate with index "+ indexOfInputGate);
      }
      if (inputGate.getNumberOfEdges() > 0 && i == 0) {
        throw new IllegalStateException("wire: wire called on target " + targetVertex.getName() + " ("+ j+ "), but number of input channels is "+ inputGate.getNumberOfEdges()+ "!");
      }
      if (DistributionPatternProvider.createWire(groupEdge.getDistributionPattern(),i,j,currentNumberOfSourceNodes,currentNumberOfTargetNodes)) {
        final ChannelID outputChannelID=new ChannelID();
        final ChannelID inputChannelID=new ChannelID();
        final ExecutionEdge edge=new ExecutionEdge(outputGate,inputGate,groupEdge,outputChannelID,inputChannelID,outputGate.getNumberOfEdges(),inputGate.getNumberOfEdges());
        this.edgeMap.put(outputChannelID,edge);
        this.edgeMap.put(inputChannelID,edge);
        outputChannels.add(edge);
        List<ExecutionEdge> inputChannels=inputChannelMap.get(inputGate.getGateID());
        if (inputChannels == null) {
          inputChannels=new ArrayList<ExecutionEdge>();
          inputChannelMap.put(inputGate.getGateID(),inputChannels);
        }
        inputChannels.add(edge);
      }
    }
    outputGate.replaceAllEdges(outputChannels);
  }
  final int currentNumberOfTargetNodes=target.getCurrentNumberOfGroupMembers();
  for (int i=0; i < currentNumberOfTargetNodes; ++i) {
    final ExecutionVertex targetVertex=target.getGroupMember(i);
    final ExecutionGate inputGate=targetVertex.getInputGate(indexOfInputGate);
    final List<ExecutionEdge> inputChannels=inputChannelMap.get(inputGate.getGateID());
    if (inputChannels == null) {
      LOG.error("Cannot find input channels for gate ID " + inputGate.getGateID());
      continue;
    }
    inputGate.replaceAllEdges(inputChannels);
  }
}
