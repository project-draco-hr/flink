{
  if (!parseParameters(args)) {
    return;
  }
  ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  DataSet<Tuple2<Long,Long>> edges=getEdgeDataSet(env);
  IterativeDataSet<Tuple2<Long,Long>> paths=edges.iterate(maxIterations);
  DataSet<Tuple2<Long,Long>> nextPaths=paths.join(edges).where(1).equalTo(0).with(new JoinFunction<Tuple2<Long,Long>,Tuple2<Long,Long>,Tuple2<Long,Long>>(){
    @Override public Tuple2<Long,Long> join(    Tuple2<Long,Long> left,    Tuple2<Long,Long> right) throws Exception {
      return new Tuple2<Long,Long>(left.f0,right.f1);
    }
  }
).union(paths).groupBy(0,1).reduceGroup(new GroupReduceFunction<Tuple2<Long,Long>,Tuple2<Long,Long>>(){
    @Override public void reduce(    Iterable<Tuple2<Long,Long>> values,    Collector<Tuple2<Long,Long>> out) throws Exception {
      out.collect(values.iterator().next());
    }
  }
);
  DataSet<Tuple2<Long,Long>> newPaths=paths.coGroup(nextPaths).where(0).equalTo(0).with(new CoGroupFunction<Tuple2<Long,Long>,Tuple2<Long,Long>,Tuple2<Long,Long>>(){
    Set<Tuple2<Long,Long>> prevSet=new HashSet<Tuple2<Long,Long>>();
    @Override public void coGroup(    Iterable<Tuple2<Long,Long>> prevPaths,    Iterable<Tuple2<Long,Long>> nextPaths,    Collector<Tuple2<Long,Long>> out) throws Exception {
      for (      Tuple2<Long,Long> prev : prevPaths) {
        prevSet.add(prev);
      }
      for (      Tuple2<Long,Long> next : nextPaths) {
        if (!prevSet.contains(next)) {
          out.collect(next);
        }
      }
    }
  }
);
  DataSet<Tuple2<Long,Long>> transitiveClosure=paths.closeWith(nextPaths,newPaths);
  if (fileOutput) {
    transitiveClosure.writeAsCsv(outputPath,"\n"," ");
  }
 else {
    transitiveClosure.print();
  }
  env.execute("Transitive Closure Example");
}
