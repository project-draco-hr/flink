{
  List<InterestingProperties> thisNodesIntProps=getInterestingProperties();
  List<InterestingProperties> props=null;
switch (getOutputContract()) {
case SameKey:
case SuperKey:
    props=InterestingProperties.filterByOutputContract(thisNodesIntProps,getOutputContract());
  break;
default :
props=new ArrayList<InterestingProperties>();
break;
}
InterestingProperties ip1=new InterestingProperties();
ip1.getGlobalProperties().setPartitioning(PartitionProperty.ANY);
ip1.getLocalProperties().setKeysGrouped(true);
for (PactConnection c : this.input) {
Costs cost=new Costs();
estimator.getHashPartitioningCost(c,cost);
ip1.getMaximalCosts().addCosts(cost);
cost=new Costs();
estimator.getLocalSortCost(this,Collections.<PactConnection>singletonList(c),cost);
ip1.getMaximalCosts().addCosts(cost);
}
InterestingProperties ip2=new InterestingProperties();
ip2.getGlobalProperties().setPartitioning(PartitionProperty.ANY);
for (PactConnection c : this.input) {
Costs cost=new Costs();
estimator.getHashPartitioningCost(c,cost);
ip2.getMaximalCosts().addCosts(cost);
}
InterestingProperties.mergeUnionOfInterestingProperties(props,ip1);
InterestingProperties.mergeUnionOfInterestingProperties(props,ip2);
for (PactConnection c : this.input) {
c.addAllInterestingProperties(props);
}
}
