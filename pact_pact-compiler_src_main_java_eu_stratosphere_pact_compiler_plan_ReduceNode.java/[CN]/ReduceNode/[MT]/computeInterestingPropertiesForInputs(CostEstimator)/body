{
  List<InterestingProperties> thisNodesIntProps=getInterestingProperties();
  List<InterestingProperties> props=null;
switch (getOutputContract()) {
case SameKey:
case SuperKey:
    props=InterestingProperties.filterByOutputContract(thisNodesIntProps,getOutputContract());
  break;
default :
props=new ArrayList<InterestingProperties>();
break;
}
InterestingProperties ip1=new InterestingProperties();
ip1.getGlobalProperties().setPartitioning(PartitionProperty.ANY);
ip1.getLocalProperties().setKeysGrouped(true);
estimator.getHashPartitioningCost(this,this.input.getSourcePact(),ip1.getMaximalCosts());
Costs c=new Costs();
estimator.getLocalSortCost(this,this.input.getSourcePact(),c);
ip1.getMaximalCosts().addCosts(c);
InterestingProperties ip2=new InterestingProperties();
ip2.getGlobalProperties().setPartitioning(PartitionProperty.ANY);
estimator.getHashPartitioningCost(this,this.input.getSourcePact(),ip2.getMaximalCosts());
InterestingProperties.mergeUnionOfInterestingProperties(props,ip1);
InterestingProperties.mergeUnionOfInterestingProperties(props,ip2);
input.addAllInterestingProperties(props);
}
