{
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans=input.getSourcePact().getAlternativePlans(estimator);
  List<ReduceNode> outputPlans=new ArrayList<ReduceNode>();
  for (  OptimizerNode pred : inPlans) {
    ShipStrategy ss=input.getShipStrategy();
    LocalStrategy ls=getLocalStrategy();
    GlobalProperties gp;
    LocalProperties lp;
    if (ss == ShipStrategy.NONE) {
      gp=pred.getGlobalProperties();
      lp=pred.getLocalProperties();
      if (gp.getPartitioning().isPartitioned()) {
        ss=ShipStrategy.FORWARD;
      }
 else {
        ss=ShipStrategy.PARTITION_HASH;
      }
      gp=PactConnection.getGlobalPropertiesAfterConnection(pred,this,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(pred,this,ss);
    }
 else {
      gp=PactConnection.getGlobalPropertiesAfterConnection(pred,this,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(pred,this,ss);
      if (!(gp.getPartitioning().isPartitioned())) {
        continue;
      }
    }
    FieldSet keySet=new FieldSet(getPactContract().getKeyColumnNumbers(0));
    boolean localStrategyNeeded=!lp.getOrdering().groupsFieldSet(keySet);
    if (localStrategyNeeded && lp.isGrouped() == true) {
      localStrategyNeeded=!lp.getGroupedFields().containsAll(keySet);
    }
    if (localStrategyNeeded) {
      if (ls != LocalStrategy.NONE) {
        if (ls != LocalStrategy.COMBININGSORT && ls != LocalStrategy.SORT) {
          continue;
        }
      }
 else {
        ls=isCombineable() ? LocalStrategy.COMBININGSORT : LocalStrategy.SORT;
      }
    }
    if (ls == LocalStrategy.COMBININGSORT || ls == LocalStrategy.SORT) {
      Ordering ordering=new Ordering();
      for (      Integer index : keySet) {
        ordering.appendOrdering(index,Order.ASCENDING);
      }
      lp.setOrdering(ordering);
      lp.setGrouped(true,keySet);
    }
    if (isCombineable() && ss != ShipStrategy.FORWARD) {
      OptimizerNode combiner=new CombinerNode(getPactContract(),pred,combinerReducingFactor);
      combiner.setDegreeOfParallelism(pred.getDegreeOfParallelism());
      estimator.costOperator(combiner);
      pred=combiner;
    }
    ReduceNode n=new ReduceNode(this,pred,input,gp,lp);
    n.input.setShipStrategy(ss);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByKeepSet(getKeepSet(0));
    n.getLocalProperties().filterByKeepSet(getKeepSet(0));
    estimator.costOperator(n);
    outputPlans.add(n);
  }
  if (outputPlans.isEmpty()) {
    throw new CompilerException("Could not create a valid plan for the reduce contract '" + getPactContract().getName() + "'. The compiler hints specified incompatible shipping strategies.");
  }
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
