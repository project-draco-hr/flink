{
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans=input.getSourcePact().getAlternativePlans(estimator);
  List<ReduceNode> outputPlans=new ArrayList<ReduceNode>();
  for (  OptimizerNode pred : inPlans) {
    ShipStrategy ss=input.getShipStrategy();
    LocalStrategy ls=getLocalStrategy();
    GlobalProperties gp;
    LocalProperties lp;
    if (ss == ShipStrategy.NONE) {
      gp=pred.getGlobalProperties();
      lp=pred.getLocalProperties();
      if (gp.getPartitioning().isPartitioned() || gp.isKeyUnique()) {
        ss=ShipStrategy.FORWARD;
      }
 else {
        ss=ShipStrategy.PARTITION_HASH;
      }
      gp=PactConnection.getGlobalPropertiesAfterConnection(pred,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(pred,ss);
    }
 else {
      gp=PactConnection.getGlobalPropertiesAfterConnection(pred,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(pred,ss);
      if (!(gp.getPartitioning().isPartitioned() || gp.isKeyUnique())) {
        continue;
      }
    }
    if (!(lp.areKeysGrouped() || lp.getKeyOrder().isOrdered() || lp.isKeyUnique())) {
      if (ls != LocalStrategy.NONE) {
        if (ls != LocalStrategy.COMBININGSORT && ls != LocalStrategy.SORT) {
          continue;
        }
      }
 else {
        ls=isCombineable() ? LocalStrategy.COMBININGSORT : LocalStrategy.SORT;
      }
    }
    if (ls == LocalStrategy.COMBININGSORT || ls == LocalStrategy.SORT) {
      lp.setKeyOrder(Order.ASCENDING);
      lp.setKeysGrouped(true);
    }
    if (isCombineable() && ss != ShipStrategy.FORWARD) {
      OptimizerNode combiner=new CombinerNode(getPactContract(),pred,combinerReducingFactor);
      combiner.setDegreeOfParallelism(pred.getDegreeOfParallelism());
      estimator.costOperator(combiner);
      pred=combiner;
    }
    ReduceNode n=new ReduceNode(this,pred,input,gp,lp);
    n.input.setShipStrategy(ss);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().getPreservedAfterContract(getOutputContract());
    n.getLocalProperties().getPreservedAfterContract(getOutputContract());
    estimator.costOperator(n);
    outputPlans.add(n);
  }
  if (outputPlans.isEmpty()) {
    throw new CompilerException("Could not create a valid plan for the reduce contract '" + getPactContract().getName() + "'. The compiler hints specified incompatible shipping strategies.");
  }
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}
