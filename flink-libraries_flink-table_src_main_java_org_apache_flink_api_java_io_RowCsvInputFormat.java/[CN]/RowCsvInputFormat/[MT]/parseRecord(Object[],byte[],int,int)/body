{
  boolean[] fieldIncluded=this.fieldIncluded;
  int startPos=offset;
  final int limit=offset + numBytes;
  for (int field=0, output=0; field < fieldIncluded.length; field++) {
    if (startPos >= limit) {
      if (isLenient()) {
        return false;
      }
 else {
        throw new ParseException("Row too short: " + new String(bytes,offset,numBytes));
      }
    }
    if (fieldIncluded[field]) {
      @SuppressWarnings("unchecked") FieldParser<Object> parser=(FieldParser<Object>)this.getFieldParsers()[output];
      int latestValidPos=startPos;
      startPos=parser.resetErrorStateAndParse(bytes,startPos,limit,this.getFieldDelimiter(),holders[output]);
      if (!isLenient() && parser.getErrorState() != ParseErrorState.NONE) {
        if (parser.getErrorState() != ParseErrorState.EMPTY_STRING) {
          throw new ParseException(String.format("Parsing error for column %s of row '%s' originated by %s: %s.",field,new String(bytes,offset,numBytes),parser.getClass().getSimpleName(),parser.getErrorState()));
        }
      }
      holders[output]=parser.getLastResult();
      if (startPos < 0) {
        holders[output]=null;
        startPos=skipFields(bytes,latestValidPos,limit,this.getFieldDelimiter());
      }
      output++;
    }
 else {
      startPos=skipFields(bytes,startPos,limit,this.getFieldDelimiter());
    }
  }
  return true;
}
