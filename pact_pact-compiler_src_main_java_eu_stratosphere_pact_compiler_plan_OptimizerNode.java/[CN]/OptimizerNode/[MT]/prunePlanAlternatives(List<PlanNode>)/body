{
  if (this.openBranches == null || this.openBranches.isEmpty()) {
    prunePlanAlternativesWithCommonBranching(plans);
  }
 else {
    final OptimizerNode branchDeterminer=openBranches.get(this.openBranches.size() - 1).getBranchingNode();
    Comparator<PlanNode> sorter=new Comparator<PlanNode>(){
      @Override public int compare(      PlanNode o1,      PlanNode o2){
        PlanNode n1=o1.getCandidateAtBranchPoint(branchDeterminer);
        PlanNode n2=o2.getCandidateAtBranchPoint(branchDeterminer);
        return System.identityHashCode(n1) - System.identityHashCode(n2);
      }
    }
;
    Collections.sort(plans,sorter);
    List<PlanNode> result=new ArrayList<PlanNode>();
    List<PlanNode> turn=new ArrayList<PlanNode>();
    while (!plans.isEmpty()) {
      turn.clear();
      PlanNode determiner=plans.remove(plans.size() - 1);
      turn.add(determiner);
      PlanNode determinerChoice=determiner.getCandidateAtBranchPoint(branchDeterminer);
      for (int k=plans.size() - 1; k >= 0; k--) {
        PlanNode toCheck=plans.get(k);
        PlanNode checkerChoice=toCheck.getCandidateAtBranchPoint(branchDeterminer);
        if (checkerChoice == determinerChoice) {
          plans.remove(k);
          turn.add(toCheck);
        }
 else {
          break;
        }
      }
      if (turn.size() > 1) {
        prunePlanAlternativesWithCommonBranching(turn);
      }
 else {
        throw new CompilerException();
      }
      result.addAll(turn);
    }
    plans.clear();
    plans.addAll(result);
  }
}
