{
  if (plans.isEmpty()) {
    throw new CompilerException("No plan meeting the requirements could be created.");
  }
  if (plans.size() == 1) {
    return;
  }
  final RequestedGlobalProperties[] gps=(RequestedGlobalProperties[])this.intProps.getGlobalProperties().toArray(new RequestedGlobalProperties[plans.size()]);
  final RequestedLocalProperties[] lps=(RequestedLocalProperties[])this.intProps.getLocalProperties().toArray(new RequestedLocalProperties[plans.size()]);
  final PlanNode[][] toKeep=new PlanNode[gps.length][];
  PlanNode cheapest=null;
  for (  PlanNode candidate : plans) {
    if (cheapest == null || (cheapest.getCumulativeCosts().compareTo(candidate.getCumulativeCosts()) > 0)) {
      cheapest=candidate;
    }
    for (int i=0; i < gps.length; i++) {
      if (gps[i].isMetBy(candidate.getGlobalProperties())) {
        final PlanNode[] localMatches;
        if (toKeep[i] == null) {
          localMatches=new PlanNode[lps.length];
          toKeep[i]=localMatches;
        }
 else {
          localMatches=toKeep[i];
        }
        for (int k=0; k < lps.length; k++) {
          if (lps[k].isMetBy(candidate.getLocalProperties())) {
            final PlanNode previous=localMatches[k];
            if (previous == null || previous.getCumulativeCosts().compareTo(candidate.getCumulativeCosts()) > 0) {
              localMatches[k]=candidate;
            }
          }
        }
      }
    }
  }
  plans.clear();
  if (cheapest != null) {
    plans.add(cheapest);
    cheapest.setPruningMarker();
  }
  for (int i=0; i < toKeep.length; i++) {
    if (toKeep[i] != null) {
      final PlanNode[] localMatches=toKeep[i];
      for (int k=0; k < localMatches.length; k++) {
        final PlanNode n=localMatches[k];
        if (n != null && !n.isPruneMarkerSet()) {
          n.setPruningMarker();
          plans.add(n);
        }
      }
    }
  }
}
