{
  final Class<? extends Stub> stubClass=this.getStubClass();
  if (stubClass == null)   throw new IllegalStateException("no implementing stub found");
  final Class<? extends Contract> contractClass=ContractUtil.getContractClass(stubClass);
  if (contractClass == null)   throw new IllegalStateException("no associated contract found");
  try {
    if (contractClass == ReduceContract.class) {
      int[] keyIndices=getKeyIndices(globalSchema,this.keyExpressions);
      return new ReduceContract((Class<? extends ReduceStub>)stubClass,getKeyClasses(globalSchema,keyIndices),keyIndices,this.toString());
    }
 else     if (contractClass == CoGroupContract.class) {
      int[] keyIndices1=getKeyIndices(globalSchema,getKeyExpressionForInput(0));
      int[] keyIndices2=getKeyIndices(globalSchema,getKeyExpressionForInput(1));
      return new CoGroupContract((Class<? extends CoGroupStub>)stubClass,getCommonKeyClasses(globalSchema,keyIndices1,keyIndices2),keyIndices1,keyIndices2,this.toString());
    }
 else     if (contractClass == MatchContract.class) {
      int[] keyIndices1=getKeyIndices(globalSchema,getKeyExpressionForInput(0));
      int[] keyIndices2=getKeyIndices(globalSchema,getKeyExpressionForInput(1));
      return new MatchContract((Class<? extends MatchStub>)stubClass,getCommonKeyClasses(globalSchema,keyIndices1,keyIndices2),keyIndices1,keyIndices2,this.toString());
    }
    return ReflectUtil.newInstance(contractClass,stubClass,this.toString());
  }
 catch (  final Exception e) {
    throw new IllegalStateException("Cannot create contract from stub " + stubClass,e);
  }
}
