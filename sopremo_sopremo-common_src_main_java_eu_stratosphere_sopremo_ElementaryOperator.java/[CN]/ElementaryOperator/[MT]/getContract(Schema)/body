{
  final Class<? extends Stub> stubClass=this.getStubClass();
  if (stubClass == null)   throw new IllegalStateException("no implementing stub found");
  final Class<? extends Contract> contractClass=ContractUtil.getContractClass(stubClass);
  if (contractClass == null)   throw new IllegalStateException("no associated contract found");
  try {
    if (contractClass == ReduceContract.class) {
      int[] keyIndices=this.getKeyIndices(globalSchema,this.getKeyExpressions(0));
      ReduceContract.Builder builder=new ReduceContract.Builder((Class<? extends ReduceStub>)stubClass);
      builder.name(this.toString());
      PactBuilderUtil.addKeys(builder,this.getKeyClasses(globalSchema,keyIndices),keyIndices);
      return builder.build();
    }
 else     if (contractClass == CoGroupContract.class) {
      int[] keyIndices1=this.getKeyIndices(globalSchema,this.getKeyExpressions(0));
      int[] keyIndices2=this.getKeyIndices(globalSchema,this.getKeyExpressions(1));
      CoGroupContract.Builder builder=new CoGroupContract.Builder((Class<? extends CoGroupStub>)stubClass);
      builder.name(this.toString());
      PactBuilderUtil.addKeys(builder,this.getCommonKeyClasses(globalSchema,keyIndices1,keyIndices2),keyIndices1,keyIndices2);
      return builder.build();
    }
 else     if (contractClass == MatchContract.class) {
      int[] keyIndices1=this.getKeyIndices(globalSchema,this.getKeyExpressions(0));
      int[] keyIndices2=this.getKeyIndices(globalSchema,this.getKeyExpressions(1));
      MatchContract.Builder builder=new MatchContract.Builder((Class<? extends MatchStub>)stubClass);
      builder.name(this.toString());
      PactBuilderUtil.addKeys(builder,this.getCommonKeyClasses(globalSchema,keyIndices1,keyIndices2),keyIndices1,keyIndices2);
      return builder.build();
    }
    return ReflectUtil.newInstance(contractClass,stubClass,this.toString());
  }
 catch (  final Exception e) {
    throw new IllegalStateException("Cannot create contract from stub " + stubClass,e);
  }
}
