{
  final KeyValuePair<K,V> actualPair=inputFileIterator.next();
  final TaskConfig config=new TaskConfig(GlobalConfiguration.getConfiguration());
  this.assignMemory(config,10);
  final long totalMemory=config.getMemorySize();
  final int numFileHandles=config.getNumFilehandles();
  final Comparator<K> keyComparator=new Comparator<K>(){
    @Override public int compare(    final K k1,    final K k2){
      return k1.compareTo(k2);
    }
  }
;
  try {
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>((Class<K>)actualPair.getKey().getClass());
    final SerializationFactory<V> valSerialization=new WritableSerializationFactory<V>((Class<V>)actualPair.getValue().getClass());
    final StringBuilder testName=new StringBuilder();
    StackTraceElement[] stackTrace=new Throwable().getStackTrace();
    for (int index=stackTrace.length - 1; index > 0; index--)     if (stackTrace[index].getClassName().contains("Test"))     testName.append(stackTrace[index].toString());
    AbstractTask parentTask=new ReduceTask(){
      @Override public String toString(){
        return "TestPair Sorter " + testName;
      }
    }
;
    @SuppressWarnings("rawtypes") final UnilateralSortMerger<K,V> sortMerger=new UnilateralSortMerger<K,V>(MockTaskManager.INSTANCE.getMemoryManager(),MockTaskManager.INSTANCE.getIoManager(),totalMemory,numFileHandles,keySerialization,valSerialization,keyComparator,new TestPairsReader(inputFileIterator,actualPair),parentTask,0.7f);
    this.closableManager.add(sortMerger);
    return sortMerger.getIterator();
  }
 catch (  final MemoryAllocationException mae) {
    throw new RuntimeException("MemoryManager is not able to provide the required amount of memory for ReduceTask",mae);
  }
catch (  final IOException ioe) {
    throw new RuntimeException("IOException caught when obtaining SortMerger for ReduceTask",ioe);
  }
catch (  final InterruptedException iex) {
    throw new RuntimeException("InterruptedException caught when obtaining iterator over sorted data.",iex);
  }
}
