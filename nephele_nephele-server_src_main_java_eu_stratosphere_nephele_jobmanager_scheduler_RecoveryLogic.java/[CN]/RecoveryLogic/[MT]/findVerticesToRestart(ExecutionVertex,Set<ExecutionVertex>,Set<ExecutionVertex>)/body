{
  final Queue<ExecutionVertex> verticesToTest=new ArrayDeque<ExecutionVertex>();
  final Set<ExecutionVertex> visited=new HashSet<ExecutionVertex>();
  verticesToTest.add(failedVertex);
  while (!verticesToTest.isEmpty()) {
    final ExecutionVertex vertex=verticesToTest.poll();
    for (int j=0; j < vertex.getNumberOfPredecessors(); j++) {
      final ExecutionVertex predecessor=vertex.getPredecessor(j);
      if (hasInstanceAssigned(predecessor)) {
        if (predecessor.getCheckpointState() == CheckpointState.UNDECIDED) {
          final TaskCheckpointResult result=predecessor.requestCheckpointDecision();
          if (result.getReturnCode() != ReturnCode.SUCCESS) {
            predecessor.updateCheckpointState(CheckpointState.NONE);
          }
 else {
            try {
              predecessor.waitForCheckpointStateChange(CheckpointState.UNDECIDED,100L);
            }
 catch (            InterruptedException e) {
            }
            if (predecessor.getCheckpointState() == CheckpointState.UNDECIDED) {
              predecessor.updateCheckpointState(CheckpointState.NONE);
            }
          }
        }
        final CheckpointState checkpointState=predecessor.getCheckpointState();
switch (checkpointState) {
case NONE:
          verticesToBeCanceled.add(predecessor);
        break;
case COMPLETE:
      verticesToBeCanceled.add(predecessor);
    continue;
case PARTIAL:
  checkpointsToBeReplayed.add(predecessor);
continue;
default :
LOG.error(predecessor + " has unexpected checkpoint state " + checkpointState);
}
}
if (!visited.contains(predecessor)) {
verticesToTest.add(predecessor);
}
}
visited.add(vertex);
}
}
