{
  final Queue<ExecutionVertex> verticesToTest=new ArrayDeque<ExecutionVertex>();
  final Set<ExecutionVertex> visited=new HashSet<ExecutionVertex>();
  verticesToTest.add(failedVertex);
  while (!verticesToTest.isEmpty()) {
    final ExecutionVertex vertex=verticesToTest.poll();
    for (int j=0; j < vertex.getNumberOfPredecessors(); j++) {
      final ExecutionVertex predecessor=vertex.getPredecessor(j);
      if (hasInstanceAssigned(predecessor)) {
        if (predecessor.getCheckpointState() == CheckpointState.UNDECIDED) {
          final TaskCheckpointResult result=predecessor.requestCheckpointDecision();
          if (result.getReturnCode() != ReturnCode.SUCCESS) {
            predecessor.updateCheckpointState(CheckpointState.NONE);
          }
 else {
            try {
              predecessor.waitForCheckpointStateChange(CheckpointState.UNDECIDED,100L);
            }
 catch (            InterruptedException e) {
            }
            if (predecessor.getCheckpointState() == CheckpointState.UNDECIDED) {
              predecessor.updateCheckpointState(CheckpointState.NONE);
            }
          }
        }
        if (predecessor.getCheckpointState() == CheckpointState.NONE) {
          verticesToBeCanceled.add(predecessor);
        }
 else {
          checkpointsToBeReplayed.add(predecessor);
          continue;
        }
      }
      if (!visited.contains(predecessor)) {
        verticesToTest.add(predecessor);
      }
    }
    visited.add(vertex);
  }
}
