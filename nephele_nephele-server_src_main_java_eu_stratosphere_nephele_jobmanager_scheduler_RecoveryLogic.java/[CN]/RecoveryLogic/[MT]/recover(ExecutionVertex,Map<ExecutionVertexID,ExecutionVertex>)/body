{
  if (failedVertex.getExecutionState() != ExecutionState.FAILED) {
    LOG.error("Vertex " + failedVertex + " is requested to be recovered, but is not failed");
    return false;
  }
  LOG.info("Starting recovery for failed vertex " + failedVertex);
  final Set<ExecutionVertex> verticesToBeCanceled=new HashSet<ExecutionVertex>();
  final Map<AbstractInstance,List<ExecutionVertexID>> checkpointsToBeReplayed=new HashMap<AbstractInstance,List<ExecutionVertexID>>();
  findVerticesToRestart(failedVertex,verticesToBeCanceled,checkpointsToBeReplayed);
  final Iterator<ExecutionVertex> cancelIterator=verticesToBeCanceled.iterator();
  while (cancelIterator.hasNext()) {
    final ExecutionVertex vertex=cancelIterator.next();
    LOG.info(vertex + " is canceled by recovery logic");
    final TaskCancelResult cancelResult=vertex.cancelTask();
    verticesToBeRestarted.put(vertex.getID(),vertex);
    if (cancelResult.getReturnCode() != ReturnCode.SUCCESS) {
      verticesToBeRestarted.remove(vertex.getID());
      LOG.error(cancelResult.getDescription());
      return false;
    }
  }
  final Iterator<Map.Entry<AbstractInstance,List<ExecutionVertexID>>> checkpointIterator=checkpointsToBeReplayed.entrySet().iterator();
  while (checkpointIterator.hasNext()) {
    final Map.Entry<AbstractInstance,List<ExecutionVertexID>> entry=checkpointIterator.next();
    final AbstractInstance instance=entry.getKey();
    try {
      final List<CheckpointReplayResult> results=instance.replayCheckpoints(entry.getValue());
      for (      final CheckpointReplayResult result : results) {
        if (result.getReturnCode() != ReturnCode.SUCCESS) {
          LOG.error(result.getDescription());
          return false;
        }
      }
    }
 catch (    IOException ioe) {
      LOG.error(StringUtils.stringifyException(ioe));
      return false;
    }
  }
  failedVertex.updateExecutionState(ExecutionState.SCHEDULED);
  return true;
}
