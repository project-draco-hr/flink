{
  if (failedVertex.getExecutionState() != ExecutionState.FAILED) {
    LOG.error("Vertex " + failedVertex + " is requested to be recovered, but is not failed");
    return false;
  }
  LOG.info("Starting recovery for failed vertex " + failedVertex);
  final Set<ExecutionVertex> verticesToBeCanceled=new HashSet<ExecutionVertex>();
  final Set<ExecutionVertex> checkpointsToBeReplayed=new HashSet<ExecutionVertex>();
  findVerticesToRestart(failedVertex,verticesToBeCanceled,checkpointsToBeReplayed);
  final Iterator<ExecutionVertex> cancelIterator=verticesToBeCanceled.iterator();
  while (cancelIterator.hasNext()) {
    final ExecutionVertex vertex=cancelIterator.next();
    final ExecutionState state=vertex.getExecutionState();
    System.out.println("Canceling " + vertex + " with state "+ vertex.getExecutionState());
    if (state == ExecutionState.FINISHED) {
      restart(vertex);
    }
 else {
      LOG.info(vertex + " is canceled by recovery logic");
      final TaskCancelResult cancelResult=vertex.cancelTask();
      verticesToBeRestarted.put(vertex.getID(),vertex);
      if (cancelResult.getReturnCode() != ReturnCode.SUCCESS) {
        verticesToBeRestarted.remove(vertex.getID());
        if (cancelResult.getReturnCode() == ReturnCode.TASK_NOT_FOUND) {
          restart(vertex);
        }
 else {
          LOG.error(cancelResult.getDescription());
          return false;
        }
      }
    }
  }
  if (!invalidateReceiverLookupCaches(failedVertex,verticesToBeCanceled)) {
    return false;
  }
  final Iterator<ExecutionVertex> checkpointIterator=checkpointsToBeReplayed.iterator();
  while (checkpointIterator.hasNext()) {
    checkpointIterator.next().updateExecutionState(ExecutionState.ASSIGNED);
  }
  restart(failedVertex);
  return true;
}
