{
  if (failedVertex.getExecutionState() != ExecutionState.FAILED) {
    LOG.error("Vertex " + failedVertex + " is requested to be recovered, but is not failed");
    return false;
  }
  LOG.info("Starting recovery for failed vertex " + failedVertex);
  final Set<ExecutionVertex> verticesToBeCanceled=new HashSet<ExecutionVertex>();
  final Map<AbstractInstance,Set<ExecutionVertexID>> checkpointsToBeReplayed=new HashMap<AbstractInstance,Set<ExecutionVertexID>>();
  findVerticesToRestart(failedVertex,verticesToBeCanceled,checkpointsToBeReplayed);
  final Iterator<ExecutionVertex> cancelIterator=verticesToBeCanceled.iterator();
  while (cancelIterator.hasNext()) {
    final ExecutionVertex vertex=cancelIterator.next();
    LOG.info(vertex + " is canceled by recovery logic");
    final TaskCancelResult cancelResult=vertex.cancelTask();
    verticesToBeRestarted.put(vertex.getID(),vertex);
    if (cancelResult.getReturnCode() != ReturnCode.SUCCESS) {
      verticesToBeRestarted.remove(vertex.getID());
      LOG.error(cancelResult.getDescription());
      return false;
    }
  }
  if (!invalidateReceiverLookupCaches(failedVertex,verticesToBeCanceled)) {
    return false;
  }
  final Iterator<Map.Entry<AbstractInstance,Set<ExecutionVertexID>>> checkpointIterator=checkpointsToBeReplayed.entrySet().iterator();
  while (checkpointIterator.hasNext()) {
    final Map.Entry<AbstractInstance,Set<ExecutionVertexID>> entry=checkpointIterator.next();
    final AbstractInstance instance=entry.getKey();
    try {
      final List<CheckpointReplayResult> results=instance.replayCheckpoints(toListOfReplayRequests(failedVertex.getExecutionGraph(),entry.getValue()));
      for (      final CheckpointReplayResult result : results) {
        if (result.getReturnCode() != ReturnCode.SUCCESS) {
          LOG.error(result.getDescription());
          return false;
        }
      }
    }
 catch (    IOException ioe) {
      LOG.error(StringUtils.stringifyException(ioe));
      return false;
    }
  }
  if (failedVertex.getAllocatedResource().getInstance() instanceof DummyInstance) {
    failedVertex.updateExecutionState(ExecutionState.CREATED);
  }
 else {
    failedVertex.updateExecutionState(ExecutionState.ASSIGNED);
  }
  return true;
}
