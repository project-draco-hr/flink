{
  final Queue<ExecutionVertex> verticesToTest=new ArrayDeque<ExecutionVertex>();
  final Set<ExecutionVertex> visited=new HashSet<ExecutionVertex>();
  verticesToTest.add(failedVertex);
  while (!verticesToTest.isEmpty()) {
    final ExecutionVertex vertex=verticesToTest.poll();
    if (!vertex.getID().equals(failedVertex.getID())) {
      verticesToBeCanceled.add(vertex);
    }
    for (int j=0; j < vertex.getNumberOfPredecessors(); j++) {
      final ExecutionVertex predecessor=vertex.getPredecessor(j);
      if (predecessor.getCheckpointState() != CheckpointState.PARTIAL && predecessor.getCheckpointState() != CheckpointState.COMPLETE) {
        verticesToBeCanceled.add(predecessor);
        if (!visited.contains(predecessor)) {
          verticesToTest.add(predecessor);
        }
      }
 else {
        final AbstractInstance instance=predecessor.getAllocatedResource().getInstance();
        Set<ExecutionVertexID> checkpointIDs=checkpointsToBeReplayed.get(instance);
        if (checkpointIDs == null) {
          checkpointIDs=new HashSet<ExecutionVertexID>();
          checkpointsToBeReplayed.put(instance,checkpointIDs);
        }
        checkpointIDs.add(predecessor.getID());
      }
    }
    visited.add(vertex);
  }
}
