{
  LOG.info("Starting parallel channels test.");
  final Random rnd=new Random(SEED);
  final AbstractInvokable memOwner=new DefaultMemoryManagerTest.DummyInvokable();
  final int minSegmentSize=4 * 1024;
  final int maxSegmentSize=SEGMENT_SIZE / NUM_CHANNELS;
  Channel.ID[] ids=new Channel.ID[NUM_CHANNELS];
  Writer[] writers=new Writer[NUM_CHANNELS];
  Reader[] readers=new Reader[NUM_CHANNELS];
  int[] writingCounters=new int[NUM_CHANNELS];
  int[] readingCounters=new int[NUM_CHANNELS];
  for (int i=0; i < NUM_CHANNELS; i++) {
    ids[i]=this.ioManager.createChannel();
    final int segmentSize=rnd.nextInt(maxSegmentSize - minSegmentSize) + minSegmentSize;
    Collection<MemorySegment> memSegs=memoryManager.allocate(memOwner,rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2,segmentSize);
    writers[i]=ioManager.createChannelWriter(ids[i],memSegs);
  }
  Value val=new Value();
  int nextLogCount=0;
  float nextLogFraction=0.0f;
  LOG.info("Writing to channels...");
  for (int i=0; i < NUMBERS_TO_BE_WRITTEN; i++) {
    if (i == nextLogCount) {
      LOG.info("... " + (int)(nextLogFraction * 100) + "% done.");
      nextLogFraction+=0.05;
      nextLogCount=(int)(nextLogFraction * NUMBERS_TO_BE_WRITTEN);
    }
    int channel=skewedSample(rnd,NUM_CHANNELS - 1);
    val.value=String.valueOf(writingCounters[channel]++);
    writers[channel].write(val);
  }
  LOG.info("Writing done, flushing contents...");
  for (int i=0; i < NUM_CHANNELS; i++) {
    memoryManager.release(writers[i].close());
  }
  writers=null;
  LOG.info("Reading channels sequentially...");
  for (int i=0; i < NUM_CHANNELS; i++) {
    final int segmentSize=rnd.nextInt(maxSegmentSize - minSegmentSize) + minSegmentSize;
    Collection<MemorySegment> memSegs=memoryManager.allocate(memOwner,rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2,segmentSize);
    LOG.info("Reading channel " + i + "/"+ NUM_CHANNELS+ '.');
    Reader reader=ioManager.createChannelReader(ids[i],memSegs,false);
    int nextVal=0;
    while (reader.read(val)) {
      int intValue=0;
      try {
        intValue=Integer.parseInt(val.value);
      }
 catch (      NumberFormatException nfex) {
        Assert.fail("Invalid value read from reader. Valid decimal number expected.");
      }
      Assert.assertEquals("Written and read values do not match during sequential read.",nextVal,intValue);
      nextVal++;
    }
    Assert.assertEquals("NUmber of written numbers differs from number of read numbers.",writingCounters[i],nextVal);
    memoryManager.release(reader.close());
  }
  LOG.info("Sequential reading done.");
  LOG.info("Reading channels randomly...");
  for (int i=0; i < NUM_CHANNELS; i++) {
    final int segmentSize=rnd.nextInt(maxSegmentSize - minSegmentSize) + minSegmentSize;
    Collection<MemorySegment> memSegs=memoryManager.allocate(memOwner,rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2,segmentSize);
    readers[i]=ioManager.createChannelReader(ids[i],memSegs,true);
  }
  nextLogCount=0;
  nextLogFraction=0.0f;
  for (int i=0; i < NUMBERS_TO_BE_WRITTEN; i++) {
    if (i == nextLogCount) {
      LOG.info("... " + (int)(nextLogFraction * 100) + "% done.");
      nextLogFraction+=0.05;
      nextLogCount=(int)(nextLogFraction * NUMBERS_TO_BE_WRITTEN);
    }
    int channel=skewedSample(rnd,NUM_CHANNELS - 1);
    if (!readers[channel].read(val)) {
      continue;
    }
    int intValue=0;
    try {
      intValue=Integer.parseInt(val.value);
    }
 catch (    NumberFormatException nfex) {
      Assert.fail("Invalid value read from reader. Valid decimal number expected.");
    }
    Assert.assertEquals("Written and read values do not match.",readingCounters[channel]++,intValue);
  }
  LOG.info("Random reading done.");
  for (int i=0; i < NUM_CHANNELS; i++) {
    memoryManager.release(readers[i].close());
  }
  readers=null;
  for (int i=0; i < NUM_CHANNELS; i++) {
    File f=new File(ids[i].getPath());
    Assert.assertFalse("Channel file has not been deleted.",f.exists());
  }
}
