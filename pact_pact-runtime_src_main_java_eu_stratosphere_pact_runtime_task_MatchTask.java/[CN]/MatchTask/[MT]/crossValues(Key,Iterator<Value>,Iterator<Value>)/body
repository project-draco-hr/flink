{
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    this.v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (!this.taskCanceled && v2HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!this.taskCanceled && !v2HasNext) {
    this.v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v2=this.v2Serialization.newInstance();
      this.v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    SpillingResettableIterator<Value> v1ResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,(long)(this.availableMemory * MEMORY_SHARE_RATIO),v1Deserializer,this);
      v1ResettableIterator.open();
      this.v2Copier.setCopy(firstV2);
      while (!this.taskCanceled && v1ResettableIterator.hasNext()) {
        key=this.keySerialization.newInstance();
        this.keyCopier.getCopy(key);
        v2=this.v2Serialization.newInstance();
        this.v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      SerializationCopier<Value>[] valBuffer=new SerializationCopier[VALUE_BUFFER_SIZE];
      for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
        valBuffer[i]=new SerializationCopier<Value>();
      }
      while (!this.taskCanceled && values2.hasNext()) {
        int valBufferCnt=0;
        while (!this.taskCanceled && values2.hasNext() && valBufferCnt < VALUE_BUFFER_SIZE) {
          valBuffer[valBufferCnt++].setCopy(values2.next());
        }
        while (!this.taskCanceled && v1ResettableIterator.hasNext()) {
          v1=v1ResettableIterator.next();
          for (int i=0; i < valBufferCnt; i++) {
            key=this.keySerialization.newInstance();
            this.keyCopier.getCopy(key);
            v2=this.v2Serialization.newInstance();
            valBuffer[i].getCopy(v2);
            matchStub.match(key,v1,v2,output);
            if (i < valBufferCnt - 1)             v1=v1ResettableIterator.repeatLast();
          }
        }
        v1ResettableIterator.reset();
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (v1ResettableIterator != null) {
        v1ResettableIterator.close();
      }
    }
  }
}
