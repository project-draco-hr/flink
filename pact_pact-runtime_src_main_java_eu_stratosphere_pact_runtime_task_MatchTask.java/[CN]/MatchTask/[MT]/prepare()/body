{
  final long availableMemory=this.config.getMemorySize();
  final int maxFileHandles=this.config.getNumFilehandles();
  final float spillThreshold=this.config.getSortSpillingTreshold();
  final LocalStrategy ls=this.config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case SORT_BOTH_MERGE:
    strategyMinMem=MIN_REQUIRED_MEMORY * 2;
  break;
case SORT_FIRST_MERGE:
case SORT_SECOND_MERGE:
case MERGE:
case HYBRIDHASH_FIRST:
case HYBRIDHASH_SECOND:
case MMHASH_FIRST:
case MMHASH_SECOND:
strategyMinMem=MIN_REQUIRED_MEMORY;
break;
}
if (availableMemory < strategyMinMem) {
throw new Exception("The Match task was initialized with too little memory for local strategy " + ls.name() + ": "+ availableMemory+ " bytes. Required is at least "+ strategyMinMem+ " bytes.");
}
final int[] keyPositions1=this.config.getLocalStrategyKeyPositions(0);
final int[] keyPositions2=this.config.getLocalStrategyKeyPositions(1);
final Class<? extends Key>[] keyClasses=this.config.getLocalStrategyKeyClasses(this.userCodeClassLoader);
if (keyPositions1 == null || keyPositions2 == null || keyClasses == null) {
throw new Exception("The key positions and types are not specified for the MatchTask.");
}
if (keyPositions1.length != keyPositions2.length || keyPositions2.length != keyClasses.length) {
throw new Exception("The number of key positions and types does not match in the configuration");
}
final MemoryManager memoryManager=getEnvironment().getMemoryManager();
final IOManager ioManager=getEnvironment().getIOManager();
switch (ls) {
case SORT_BOTH_MERGE:
case SORT_FIRST_MERGE:
case SORT_SECOND_MERGE:
case MERGE:
this.matchIterator=new SortMergeMatchIterator(memoryManager,ioManager,this.inputs[0],this.inputs[1],keyPositions1,keyPositions2,keyClasses,availableMemory,maxFileHandles,spillThreshold,ls,this);
break;
case HYBRIDHASH_FIRST:
this.matchIterator=new BuildFirstHashMatchIterator(this.inputs[0],this.inputs[1],keyPositions1,keyPositions2,keyClasses,memoryManager,ioManager,this,availableMemory);
break;
case HYBRIDHASH_SECOND:
this.matchIterator=new BuildSecondHashMatchIterator(this.inputs[0],this.inputs[1],keyPositions2,keyPositions1,keyClasses,memoryManager,ioManager,this,availableMemory);
break;
default :
throw new Exception("Unsupported local strategy for MatchTask: " + ls.name());
}
this.matchIterator.open();
if (LOG.isDebugEnabled()) LOG.debug(getLogString("Match task iterator ready."));
}
