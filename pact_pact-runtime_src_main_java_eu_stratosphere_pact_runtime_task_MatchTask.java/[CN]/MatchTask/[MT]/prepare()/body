{
  final long availableMemory=this.config.getMemorySize();
  final int maxFileHandles=this.config.getNumFilehandles();
  final float spillThreshold=this.config.getSortSpillingTreshold();
  final LocalStrategy ls=this.config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case SORT_BOTH_MERGE:
    strategyMinMem=MIN_REQUIRED_MEMORY * 2;
  break;
case SORT_FIRST_MERGE:
case SORT_SECOND_MERGE:
case MERGE:
case HYBRIDHASH_FIRST:
case HYBRIDHASH_SECOND:
case MMHASH_FIRST:
case MMHASH_SECOND:
strategyMinMem=MIN_REQUIRED_MEMORY;
break;
}
if (availableMemory < strategyMinMem) {
throw new Exception("The Match task was initialized with too little memory for local strategy " + ls.name() + ": "+ availableMemory+ " bytes. Required is at least "+ strategyMinMem+ " bytes.");
}
final MutableObjectIterator<IT1> in1=getInput(0);
final MutableObjectIterator<IT2> in2=getInput(1);
final TypeSerializer<IT1> serializer1=getInputSerializer(0);
final TypeSerializer<IT2> serializer2=getInputSerializer(1);
final TypeComparator<IT1> comparator1=getInputComparator(0);
final TypeComparator<IT2> comparator2=getInputComparator(1);
final TypePairComparatorFactory<IT1,IT2> pairComparatorFactory;
try {
final Class<? extends TypePairComparatorFactory<IT1,IT2>> factoryClass=this.config.getPairComparatorFactory(this.userCodeClassLoader);
if (factoryClass == null) {
@SuppressWarnings("unchecked") TypePairComparatorFactory<IT1,IT2> pactRecordFactory=(TypePairComparatorFactory<IT1,IT2>)PactRecordPairComparatorFactory.get();
pairComparatorFactory=pactRecordFactory;
}
 else {
@SuppressWarnings("unchecked") final Class<TypePairComparatorFactory<IT1,IT2>> clazz=(Class<TypePairComparatorFactory<IT1,IT2>>)(Class<?>)TypePairComparatorFactory.class;
pairComparatorFactory=InstantiationUtil.instantiate(factoryClass,clazz);
}
}
 catch (ClassNotFoundException cnfex) {
throw new Exception("The class registered as TypePairComparatorFactory cloud not be loaded.",cnfex);
}
final MemoryManager memoryManager=getEnvironment().getMemoryManager();
final IOManager ioManager=getEnvironment().getIOManager();
switch (ls) {
case SORT_BOTH_MERGE:
case SORT_FIRST_MERGE:
case SORT_SECOND_MERGE:
case MERGE:
this.matchIterator=new SortMergeMatchIterator<IT1,IT2,OT>(in1,in2,serializer1,comparator1,serializer2,comparator2,pairComparatorFactory.createComparator12(comparator1,comparator2),memoryManager,ioManager,availableMemory,maxFileHandles,spillThreshold,ls,this);
break;
case HYBRIDHASH_FIRST:
this.matchIterator=new BuildFirstHashMatchIterator<IT1,IT2,OT>(in1,in2,serializer1,comparator1,serializer2,comparator2,pairComparatorFactory.createComparator21(comparator1,comparator2),memoryManager,ioManager,this,availableMemory);
break;
case HYBRIDHASH_SECOND:
this.matchIterator=new BuildSecondHashMatchIterator<IT1,IT2,OT>(in1,in2,serializer1,comparator1,serializer2,comparator2,pairComparatorFactory.createComparator12(comparator1,comparator2),memoryManager,ioManager,this,availableMemory);
break;
default :
throw new Exception("Unsupported local strategy for MatchTask: " + ls.name());
}
this.matchIterator.open();
if (LOG.isDebugEnabled()) LOG.debug(getLogString("Match task iterator ready."));
}
