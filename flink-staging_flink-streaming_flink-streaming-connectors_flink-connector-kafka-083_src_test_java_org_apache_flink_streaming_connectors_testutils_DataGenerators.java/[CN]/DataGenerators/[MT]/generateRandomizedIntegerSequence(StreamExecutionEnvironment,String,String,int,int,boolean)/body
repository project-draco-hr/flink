{
  env.setParallelism(numPartitions);
  env.getConfig().disableSysoutLogging();
  env.setNumberOfExecutionRetries(0);
  DataStream<Integer> stream=env.addSource(new RichParallelSourceFunction<Integer>(){
    private volatile boolean running=true;
    @Override public void run(    SourceContext<Integer> ctx){
      int[] elements=new int[numElements];
      for (int i=0, val=getRuntimeContext().getIndexOfThisSubtask(); i < numElements; i++, val+=getRuntimeContext().getNumberOfParallelSubtasks()) {
        elements[i]=val;
      }
      if (randomizeOrder) {
        Random rnd=new Random();
        for (int i=0; i < elements.length; i++) {
          int otherPos=rnd.nextInt(elements.length);
          int tmp=elements[i];
          elements[i]=elements[otherPos];
          elements[otherPos]=tmp;
        }
      }
      int pos=0;
      while (running && pos < elements.length) {
        ctx.collect(elements[pos++]);
      }
    }
    @Override public void cancel(){
      running=false;
    }
  }
);
  stream.rebalance().addSink(new KafkaSink<>(brokerConnection,topic,new TypeInformationSerializationSchema<>(BasicTypeInfo.INT_TYPE_INFO,env.getConfig()),new SerializableKafkaPartitioner(){
    @Override public int partition(    Object key,    int numPartitions){
      return ((Integer)key) % numPartitions;
    }
  }
));
  env.execute("Scrambles int sequence generator");
}
