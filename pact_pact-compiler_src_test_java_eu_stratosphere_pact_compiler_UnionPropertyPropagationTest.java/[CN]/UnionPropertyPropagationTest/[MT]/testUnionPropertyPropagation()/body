{
  FileDataSource sourceA=new FileDataSource(DummyInputFormat.class,IN_FILE);
  FileDataSource sourceB=new FileDataSource(DummyInputFormat.class,IN_FILE);
  ReduceContract redA=new ReduceContract.Builder(IdentityReduce.class,PactInteger.class,0).input(sourceA).build();
  ReduceContract redB=new ReduceContract.Builder(IdentityReduce.class,PactInteger.class,0).input(sourceB).build();
  ReduceContract globalRed=new ReduceContract.Builder(IdentityReduce.class,PactInteger.class,0).build();
  globalRed.addInput(redA);
  globalRed.addInput(redB);
  FileDataSink sink=new FileDataSink(DummyOutputFormat.class,OUT_FILE,globalRed);
  Plan plan=new Plan(sink,"Union Property Propagation");
  OptimizedPlan oPlan=compileNoStats(plan);
  NepheleJobGraphGenerator jobGen=new NepheleJobGraphGenerator();
  jobGen.compileJobGraph(oPlan);
  oPlan.accept(new Visitor<PlanNode>(){
    @Override public boolean preVisit(    PlanNode visitable){
      if (visitable instanceof SingleInputPlanNode && visitable.getPactContract() instanceof ReduceContract) {
        for (Iterator<Channel> inputs=visitable.getInputs(); inputs.hasNext(); ) {
          final Channel inConn=inputs.next();
          Assert.assertTrue("Reduce should just forward the input if it is already partitioned",inConn.getShipStrategy() == ShipStrategyType.FORWARD);
        }
        return false;
      }
      return true;
    }
    @Override public void postVisit(    PlanNode visitable){
    }
  }
);
}
