{
  FileDataSource sourceA=new FileDataSource(DummyInputFormat.class,IN_FILE);
  FileDataSource sourceB=new FileDataSource(DummyInputFormat.class,IN_FILE);
  ReduceContract redA=new ReduceContract(IdentityReduce.class,PactInteger.class,0,sourceA);
  ReduceContract redB=new ReduceContract(IdentityReduce.class,PactInteger.class,0,sourceB);
  ReduceContract globalRed=new ReduceContract(IdentityReduce.class,PactInteger.class,0);
  globalRed.addInput(redA);
  globalRed.addInput(redB);
  FileDataSink sink=new FileDataSink(DummyOutputFormat.class,OUT_FILE,globalRed);
  Plan plan=new Plan(sink,"Union Property Propagation");
  OptimizedPlan oPlan=this.compiler.compile(plan,this.instanceType);
  JobGraphGenerator jobGen=new JobGraphGenerator();
  jobGen.compileJobGraph(oPlan);
  oPlan.accept(new Visitor<OptimizerNode>(){
    @Override public boolean preVisit(    OptimizerNode visitable){
      if (visitable instanceof ReduceNode) {
        for (        PactConnection inConn : visitable.getIncomingConnections()) {
          Assert.assertTrue("Reduce should just forward the input if it is already partitioned",inConn.getShipStrategy().type() == ShipStrategyType.FORWARD);
        }
        return false;
      }
      return true;
    }
    @Override public void postVisit(    OptimizerNode visitable){
    }
  }
);
}
