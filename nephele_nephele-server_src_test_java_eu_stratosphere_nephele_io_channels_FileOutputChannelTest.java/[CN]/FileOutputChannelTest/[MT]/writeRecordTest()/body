{
  final StringRecord record=new StringRecord("abc");
  this.uncompressedDataBuffer=mock(Buffer.class);
  @SuppressWarnings("unchecked") final OutputGate<StringRecord> outGate=mock(OutputGate.class);
  final ByteBufferedOutputChannelBroker outputBroker=mock(ByteBufferedOutputChannelBroker.class);
  when(outputBroker.requestEmptyWriteBuffer()).thenReturn(this.uncompressedDataBuffer);
  when(outputBroker.hasDataLeftToTransmit()).thenReturn(true);
  when(this.recordSerializer.dataLeftFromPreviousSerialization()).thenReturn(false,false,true,true,false,false);
  when(this.uncompressedDataBuffer.remaining()).thenReturn(0);
  FileOutputChannel<StringRecord> fileOutputChannel=new FileOutputChannel<StringRecord>(outGate,1,ChannelID.generate(),ChannelID.generate(),CompressionLevel.NO_COMPRESSION,new SpanningRecordSerializer<StringRecord>());
  fileOutputChannel.setByteBufferedOutputChannelBroker(outputBroker);
  Whitebox.setInternalState(fileOutputChannel,"recordSerializer",this.recordSerializer);
  try {
    fileOutputChannel.writeRecord(record);
  }
 catch (  IOException e) {
    fail();
    e.printStackTrace();
  }
  fileOutputChannel.requestClose();
  assertEquals(false,fileOutputChannel.isClosed());
  when(outputBroker.hasDataLeftToTransmit()).thenReturn(false);
  assertEquals(true,fileOutputChannel.isClosed());
  try {
    fileOutputChannel.writeRecord(record);
    fail();
  }
 catch (  IOException e) {
  }
}
