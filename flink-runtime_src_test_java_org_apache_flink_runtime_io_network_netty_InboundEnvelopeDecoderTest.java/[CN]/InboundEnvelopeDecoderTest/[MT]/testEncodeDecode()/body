{
  final EmbeddedChannel ch=new EmbeddedChannel(new OutboundEnvelopeEncoder(),new InboundEnvelopeDecoder(this.bufferProviderBroker));
  when(this.bufferProviderBroker.getBufferProvider(anyJobId(),anyChannelId())).thenReturn(this.bufferProvider);
  when(this.bufferProvider.requestBuffer(anyInt())).thenAnswer(new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      return allocBuffer((Integer)invocation.getArguments()[0]);
    }
  }
);
  Envelope[] envelopes=new Envelope[]{nextEnvelope(0),nextEnvelope(2),nextEnvelope(32768),nextEnvelope(3782,new TestEvent1(34872527)),nextEnvelope(88,new TestEvent1(8749653),new TestEvent1(365345)),nextEnvelope(0,new TestEvent2(34563456),new TestEvent1(598432),new TestEvent2(976293845)),nextEnvelope(23)};
  ByteBuf buf=encode(ch,envelopes);
  int refCount=buf.retain().refCnt();
  decodeAndVerify(ch,buf,envelopes);
  Assert.assertEquals(refCount - 1,buf.refCnt());
  buf.readerIndex(0);
  ByteBuf[] slices=randomSlices(buf);
  ch.writeInbound((Object[])slices);
  for (  ByteBuf slice : slices) {
    Assert.assertEquals(1,slice.refCnt());
  }
  decodeAndVerify(ch,envelopes);
  buf.release();
}
