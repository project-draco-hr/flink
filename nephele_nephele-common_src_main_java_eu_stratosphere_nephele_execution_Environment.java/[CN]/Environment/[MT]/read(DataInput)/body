{
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException("invokableClassName is null");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException("Class " + invokableClassName + " not found in one of the supplied jar files: "+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    final String typeClassName=StringRecord.readString(in);
    Class<? extends Record> type=null;
    try {
      type=(Class<? extends Record>)Class.forName(typeClassName,true,cl);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new IOException("Class " + typeClassName + " not found in one of the supplied jar files: "+ StringUtils.stringifyException(cnfe));
    }
    final boolean isBroadcast=in.readBoolean();
    ChannelSelector<? extends Record> channelSelector=null;
    if (!isBroadcast) {
      final String channelSelectorClassName=StringRecord.readString(in);
      try {
        channelSelector=(ChannelSelector<? extends Record>)Class.forName(channelSelectorClassName,true,cl).newInstance();
      }
 catch (      InstantiationException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      IllegalAccessException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      ClassNotFoundException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
      channelSelector.read(in);
    }
    @SuppressWarnings("rawtypes") final OutputGate<? extends Record> eog=new OutputGate(this.jobID,gateID,type,i,channelSelector,isBroadcast);
    eog.read(in);
    this.outputGates.add(eog);
    this.unboundOutputGates.add(eog);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    final String deserializerClassName=StringRecord.readString(in);
    RecordDeserializer<? extends Record> recordDeserializer=null;
    Class<? extends RecordDeserializer<? extends Record>> deserializerClass=null;
    try {
      deserializerClass=(Class<? extends RecordDeserializer<? extends Record>>)cl.loadClass(deserializerClassName);
      recordDeserializer=deserializerClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    recordDeserializer.setClassLoader(cl);
    recordDeserializer.read(in);
    final String distributionPatternClassName=StringRecord.readString(in);
    DistributionPattern distributionPattern=null;
    Class<? extends DistributionPattern> distributionPatternClass=null;
    try {
      distributionPatternClass=(Class<? extends DistributionPattern>)cl.loadClass(distributionPatternClassName);
      distributionPattern=distributionPatternClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    @SuppressWarnings("rawtypes") final InputGate<? extends Record> eig=new InputGate(this.jobID,gateID,recordDeserializer,i,distributionPattern);
    eig.read(in);
    this.inputGates.add(eig);
    this.unboundInputGates.add(eig);
  }
  this.runtimeConfiguration=new Configuration();
  this.runtimeConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  this.executionState=EnumUtils.readEnum(in,ExecutionState.class);
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
}
