{
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException("invokableClassName is null");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException("Class " + invokableClassName + " not found in one of the supplied jar files: "+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final String typeClassName=StringRecord.readString(in);
    Class<? extends Record> type=null;
    try {
      type=(Class<? extends Record>)Class.forName(typeClassName,true,cl);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new IOException("Class " + typeClassName + " not found in one of the supplied jar files: "+ StringUtils.stringifyException(cnfe));
    }
    final boolean isBroadcast=in.readBoolean();
    ChannelSelector<? extends Record> channelSelector=null;
    if (!isBroadcast) {
      final String channelSelectorClassName=StringRecord.readString(in);
      try {
        channelSelector=(ChannelSelector<? extends Record>)Class.forName(channelSelectorClassName,true,cl).newInstance();
      }
 catch (      InstantiationException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      IllegalAccessException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      ClassNotFoundException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
    }
    @SuppressWarnings("rawtypes") final OutputGate<? extends Record> eog=new OutputGate(type,i,channelSelector,isBroadcast);
    eog.read(in);
    this.outputGates.add(eog);
    this.unboundOutputGates.add(eog);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    @SuppressWarnings("rawtypes") final InputGate<? extends Record> eig=new InputGate(null,i,null);
    eig.read(in);
    this.inputGates.add(eig);
    this.unboundInputGates.add(eig);
  }
  final int numInputSplits=in.readInt();
  for (int i=0; i < numInputSplits; i++) {
    final boolean isNotNull=in.readBoolean();
    if (isNotNull) {
      final String className=StringRecord.readString(in);
      Class<? extends IOReadableWritable> c=null;
      try {
        c=(Class<? extends IOReadableWritable>)Class.forName(className,true,cl);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new IOException("Class " + className + " not found in one of the supplied jar files: "+ StringUtils.stringifyException(cnfe));
      }
      try {
        final InputSplit inputSplit=(InputSplit)c.newInstance();
        inputSplit.read(in);
        this.inputSplits.add(inputSplit);
      }
 catch (      InstantiationException e) {
        throw new IOException(e);
      }
catch (      IllegalAccessException e) {
        throw new IOException(e);
      }
    }
  }
  this.runtimeConfiguration=new Configuration();
  this.runtimeConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  this.executionState=EnumUtils.readEnum(in,ExecutionState.class);
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
}
