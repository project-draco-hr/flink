{
  this.jsonString.append("\t{\n");
  this.jsonString.append("\t\t\"id\": " + this.nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type="sink";
  break;
case DataSource:
type="source";
break;
default :
type="pact";
break;
}
this.jsonString.append(",\n\t\t\"type\": \"" + type + "\"");
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=visitable.getPactContract().toString();
break;
case DataSource:
contents=visitable.getPactContract().toString();
break;
default :
jsonString.append(",\n\t\t\"pact\": \"" + visitable.getName() + "\"");
contents=visitable.getPactContract().getName();
break;
}
this.jsonString.append(",\n\t\t\"contents\": \"" + contents + "\"");
this.jsonString.append(",\n\t\t\"parallelism\": \"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : "default") + "\"");
List<List<PactConnection>> connLists=visitable.getIncomingConnections();
String child1name="", child2name="";
if (connLists != null && connLists.size() > 0) {
this.jsonString.append(",\n\t\t\"predecessors\": [");
int connCnt=0;
int inputCnt=0;
for (List<PactConnection> oneList : connLists) {
for (PactConnection conn : oneList) {
this.jsonString.append(inputCnt == 0 ? "\n" : ",\n");
if (connCnt == 0) {
child1name+=child1name.length() > 0 ? ", " : "";
child1name+=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name+=child2name.length() > 0 ? ", " : "";
child2name=conn.getSourcePact().getPactContract().getName();
}
this.jsonString.append("\t\t\t{\"id\": " + this.nodeIds.get(conn.getSourcePact()));
if (connLists.size() == 2) {
this.jsonString.append(", \"side\": \"" + (connCnt == 0 ? "first" : "second") + "\"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy="Local Forward";
channelType="memory";
break;
case BROADCAST:
shipStrategy="Broadcast";
channelType="network";
break;
case PARTITION_HASH:
shipStrategy="Partition";
channelType="network";
break;
case PARTITION_RANGE:
shipStrategy="Partition (range)";
channelType="network";
break;
case PARTITION_LOCAL_HASH:
shipStrategy="Partition local";
channelType="memory";
case SFR:
shipStrategy="SFR";
channelType="network";
break;
default :
throw new CompilerException("Unknown ship strategy '" + conn.getShipStrategy().name() + "' in JSON generator.");
}
if (shipStrategy != null) {
this.jsonString.append(", \"shippingStrategy\": \"" + shipStrategy + "\"");
}
if (channelType != null) {
this.jsonString.append(", \"channelType\": \"" + channelType + "\"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
this.jsonString.append(", \"tempMode\": \"" + tempMode + "\"");
}
this.jsonString.append('}');
inputCnt++;
}
connCnt++;
}
this.jsonString.append("\t\t]");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString="Hybrid Hash (build: " + child1name + ")";
break;
case HYBRIDHASH_SECOND:
locString="Hybrid Hash (build: " + child2name + ")";
break;
case MMHASH_FIRST:
locString="Main-Memory Hash (build: " + child1name + ")";
break;
case MMHASH_SECOND:
locString="Main-Memory Hash (build: " + child2name + ")";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString="Nested Loops (Blocked Outer: " + child1name + ")";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString="Nested Loops (Blocked Outer: " + child2name + ")";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString="Nested Loops (Streamed Outer: " + child1name + ")";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString="Nested Loops (Streamed Outer: " + child2name + ")";
break;
case SORT_BOTH_MERGE:
locString="Sort-Both-Merge";
break;
case SORT_FIRST_MERGE:
locString="Sort-First-Merge";
break;
case SORT_SECOND_MERGE:
locString="Sort-Second-Merge";
break;
case MERGE:
locString="Merge";
break;
case SORT:
locString="Sort";
break;
case COMBININGSORT:
locString="Sort with Combiner";
break;
case SORT_SELF_NESTEDLOOP:
locString="Sort Self-Nested-Loops";
break;
case SELF_NESTEDLOOP:
locString="Self-Nested-Loops";
break;
default :
throw new CompilerException("Unknown local strategy '" + visitable.getLocalStrategy().name() + "' in JSON generator.");
}
if (locString != null) {
this.jsonString.append(",\n\t\t\"local_strategy\": \"");
this.jsonString.append(locString);
this.jsonString.append("\"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
this.jsonString.append(",\n\t\t\"global_properties\": [\n");
addProperty(jsonString,"Partitioning",gp.getPartitioning().name(),true);
if (gp.getPartitioning() != PartitionProperty.NONE) {
addProperty(jsonString,"Partitioned on",Arrays.toString(gp.getPartitionedFields()),false);
}
if (gp.getOrdering() != null) {
addProperty(jsonString,"Order",gp.getOrdering().toString(),false);
}
 else {
addProperty(jsonString,"Order","(none)",false);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,"Uniqueness","not unique",false);
}
 else {
addProperty(jsonString,"Uniqueness",visitable.getUniqueFields().toString(),false);
}
this.jsonString.append("\n\t\t]");
}
{
LocalProperties lp=visitable.getLocalProperties();
this.jsonString.append(",\n\t\t\"local_properties\": [\n");
if (lp.getOrdering() != null) {
addProperty(jsonString,"Order",lp.getOrdering().toString(),true);
}
 else {
addProperty(jsonString,"Order","(none)",true);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,"Uniqueness","not unique",false);
}
 else {
addProperty(jsonString,"Uniqueness",visitable.getUniqueFields().toString(),false);
}
addProperty(jsonString,"Grouping",lp.isGrouped() ? "grouped" : "not grouped",false);
if (lp.isGrouped()) {
addProperty(jsonString,"Grouped on",lp.getGroupedFields().toString(),false);
}
this.jsonString.append("\n\t\t]");
}
this.jsonString.append(",\n\t\t\"properties\": [\n");
addProperty(this.jsonString,"Est. Cardinality",visitable.getEstimatedNumRecords() == -1 ? "(unknown)" : formatNumber(visitable.getEstimatedNumRecords()),true);
String estCardinality="(unknown)";
if (visitable.getEstimatedCardinalities().size() > 0) {
estCardinality="";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
estCardinality+="[" + entry.getKey().toString() + "->"+ entry.getValue()+ "]";
}
}
addProperty(jsonString,"Est. Cardinality/fields",estCardinality,false);
addProperty(jsonString,"Est. Output Size",visitable.getEstimatedOutputSize() == -1 ? "(unknown)" : formatNumber(visitable.getEstimatedOutputSize(),"B"),false);
this.jsonString.append("\t\t]");
if (visitable.getNodeCosts() != null) {
this.jsonString.append(",\n\t\t\"costs\": [\n");
addProperty(this.jsonString,"Network",visitable.getNodeCosts().getNetworkCost() == -1 ? "(unknown)" : formatNumber(visitable.getNodeCosts().getNetworkCost(),"B"),true);
addProperty(this.jsonString,"Disk I/O",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? "(unknown)" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),"B"),false);
addProperty(this.jsonString,"Cumulative Network",visitable.getCumulativeCosts().getNetworkCost() == -1 ? "(unknown)" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),"B"),false);
addProperty(this.jsonString,"Cumulative Disk I/O",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? "(unknown)" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),"B"),false);
this.jsonString.append("\n\t\t]");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
this.jsonString.append(",\n\t\t\"compiler_hints\": [\n");
String hintCardinality="(none)";
if (hints.getDistinctCounts().size() > 0) {
hintCardinality="";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
hintCardinality+="[" + entry.getKey().toString() + "->"+ entry.getValue()+ "]";
}
}
addProperty(jsonString,"Cardinality",hintCardinality,true);
addProperty(jsonString,"Avg. Records/StubCall",hints.getAvgRecordsEmittedPerStubCall() == defaults.getAvgRecordsEmittedPerStubCall() ? "(none)" : String.valueOf(hints.getAvgRecordsEmittedPerStubCall()),false);
String valuesKey="(none)";
if (hints.getAvgNumRecordsPerDistinctFields().size() > 0) {
valuesKey="";
for (Entry<FieldSet,Float> entry : hints.getAvgNumRecordsPerDistinctFields().entrySet()) {
valuesKey+="[" + entry.getKey().toString() + "->"+ entry.getValue()+ "]";
}
}
addProperty(jsonString,"Avg. Values/Distinct fields",valuesKey,false);
addProperty(jsonString,"Avg. Width (bytes)",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? "(none)" : String.valueOf(hints.getAvgBytesPerRecord()),false);
this.jsonString.append("\t\t]");
}
this.jsonString.append("\n\t},\n");
}
