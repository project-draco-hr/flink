{
  EnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList != null) {
    return receiverList;
  }
  while (true) {
    ConnectionInfoLookupResponse lookupResponse;
synchronized (this.channelLookup) {
      Future<Object> futureResponse=Patterns.ask(channelLookup,new JobManagerMessages.LookupConnectionInformation(connectionInfo,jobID,sourceChannelID),AkkaUtils.FUTURE_TIMEOUT());
      try {
        lookupResponse=((JobManagerMessages.ConnectionInformation)Await.result(futureResponse,AkkaUtils.AWAIT_DURATION())).response();
      }
 catch (      IOException ioe) {
        throw ioe;
      }
catch (      Exception e) {
        throw new RuntimeException("Caught exception while looking connection information up.",e);
      }
    }
    if (lookupResponse.receiverReady()) {
      receiverList=new EnvelopeReceiverList(lookupResponse);
      break;
    }
 else     if (lookupResponse.receiverNotReady()) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        if (reportException) {
          throw new IOException("Lookup was interrupted.");
        }
 else {
          return null;
        }
      }
    }
 else     if (lookupResponse.isJobAborting()) {
      if (reportException) {
        throw new CancelTaskException();
      }
 else {
        return null;
      }
    }
 else     if (lookupResponse.receiverNotFound()) {
      if (reportException) {
        throw new IOException("Could not find the receiver for Job " + jobID + ", channel with source id "+ sourceChannelID);
      }
 else {
        return null;
      }
    }
 else {
      throw new IllegalStateException("Unrecognized response to channel lookup.");
    }
  }
  this.receiverCache.put(sourceChannelID,receiverList);
  if (LOG.isDebugEnabled()) {
    LOG.debug(String.format("Receiver for %s: %s [%s])",sourceChannelID,receiverList.hasLocalReceiver() ? receiverList.getLocalReceiver() : receiverList.getRemoteReceiver(),receiverList.hasLocalReceiver() ? "local" : "remote"));
  }
  return receiverList;
}
