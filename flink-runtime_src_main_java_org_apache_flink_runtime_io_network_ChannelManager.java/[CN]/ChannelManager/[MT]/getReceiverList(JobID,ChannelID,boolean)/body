{
  EnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList != null) {
    return receiverList;
  }
  while (true) {
    ConnectionInfoLookupResponse lookupResponse;
synchronized (this.channelLookup) {
      try {
        lookupResponse=AkkaUtils.<JobManagerMessages.ConnectionInformation>ask(channelLookup,new JobManagerMessages.LookupConnectionInformation(connectionInfo,jobID,sourceChannelID)).response();
      }
 catch (      IOException ioe) {
        throw ioe;
      }
    }
    if (lookupResponse.receiverReady()) {
      receiverList=new EnvelopeReceiverList(lookupResponse);
      break;
    }
 else     if (lookupResponse.receiverNotReady()) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        if (reportException) {
          throw new IOException("Lookup was interrupted.");
        }
 else {
          return null;
        }
      }
    }
 else     if (lookupResponse.isJobAborting()) {
      if (reportException) {
        throw new CancelTaskException();
      }
 else {
        return null;
      }
    }
 else     if (lookupResponse.receiverNotFound()) {
      if (reportException) {
        throw new IOException("Could not find the receiver for Job " + jobID + ", channel with source id "+ sourceChannelID);
      }
 else {
        return null;
      }
    }
 else {
      throw new IllegalStateException("Unrecognized response to channel lookup.");
    }
  }
  this.receiverCache.put(sourceChannelID,receiverList);
  if (LOG.isDebugEnabled()) {
    LOG.debug(String.format("Receiver for %s: %s [%s])",sourceChannelID,receiverList.hasLocalReceiver() ? receiverList.getLocalReceiver() : receiverList.getRemoteReceiver(),receiverList.hasLocalReceiver() ? "local" : "remote"));
  }
  return receiverList;
}
