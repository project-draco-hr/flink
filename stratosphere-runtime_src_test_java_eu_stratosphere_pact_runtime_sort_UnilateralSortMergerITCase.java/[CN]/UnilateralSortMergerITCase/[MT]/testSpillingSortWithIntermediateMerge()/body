{
  final int PAIRS=10000000;
  final Comparator<TestData.Key> keyComparator=new TestData.KeyComparator();
  final TestData.Generator generator=new TestData.Generator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
  final MutableObjectIterator<Record> source=new TestData.GeneratorIterator(generator,PAIRS);
  LOG.debug("Initializing sortmerger...");
  Sorter<Record> merger=new UnilateralSortMerger<Record>(this.memoryManager,this.ioManager,source,this.parentTask,this.pactRecordSerializer,this.pactRecordComparator,64 * 1024 * 1024,16,0.7f);
  LOG.debug("Emitting data...");
  MutableObjectIterator<Record> iterator=merger.getIterator();
  LOG.debug("Checking results...");
  int pairsRead=1;
  int nextStep=PAIRS / 20;
  Record rec1=new Record();
  Record rec2=new Record();
  Assert.assertTrue((rec1=iterator.next(rec1)) != null);
  while ((rec2=iterator.next(rec2)) != null) {
    final Key k1=rec1.getField(0,TestData.Key.class);
    final Key k2=rec2.getField(0,TestData.Key.class);
    pairsRead++;
    Assert.assertTrue(keyComparator.compare(k1,k2) <= 0);
    Record tmp=rec1;
    rec1=rec2;
    k1.setKey(k2.getKey());
    rec2=tmp;
    if (pairsRead == nextStep) {
      nextStep+=PAIRS / 20;
    }
  }
  Assert.assertEquals("Not all pairs were read back in.",PAIRS,pairsRead);
  merger.close();
}
