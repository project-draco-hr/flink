{
  final TestInstanceManager tim=new TestInstanceManager();
  final TestDeploymentManager tdm=new TestDeploymentManager();
  final DefaultScheduler scheduler=new DefaultScheduler(tdm,tim);
  final ExecutionGraph executionGraph=createExecutionGraph(ChannelType.IN_MEMORY);
  try {
    try {
      scheduler.scheduleJob(executionGraph);
    }
 catch (    SchedulingException e) {
      fail(StringUtils.stringifyException(e));
    }
    tdm.waitForDeployment();
    assertEquals(executionGraph.getJobID(),tdm.getIDOfLastDeployedJob());
    final List<ExecutionVertex> listOfDeployedVertices=tdm.getListOfLastDeployedVertices();
    assertNotNull(listOfDeployedVertices);
    assertEquals(2,listOfDeployedVertices.size());
    assertEquals(0,tim.getNumberOfReleaseMethodCalls());
    for (    final ExecutionVertex vertex : listOfDeployedVertices) {
      vertex.updateExecutionState(ExecutionState.STARTING);
      vertex.updateExecutionState(ExecutionState.RUNNING);
      vertex.updateExecutionState(ExecutionState.FINISHING);
      vertex.updateExecutionState(ExecutionState.FINISHED);
    }
    assertEquals(1,tim.getNumberOfReleaseMethodCalls());
  }
  finally {
    try {
      LibraryCacheManager.unregister(executionGraph.getJobID());
    }
 catch (    IOException ioe) {
    }
  }
}
