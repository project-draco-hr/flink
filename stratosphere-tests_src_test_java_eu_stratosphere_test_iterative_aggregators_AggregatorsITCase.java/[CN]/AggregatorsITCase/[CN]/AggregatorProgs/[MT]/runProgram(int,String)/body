{
switch (progId) {
case 1:
{
      final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
      env.setDegreeOfParallelism(DOP);
      DataSet<Integer> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env);
      IterativeDataSet<Integer> iteration=initialSolutionSet.iterate(MAX_ITERATIONS);
      LongSumAggregator aggr=new LongSumAggregator();
      iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
      iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR,aggr,new NegativeElementsConvergenceCriterion());
      DataSet<Integer> updatedDs=iteration.map(new SubtractOneMap());
      iteration.closeWith(updatedDs).writeAsText(resultPath);
      env.execute();
      return "-3\n" + "-2\n" + "-2\n"+ "-1\n"+ "-1\n"+ "-1\n"+ "0\n"+ "0\n"+ "0\n"+ "0\n"+ "1\n"+ "1\n"+ "1\n"+ "1\n"+ "1\n";
    }
case 2:
{
    final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
    env.setDegreeOfParallelism(DOP);
    DataSet<Integer> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env);
    IterativeDataSet<Integer> iteration=initialSolutionSet.iterate(MAX_ITERATIONS);
    LongSumAggregatorWithParameter aggr=new LongSumAggregatorWithParameter(0);
    iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
    iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR,aggr,new NegativeElementsConvergenceCriterion());
    DataSet<Integer> updatedDs=iteration.map(new SubtractOneMapWithParam());
    iteration.closeWith(updatedDs).writeAsText(resultPath);
    env.execute();
    return "-3\n" + "-2\n" + "-2\n"+ "-1\n"+ "-1\n"+ "-1\n"+ "0\n"+ "0\n"+ "0\n"+ "0\n"+ "1\n"+ "1\n"+ "1\n"+ "1\n"+ "1\n";
  }
case 3:
{
  final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  env.setDegreeOfParallelism(DOP);
  DataSet<Integer> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env);
  IterativeDataSet<Integer> iteration=initialSolutionSet.iterate(MAX_ITERATIONS);
  LongSumAggregator aggr=new LongSumAggregator();
  iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
  iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR,aggr,new NegativeElementsConvergenceCriterionWithParam(3));
  DataSet<Integer> updatedDs=iteration.map(new SubtractOneMap());
  iteration.closeWith(updatedDs).writeAsText(resultPath);
  env.execute();
  return "-3\n" + "-2\n" + "-2\n"+ "-1\n"+ "-1\n"+ "-1\n"+ "0\n"+ "0\n"+ "0\n"+ "0\n"+ "1\n"+ "1\n"+ "1\n"+ "1\n"+ "1\n";
}
case 4:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
env.setDegreeOfParallelism(DOP);
DataSet<Tuple2<Integer,Integer>> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap());
DeltaIteration<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> iteration=initialSolutionSet.iterateDelta(initialSolutionSet,MAX_ITERATIONS,0);
LongSumAggregator aggr=new LongSumAggregator();
iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
DataSet<Tuple2<Integer,Integer>> updatedDs=iteration.getWorkset().map(new AggregateMapDelta());
DataSet<Tuple2<Integer,Integer>> newElements=updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new UpdateFilter());
DataSet<Tuple2<Integer,Integer>> iterationRes=iteration.closeWith(newElements,newElements);
DataSet<Integer> result=iterationRes.map(new ProjectSecondMapper());
result.writeAsText(resultPath);
env.execute();
return "1\n" + "2\n" + "2\n"+ "3\n"+ "3\n"+ "3\n"+ "4\n"+ "4\n"+ "4\n"+ "4\n"+ "5\n"+ "5\n"+ "5\n"+ "5\n"+ "5\n";
}
case 5:
{
final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
env.setDegreeOfParallelism(DOP);
DataSet<Tuple2<Integer,Integer>> initialSolutionSet=CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap());
DeltaIteration<Tuple2<Integer,Integer>,Tuple2<Integer,Integer>> iteration=initialSolutionSet.iterateDelta(initialSolutionSet,MAX_ITERATIONS,0);
LongSumAggregator aggr=new LongSumAggregatorWithParameter(4);
iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR,aggr);
DataSet<Tuple2<Integer,Integer>> updatedDs=iteration.getWorkset().map(new AggregateMapDelta());
DataSet<Tuple2<Integer,Integer>> newElements=updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new UpdateFilter());
DataSet<Tuple2<Integer,Integer>> iterationRes=iteration.closeWith(newElements,newElements);
DataSet<Integer> result=iterationRes.map(new ProjectSecondMapper());
result.writeAsText(resultPath);
env.execute();
return "1\n" + "2\n" + "2\n"+ "3\n"+ "3\n"+ "3\n"+ "4\n"+ "4\n"+ "4\n"+ "4\n"+ "5\n"+ "5\n"+ "5\n"+ "5\n"+ "5\n";
}
default :
throw new IllegalArgumentException("Invalid program id");
}
}
