{
  String edgePath="TESTDATA";
  String outPath="STDOUT";
  if (args.length > 0) {
    edgePath=args[0];
  }
  if (args.length > 1) {
    outPath=args[1];
  }
  final ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  DataSet<Edge> edges;
  if (edgePath.equals("TESTDATA")) {
    edges=EdgeData.getDefaultEdgeDataSet(env);
  }
 else {
    edges=env.readCsvFile(edgePath).fieldDelimiter(',').includeFields(true,true).types(Integer.class,Integer.class).map(new TupleEdgeConverter());
  }
  DataSet<EdgeWithDegrees> edgesWithDegrees=edges.flatMap(new EdgeDuplicator()).groupBy(Edge.V1).sortGroup(Edge.V2,Order.ASCENDING).reduceGroup(new DegreeCounter()).groupBy(EdgeWithDegrees.V1,EdgeWithDegrees.V2).reduce(new DegreeJoiner());
  DataSet<Edge> edgesByDegree=edgesWithDegrees.map(new EdgeByDegreeProjector());
  DataSet<Edge> edgesById=edgesByDegree.map(new EdgeByIdProjector());
  DataSet<Triad> triangles=edgesByDegree.groupBy(Edge.V1).sortGroup(Edge.V2,Order.ASCENDING).reduceGroup(new TriadBuilder()).join(edgesById).where(Triad.V2,Triad.V3).equalTo(Edge.V1,Edge.V2).with(new TriadFilter());
  if (outPath.equals("STDOUT")) {
    triangles.print();
  }
 else {
    triangles.writeAsCsv(outPath,"\n",",");
  }
  env.execute();
}
