{
  if (slot == null || jid == null) {
    throw new NullPointerException();
  }
synchronized (allSlots) {
    if (!allSlots.contains(slot)) {
      throw new IllegalArgumentException("Slot was not associated with this SlotSharingGroup before.");
    }
    if (lastSubSlot) {
      allSlots.remove(slot);
      Instance location=slot.getAllocatedSlot().getInstance();
      for (      Map.Entry<JobVertexID,Map<Instance,List<SharedSlot>>> mapEntry : availableSlotsPerJid.entrySet()) {
        if (mapEntry.getKey().equals(jid)) {
          continue;
        }
        Map<Instance,List<SharedSlot>> map=mapEntry.getValue();
        List<SharedSlot> list=map.get(location);
        if (list == null || !list.remove(slot)) {
          throw new IllegalStateException("SharedSlot was not available to another vertex type that it was not allocated for before.");
        }
        if (list.isEmpty()) {
          map.remove(location);
        }
      }
      return true;
    }
    Map<Instance,List<SharedSlot>> slotsForJid=availableSlotsPerJid.get(jid);
    if (slotsForJid == null) {
      throw new IllegalStateException("Trying to return a slot for jid " + jid + " when available slots indicated that all slots were available.");
    }
    putIntoMultiMap(slotsForJid,slot.getAllocatedSlot().getInstance(),slot);
    return false;
  }
}
