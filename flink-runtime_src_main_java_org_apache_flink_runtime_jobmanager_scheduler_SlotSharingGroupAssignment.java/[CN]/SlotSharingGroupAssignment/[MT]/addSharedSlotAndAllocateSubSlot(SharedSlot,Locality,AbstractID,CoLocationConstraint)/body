{
  final Instance location=sharedSlot.getInstance();
synchronized (lock) {
    allSlots.add(sharedSlot);
    SimpleSlot subSlot=null;
    if (constraint == null) {
      subSlot=sharedSlot.allocateSubSlot(groupId);
    }
 else {
      SharedSlot constraintGroupSlot=sharedSlot.allocateSharedSlot(groupId);
      if (constraintGroupSlot == null) {
        subSlot=null;
      }
 else {
        subSlot=constraintGroupSlot.allocateSubSlot(null);
        if (subSlot == null) {
          constraintGroupSlot.releaseSlot();
        }
      }
    }
    if (subSlot == null) {
      LOG.warn("Could not allocate a sub slot.");
      return null;
    }
 else {
      subSlot.setLocality(locality);
      boolean entryForNewJidExists=false;
      for (      Map.Entry<AbstractID,Map<Instance,List<SharedSlot>>> entry : availableSlotsPerJid.entrySet()) {
        if (entry.getKey().equals(groupId)) {
          entryForNewJidExists=true;
          continue;
        }
        Map<Instance,List<SharedSlot>> available=entry.getValue();
        putIntoMultiMap(available,location,sharedSlot);
      }
      if (!entryForNewJidExists) {
        availableSlotsPerJid.put(groupId,new LinkedHashMap<Instance,List<SharedSlot>>());
      }
      return subSlot;
    }
  }
}
