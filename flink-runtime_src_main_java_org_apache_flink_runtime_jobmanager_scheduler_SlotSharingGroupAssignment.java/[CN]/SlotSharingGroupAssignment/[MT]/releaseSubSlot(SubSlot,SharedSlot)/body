{
  AbstractID groupId=subslot.getGroupId();
synchronized (lock) {
    if (!allSlots.contains(sharedSlot)) {
      throw new IllegalArgumentException("Slot was not associated with this SlotSharingGroup before.");
    }
    int slotsRemaining=sharedSlot.releaseSlot(subslot);
    if (slotsRemaining == 0) {
      try {
        allSlots.remove(sharedSlot);
        Instance location=sharedSlot.getAllocatedSlot().getInstance();
        if (groupId != null) {
          for (          Map.Entry<AbstractID,Map<Instance,List<SharedSlot>>> mapEntry : availableSlotsPerJid.entrySet()) {
            AbstractID id=mapEntry.getKey();
            if (id.getClass() == AbstractID.class || id.equals(groupId)) {
              continue;
            }
            Map<Instance,List<SharedSlot>> map=mapEntry.getValue();
            List<SharedSlot> list=map.get(location);
            if (list == null || !list.remove(sharedSlot)) {
              throw new IllegalStateException("Bug: SharedSlot was not available to another vertex type that it was not allocated for before.");
            }
            if (list.isEmpty()) {
              map.remove(location);
            }
          }
        }
      }
  finally {
        sharedSlot.dispose();
      }
    }
 else     if (groupId != null) {
      Map<Instance,List<SharedSlot>> slotsForJid=availableSlotsPerJid.get(groupId);
      if (slotsForJid == null) {
        throw new IllegalStateException("Trying to return a slot for group " + groupId + " when available slots indicated that all slots were available.");
      }
      putIntoMultiMap(slotsForJid,sharedSlot.getAllocatedSlot().getInstance(),sharedSlot);
    }
  }
}
