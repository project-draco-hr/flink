{
  final int NUMKEYS=12288;
  final int NUMVALS=4;
  Iterator<KeyValuePair<PactInteger,PactInteger>> inIt=new Iterator<KeyValuePair<PactInteger,PactInteger>>(){
    int keyCnt=1;
    int valCnt=1;
    @Override public boolean hasNext(){
      if (valCnt <= NUMVALS) {
        return true;
      }
 else {
        return false;
      }
    }
    @Override public KeyValuePair<PactInteger,PactInteger> next(){
      PactInteger key=new PactInteger(keyCnt++);
      PactInteger val=new PactInteger(valCnt);
      if (keyCnt == NUMKEYS + 1) {
        keyCnt=1;
        valCnt++;
      }
      return new KeyValuePair<PactInteger,PactInteger>(key,val);
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(inIt);
  super.addOutput(outList);
  ReduceTask testTask=new ReduceTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.COMBININGSORT);
  super.getTaskConfig().setNumSortBuffer(2);
  super.getTaskConfig().setSortBufferSize(1);
  super.getTaskConfig().setMergeFactor(4);
  super.getTaskConfig().setIOBufferSize(1);
  super.registerTask(testTask,MockCombiningReduceStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  Assert.assertTrue("Resultset size was " + outList.size() + ". Expected was "+ NUMKEYS,outList.size() == NUMKEYS);
  final int expVal=computeSum(NUMVALS);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Assert.assertTrue("Incorrect result",(expVal % pair.getKey().getValue()) == pair.getValue().getValue());
  }
  outList.clear();
  try {
    super.getMemoryManager().allocate(3 * 1024 * 1024);
  }
 catch (  MemoryAllocationException e) {
    Assert.fail("MemoryManager not reset");
  }
}
