{
  final TypeSerializerFactory<?> serializer=RecordSerializerFactory.get();
  @SuppressWarnings("unchecked") final TypeComparatorFactory<?> comparator=new RecordComparatorFactory(new int[]{0},new Class[]{LongValue.class},new boolean[]{true});
  final TypePairComparatorFactory<?,?> pairComparator=RecordPairComparatorFactory.get();
  JobGraph jobGraph=new JobGraph("Connected Components (Unified Tails)");
  InputFormatVertex vertices=createVerticesInput(jobGraph,verticesPath,numSubTasks,serializer,comparator);
  InputFormatVertex edges=createEdgesInput(jobGraph,edgesPath,numSubTasks,serializer,comparator);
  AbstractJobVertex head=createIterationHead(jobGraph,numSubTasks,serializer,comparator,pairComparator);
  AbstractJobVertex intermediate=createIterationIntermediate(jobGraph,numSubTasks,serializer,comparator);
  TaskConfig intermediateConfig=new TaskConfig(intermediate.getConfiguration());
  OutputFormatVertex output=createOutput(jobGraph,resultPath,numSubTasks,serializer);
  AbstractJobVertex fakeTail=createFakeTail(jobGraph,numSubTasks);
  AbstractJobVertex sync=createSync(jobGraph,numSubTasks,maxIterations);
  AbstractJobVertex tail=JobGraphUtils.createTask(IterationTailPactTask.class,"IterationTail",jobGraph,numSubTasks);
  TaskConfig tailConfig=new TaskConfig(tail.getConfiguration());
{
    tailConfig.setIterationId(ITERATION_ID);
    tailConfig.setIsWorksetIteration();
    tailConfig.setIsWorksetUpdate();
    tailConfig.setIsSolutionSetUpdate();
    tailConfig.setIsSolutionSetUpdateWithoutReprobe();
    tailConfig.addInputToGroup(0);
    tailConfig.setInputSerializer(serializer,0);
    tailConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
    tailConfig.setOutputSerializer(serializer);
    tailConfig.setDriver(JoinWithSolutionSetSecondDriver.class);
    tailConfig.setDriverStrategy(DriverStrategy.HYBRIDHASH_BUILD_SECOND);
    tailConfig.setDriverComparator(comparator,0);
    tailConfig.setDriverPairComparator(pairComparator);
    tailConfig.setStubWrapper(new UserCodeClassWrapper<UpdateComponentIdMatch>(UpdateComponentIdMatch.class));
  }
  JobGraphUtils.connect(vertices,head,ChannelType.NETWORK,DistributionPattern.BIPARTITE);
  JobGraphUtils.connect(edges,head,ChannelType.NETWORK,DistributionPattern.BIPARTITE);
  JobGraphUtils.connect(vertices,head,ChannelType.NETWORK,DistributionPattern.BIPARTITE);
  JobGraphUtils.connect(head,intermediate,ChannelType.NETWORK,DistributionPattern.BIPARTITE);
  intermediateConfig.setGateIterativeWithNumberOfEventsUntilInterrupt(0,numSubTasks);
  JobGraphUtils.connect(intermediate,tail,ChannelType.IN_MEMORY,DistributionPattern.POINTWISE);
  tailConfig.setGateIterativeWithNumberOfEventsUntilInterrupt(0,1);
  JobGraphUtils.connect(head,output,ChannelType.IN_MEMORY,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(tail,fakeTail,ChannelType.IN_MEMORY,DistributionPattern.POINTWISE);
  JobGraphUtils.connect(head,sync,ChannelType.NETWORK,DistributionPattern.POINTWISE);
  SlotSharingGroup sharingGroup=new SlotSharingGroup();
  vertices.setSlotSharingGroup(sharingGroup);
  edges.setSlotSharingGroup(sharingGroup);
  head.setSlotSharingGroup(sharingGroup);
  intermediate.setSlotSharingGroup(sharingGroup);
  tail.setSlotSharingGroup(sharingGroup);
  output.setSlotSharingGroup(sharingGroup);
  sync.setSlotSharingGroup(sharingGroup);
  fakeTail.setSlotSharingGroup(sharingGroup);
  intermediate.setStrictlyCoLocatedWith(head);
  tail.setStrictlyCoLocatedWith(head);
  fakeTail.setStrictlyCoLocatedWith(tail);
  return jobGraph;
}
