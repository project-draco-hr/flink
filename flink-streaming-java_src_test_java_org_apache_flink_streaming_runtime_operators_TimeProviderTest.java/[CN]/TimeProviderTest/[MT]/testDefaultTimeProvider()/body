{
  final OneShotLatch latch=new OneShotLatch();
  final Object lock=new Object();
  final AtomicReference<Throwable> error=new AtomicReference<>();
  TimeServiceProvider timeServiceProvider=new DefaultTimeServiceProvider(new ReferenceSettingExceptionHandler(error),lock);
  final List<Long> timestamps=new ArrayList<>();
  long interval=50L;
  final long noOfTimers=20;
  final long expectedNoOfTimers=2 * noOfTimers;
  for (int i=0; i < noOfTimers; i++) {
    double nextTimer=timeServiceProvider.getCurrentProcessingTime() + 100 + i * interval;
    timeServiceProvider.registerTimer((long)nextTimer,new Triggerable(){
      @Override public void trigger(      long timestamp) throws Exception {
        timestamps.add(timestamp);
        if (timestamps.size() == expectedNoOfTimers) {
          latch.trigger();
        }
      }
    }
);
    timeServiceProvider.registerTimer((long)(nextTimer - 10L),new Triggerable(){
      @Override public void trigger(      long timestamp) throws Exception {
        timestamps.add(timestamp);
        if (timestamps.size() == expectedNoOfTimers) {
          latch.trigger();
        }
      }
    }
);
  }
  if (!latch.isTriggered()) {
    latch.await();
  }
  Assert.assertEquals(timestamps.size(),expectedNoOfTimers);
  int counter=0;
  long lastTs=Long.MIN_VALUE;
  for (  long timestamp : timestamps) {
    Assert.assertTrue(timestamp >= lastTs);
    if (lastTs != Long.MIN_VALUE && counter % 2 == 1) {
      Assert.assertEquals((timestamp - lastTs),10);
    }
    lastTs=timestamp;
    counter++;
  }
  assertNull(error.get());
}
