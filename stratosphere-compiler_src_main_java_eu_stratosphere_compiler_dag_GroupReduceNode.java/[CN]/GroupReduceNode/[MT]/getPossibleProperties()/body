{
  final Configuration conf=getPactContract().getParameters();
  final String localStrategy=conf.getString(PactCompiler.HINT_LOCAL_STRATEGY,null);
  final boolean useCombiner;
  if (localStrategy != null) {
    if (PactCompiler.HINT_LOCAL_STRATEGY_SORT.equals(localStrategy)) {
      useCombiner=false;
    }
 else     if (PactCompiler.HINT_LOCAL_STRATEGY_COMBINING_SORT.equals(localStrategy)) {
      if (!isCombineable()) {
        PactCompiler.LOG.warn("Strategy hint for Reduce Pact '" + getPactContract().getName() + "' desires combinable reduce, but user function is not marked combinable.");
      }
      useCombiner=true;
    }
 else {
      throw new CompilerException("Invalid local strategy hint for match contract: " + localStrategy);
    }
  }
 else {
    useCombiner=isCombineable();
  }
  Ordering groupOrder=null;
  if (getPactContract() instanceof GroupReduceOperatorBase) {
    groupOrder=((GroupReduceOperatorBase<?,?,?>)getPactContract()).getGroupOrder();
    if (groupOrder != null && groupOrder.getNumberOfFields() == 0) {
      groupOrder=null;
    }
  }
  OperatorDescriptorSingle props=useCombiner ? (this.keys == null ? new AllGroupWithPartialPreGroupProperties() : new GroupReduceWithCombineProperties(this.keys,groupOrder)) : (this.keys == null ? new AllGroupReduceProperties() : new GroupReduceProperties(this.keys,groupOrder));
  return Collections.singletonList(props);
}
