{
  super(batchSizesOfNotPartitioned,batchSizesOfPartitioned,parallelismOfOutput,keyPosition,batchTimeout,channelID,serializationDelegate,partitionedOutputs,notPartitionedOutputs);
  this.outputSelector=outputSelector;
  this.notPartitionedOutputNameMap=new HashMap<String,StreamCollector<Tuple>>();
  this.partitionedOutputNameMap=new HashMap<String,StreamCollector<Tuple>[]>();
  partitionedCollectors=new HashSet<StreamCollector<Tuple>[]>(batchSizesOfPartitioned.size());
  for (int i=0; i < batchSizesOfPartitioned.size(); i++) {
    @SuppressWarnings("unchecked") StreamCollector<Tuple>[] collectors=new StreamCollector[parallelismOfOutput.get(i)];
    for (int j=0; j < collectors.length; j++) {
      collectors[j]=new StreamCollector<Tuple>(batchSizesOfPartitioned.get(i),batchTimeout,channelID,serializationDelegate,partitionedOutputs.get(i));
    }
    partitionedOutputNameMap.put(partitionedOutputNames.get(i),collectors);
    partitionedCollectors.add(collectors);
  }
  notPartitionedCollectors=new HashSet<StreamCollector<Tuple>>(batchSizesOfNotPartitioned.size());
  for (int i=0; i < batchSizesOfNotPartitioned.size(); i++) {
    StreamCollector<Tuple> collector=new StreamCollector<Tuple>(batchSizesOfNotPartitioned.get(i),batchTimeout,channelID,serializationDelegate,notPartitionedOutputs.get(i));
    notPartitionedCollectors.add(collector);
    notPartitionedOutputNameMap.put(notPartitionedOutputNames.get(i),collector);
  }
}
