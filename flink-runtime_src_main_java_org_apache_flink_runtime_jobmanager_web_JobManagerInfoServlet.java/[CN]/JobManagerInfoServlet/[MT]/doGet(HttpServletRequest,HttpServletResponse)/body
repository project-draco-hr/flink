{
  resp.setStatus(HttpServletResponse.SC_OK);
  resp.setContentType("application/json");
  Future<Object> response;
  Object result;
  try {
    if ("archive".equals(req.getParameter("get"))) {
      response=Patterns.ask(archive,ArchiveMessages.getRequestArchivedJobs(),new Timeout(timeout));
      result=Await.result(response,timeout);
      if (!(result instanceof ArchivedJobs)) {
        throw new RuntimeException("RequestArchiveJobs requires a response of type " + "ArchivedJobs. Instead the response is of type " + result.getClass() + ".");
      }
 else {
        final List<ExecutionGraph> archivedJobs=new ArrayList<ExecutionGraph>(((ArchivedJobs)result).asJavaCollection());
        writeJsonForArchive(resp.getWriter(),archivedJobs);
      }
    }
 else     if ("job".equals(req.getParameter("get"))) {
      String jobId=req.getParameter("job");
      response=Patterns.ask(archive,new RequestJob(JobID.fromHexString(jobId)),new Timeout(timeout));
      result=Await.result(response,timeout);
      if (!(result instanceof JobResponse)) {
        throw new RuntimeException("RequestJob requires a response of type JobResponse. " + "Instead the response is of type " + result.getClass());
      }
 else {
        final JobResponse jobResponse=(JobResponse)result;
        if (jobResponse instanceof JobFound) {
          ExecutionGraph archivedJob=((JobFound)result).executionGraph();
          writeJsonForArchivedJob(resp.getWriter(),archivedJob);
        }
 else {
          LOG.warn("DoGet:job: Could not find job for job ID " + jobId);
        }
      }
    }
 else     if ("groupvertex".equals(req.getParameter("get"))) {
      String jobId=req.getParameter("job");
      String groupvertexId=req.getParameter("groupvertex");
      response=Patterns.ask(archive,new RequestJob(JobID.fromHexString(jobId)),new Timeout(timeout));
      result=Await.result(response,timeout);
      if (!(result instanceof JobResponse)) {
        throw new RuntimeException("RequestJob requires a response of type JobResponse. " + "Instead the response is of type " + result.getClass());
      }
 else {
        final JobResponse jobResponse=(JobResponse)result;
        if (jobResponse instanceof JobFound && groupvertexId != null) {
          ExecutionGraph archivedJob=((JobFound)jobResponse).executionGraph();
          writeJsonForArchivedJobGroupvertex(resp.getWriter(),archivedJob,JobVertexID.fromHexString(groupvertexId));
        }
 else {
          LOG.warn("DoGet:groupvertex: Could not find job for job ID " + jobId);
        }
      }
    }
 else     if ("taskmanagers".equals(req.getParameter("get"))) {
      response=Patterns.ask(jobmanager,JobManagerMessages.getRequestNumberRegisteredTaskManager(),new Timeout(timeout));
      result=Await.result(response,timeout);
      if (!(result instanceof Integer)) {
        throw new RuntimeException("RequestNumberRegisteredTaskManager requires a " + "response of type Integer. Instead the response is of type " + result.getClass() + ".");
      }
 else {
        final int numberOfTaskManagers=(Integer)result;
        final Future<Object> responseRegisteredSlots=Patterns.ask(jobmanager,JobManagerMessages.getRequestTotalNumberOfSlots(),new Timeout(timeout));
        final Object resultRegisteredSlots=Await.result(responseRegisteredSlots,timeout);
        if (!(resultRegisteredSlots instanceof Integer)) {
          throw new RuntimeException("RequestTotalNumberOfSlots requires a response of " + "type Integer. Instaed the response of type " + resultRegisteredSlots.getClass() + ".");
        }
 else {
          final int numberOfRegisteredSlots=(Integer)resultRegisteredSlots;
          resp.getWriter().write("{\"taskmanagers\": " + numberOfTaskManagers + ", "+ "\"slots\": "+ numberOfRegisteredSlots+ "}");
        }
      }
    }
 else     if ("cancel".equals(req.getParameter("get"))) {
      String jobId=req.getParameter("job");
      response=Patterns.ask(jobmanager,new CancelJob(JobID.fromHexString(jobId)),new Timeout(timeout));
      Await.ready(response,timeout);
    }
 else     if ("updates".equals(req.getParameter("get"))) {
      String jobId=req.getParameter("job");
      writeJsonUpdatesForJob(resp.getWriter(),JobID.fromHexString(jobId));
    }
 else     if ("version".equals(req.getParameter("get"))) {
      writeJsonForVersion(resp.getWriter());
    }
 else {
      response=Patterns.ask(jobmanager,JobManagerMessages.getRequestRunningJobs(),new Timeout(timeout));
      result=Await.result(response,timeout);
      if (!(result instanceof RunningJobs)) {
        throw new RuntimeException("RequestRunningJobs requires a response of type " + "RunningJobs. Instead the response of type " + result.getClass() + ".");
      }
 else {
        final Iterable<ExecutionGraph> runningJobs=((RunningJobs)result).asJavaIterable();
        writeJsonForJobs(resp.getWriter(),runningJobs);
      }
    }
  }
 catch (  Exception e) {
    resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
    resp.getWriter().print(e.getMessage());
    if (LOG.isWarnEnabled()) {
      LOG.warn(StringUtils.stringifyException(e));
    }
  }
}
