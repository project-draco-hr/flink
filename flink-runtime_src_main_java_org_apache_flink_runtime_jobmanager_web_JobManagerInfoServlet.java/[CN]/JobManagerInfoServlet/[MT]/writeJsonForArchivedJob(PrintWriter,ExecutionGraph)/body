{
  try {
    wrt.write("[");
    wrt.write("{");
    wrt.write("\"jobid\": \"" + graph.getJobID() + "\",");
    wrt.write("\"jobname\": \"" + graph.getJobName() + "\",");
    wrt.write("\"status\": \"" + graph.getState() + "\",");
    wrt.write("\"SCHEDULED\": " + graph.getStatusTimestamp(JobStatus.CREATED) + ",");
    wrt.write("\"RUNNING\": " + graph.getStatusTimestamp(JobStatus.RUNNING) + ",");
    wrt.write("\"FINISHED\": " + graph.getStatusTimestamp(JobStatus.FINISHED) + ",");
    wrt.write("\"FAILED\": " + graph.getStatusTimestamp(JobStatus.FAILED) + ",");
    wrt.write("\"CANCELED\": " + graph.getStatusTimestamp(JobStatus.CANCELED) + ",");
    if (graph.getState() == JobStatus.FAILED) {
      wrt.write("\"failednodes\": [");
      boolean first=true;
      for (      ExecutionVertex vertex : graph.getAllExecutionVertices()) {
        if (vertex.getExecutionState() == ExecutionState.FAILED) {
          InstanceConnectionInfo location=vertex.getCurrentAssignedResourceLocation();
          Throwable failureCause=vertex.getFailureCause();
          if (location != null || failureCause != null) {
            if (first) {
              first=false;
            }
 else {
              wrt.write(",");
            }
            wrt.write("{");
            wrt.write("\"node\": \"" + (location == null ? "(none)" : location.getFQDNHostname()) + "\",");
            wrt.write("\"message\": \"" + (failureCause == null ? "" : StringUtils.escapeHtml(ExceptionUtils.stringifyException(failureCause))) + "\"");
            wrt.write("}");
          }
        }
      }
      wrt.write("],");
    }
    wrt.write("\"groupvertices\": [");
    boolean first=true;
    for (    ExecutionJobVertex groupVertex : graph.getVerticesTopologically()) {
      if (first) {
        first=false;
      }
 else {
        wrt.write(",");
      }
      wrt.write(JsonFactory.toJson(groupVertex));
    }
    wrt.write("],");
    ExecutionConfig ec=graph.getExecutionConfig();
    if (ec != null) {
      wrt.write("\"executionConfig\": {");
      wrt.write("\"Execution Mode\": \"" + ec.getExecutionMode() + "\",");
      wrt.write("\"Number of execution retries\": \"" + ec.getNumberOfExecutionRetries() + "\",");
      wrt.write("\"Job parallelism\": \"" + ec.getParallelism() + "\",");
      wrt.write("\"Object reuse mode\": \"" + ec.isObjectReuseEnabled() + "\"");
      ExecutionConfig.GlobalJobParameters uc=ec.getGlobalJobParameters();
      if (uc != null) {
        Map<String,String> ucVals=uc.toMap();
        if (ucVals != null) {
          String ucString="{";
          int i=0;
          for (          Map.Entry<String,String> ucVal : ucVals.entrySet()) {
            ucString+="\"" + ucVal.getKey() + "\":\""+ ucVal.getValue()+ "\"";
            if (++i < ucVals.size()) {
              ucString+=",\n";
            }
          }
          wrt.write(", \"userConfig\": " + ucString + "}");
        }
 else {
          LOG.debug("GlobalJobParameters.toMap() did not return anything");
        }
      }
 else {
        LOG.debug("No GlobalJobParameters were set in the execution config");
      }
      wrt.write("},");
    }
 else {
      LOG.warn("Unable to retrieve execution config from execution graph");
    }
    final Future<Object> response=jobmanager.ask(new RequestAccumulatorResultsStringified(graph.getJobID()),timeout);
    Object result;
    try {
      result=Await.result(response,timeout);
    }
 catch (    Exception ex) {
      throw new IOException("Could not retrieve the accumulator results from the job manager.",ex);
    }
    if (result instanceof AccumulatorResultStringsFound) {
      StringifiedAccumulatorResult[] accumulators=((AccumulatorResultStringsFound)result).result();
      wrt.write("\n\"accumulators\": [");
      int i=0;
      for (      StringifiedAccumulatorResult accumulator : accumulators) {
        wrt.write("{ \"name\": \"" + accumulator.getName() + " ("+ accumulator.getType()+ ")\","+ " \"value\": \""+ accumulator.getValue()+ "\"}\n");
        if (++i < accumulators.length) {
          wrt.write(",");
        }
      }
      wrt.write("],\n");
    }
 else     if (result instanceof AccumulatorResultsNotFound) {
      wrt.write("\n\"accumulators\": [],");
    }
 else     if (result instanceof AccumulatorResultsErroneous) {
      LOG.error("Could not obtain accumulators for job " + graph.getJobID(),((AccumulatorResultsErroneous)result).cause());
    }
 else {
      throw new RuntimeException("RequestAccumulatorResults requires a response of type " + "AccumulatorResultStringsFound. Instead the response is of type " + result.getClass() + ".");
    }
    wrt.write("\"groupverticetimes\": {");
    first=true;
    for (    ExecutionJobVertex groupVertex : graph.getVerticesTopologically()) {
      if (first) {
        first=false;
      }
 else {
        wrt.write(",");
      }
      long started=Long.MAX_VALUE;
      long ended=0;
      for (      ExecutionVertex vertex : groupVertex.getTaskVertices()) {
        long running=vertex.getStateTimestamp(ExecutionState.RUNNING);
        if (running != 0 && running < started) {
          started=running;
        }
        long finished=vertex.getStateTimestamp(ExecutionState.FINISHED);
        long canceled=vertex.getStateTimestamp(ExecutionState.CANCELED);
        long failed=vertex.getStateTimestamp(ExecutionState.FAILED);
        if (finished != 0 && finished > ended) {
          ended=finished;
        }
        if (canceled != 0 && canceled > ended) {
          ended=canceled;
        }
        if (failed != 0 && failed > ended) {
          ended=failed;
        }
      }
      wrt.write("\"" + groupVertex.getJobVertexId() + "\": {");
      wrt.write("\"groupvertexid\": \"" + groupVertex.getJobVertexId() + "\",");
      wrt.write("\"groupvertexname\": \"" + groupVertex + "\",");
      wrt.write("\"STARTED\": " + started + ",");
      wrt.write("\"ENDED\": " + ended);
      wrt.write("}");
    }
    wrt.write("}");
    wrt.write("}");
    wrt.write("]");
  }
 catch (  Exception ex) {
    LOG.error("Info server for JobManager: Failed to write json for archived jobs",ex);
  }
}
