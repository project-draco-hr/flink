{
  if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node)) {
    return false;
  }
  final AbstractJobVertex vertex;
  try {
    if (node instanceof SinkPlanNode) {
      vertex=createDataSinkVertex((SinkPlanNode)node);
    }
 else     if (node instanceof SourcePlanNode) {
      vertex=createDataSourceVertex((SourcePlanNode)node);
    }
 else     if (node instanceof BulkIterationPlanNode) {
      BulkIterationPlanNode iterationNode=(BulkIterationPlanNode)node;
      PlanNode root=iterationNode.getRootOfStepFunction();
      if (root.getDegreeOfParallelism() != node.getDegreeOfParallelism() || root.getSubtasksPerInstance() != node.getSubtasksPerInstance()) {
        throw new CompilerException("It is currently not supported that the final operator of the step " + "function has a different degree of parallelism than the iteration operator itself.");
      }
      IterationDescriptor descr=new IterationDescriptor(iterationNode,this.iterationIdEnumerator++);
      this.iterations.put(iterationNode,descr);
      vertex=null;
    }
 else     if (node instanceof SingleInputPlanNode) {
      vertex=createSingleInputVertex((SingleInputPlanNode)node);
    }
 else     if (node instanceof DualInputPlanNode) {
      vertex=createDualInputVertex((DualInputPlanNode)node);
    }
 else     if (node instanceof UnionPlanNode) {
      vertex=null;
    }
 else     if (node instanceof BulkPartialSolutionPlanNode) {
      vertex=createBulkIterationHead((BulkPartialSolutionPlanNode)node);
    }
 else {
      throw new CompilerException("Unrecognized node type: " + node.getClass().getName());
    }
  }
 catch (  Exception e) {
    throw new CompilerException("Error translating node '" + node + "': "+ e.getMessage(),e);
  }
  if (vertex != null) {
    int pd=node.getDegreeOfParallelism();
    vertex.setNumberOfSubtasks(pd);
    if (this.maxDegreeVertex == null || this.maxDegreeVertex.getNumberOfSubtasks() < pd) {
      this.maxDegreeVertex=vertex;
    }
    if (node.getSubtasksPerInstance() >= 1) {
      vertex.setNumberOfSubtasksPerInstance(node.getSubtasksPerInstance());
    }
    if (this.currentIteration != null) {
      PlanNode iterationNode=(PlanNode)this.currentIteration;
      if (iterationNode.getDegreeOfParallelism() != pd) {
        throw new CompilerException("Error: All functions that are part of an iteration must have the same degree-of-parallelism as that iteration.");
      }
      if (iterationNode.getSubtasksPerInstance() != node.getSubtasksPerInstance()) {
        throw new CompilerException("Error: All functions that are part of an iteration must have the same subtasks-per-instance as that iteration.");
      }
      IterationDescriptor descr=this.iterations.get(this.currentIteration);
      new TaskConfig(vertex.getConfiguration()).setIterationId(descr.getId());
    }
    this.vertices.put(node,vertex);
  }
  return true;
}
