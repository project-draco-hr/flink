{
  if (this.vertices.containsKey(node) || this.chainedTasks.containsKey(node)) {
    return false;
  }
  final AbstractJobVertex vertex;
  try {
    if (node instanceof SinkPlanNode) {
      vertex=createDataSinkVertex((SinkPlanNode)node);
    }
 else     if (node instanceof SourcePlanNode) {
      vertex=createDataSourceVertex((SourcePlanNode)node);
    }
 else     if (node instanceof BulkIterationPlanNode) {
      PlanNode root=((BulkIterationPlanNode)node).getRootOfStepFunction();
      if (root.getDegreeOfParallelism() != node.getDegreeOfParallelism() || root.getSubtasksPerInstance() != node.getSubtasksPerInstance()) {
        throw new CompilerException("It is currently not supported that the final operator of the step " + "function has a different degree of parallelism than the iteration operator itself.");
      }
      vertex=null;
    }
 else     if (node instanceof SingleInputPlanNode) {
      vertex=createSingleInputVertex((SingleInputPlanNode)node);
    }
 else     if (node instanceof DualInputPlanNode) {
      vertex=createDualInputVertex((DualInputPlanNode)node);
    }
 else     if (node instanceof UnionPlanNode) {
      vertex=null;
    }
 else     if (node instanceof BulkPartialSolutionPlanNode) {
      vertex=createBulkIterationHead((BulkPartialSolutionPlanNode)node);
    }
 else {
      throw new CompilerException("Unrecognized node type: " + node.getClass().getName());
    }
  }
 catch (  Exception e) {
    throw new CompilerException("Error translating node '" + node + "': "+ e.getMessage(),e);
  }
  if (vertex != null) {
    int pd=node.getDegreeOfParallelism();
    vertex.setNumberOfSubtasks(pd);
    if (this.maxDegreeVertex == null || this.maxDegreeVertex.getNumberOfSubtasks() < pd) {
      this.maxDegreeVertex=vertex;
    }
    if (node.getSubtasksPerInstance() >= 1) {
      vertex.setNumberOfSubtasksPerInstance(node.getSubtasksPerInstance());
    }
    this.vertices.put(node,vertex);
  }
  return true;
}
