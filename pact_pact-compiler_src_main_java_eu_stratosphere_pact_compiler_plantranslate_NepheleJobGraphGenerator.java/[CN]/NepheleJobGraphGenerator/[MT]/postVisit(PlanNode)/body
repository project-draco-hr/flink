{
  try {
    if (node instanceof SourcePlanNode || node instanceof UnionPlanNode) {
      return;
    }
    if (node instanceof IterationPlanNode) {
      if (this.currentIteration != null) {
        throw new CompilerException("Nested Iterations are not possible at the moment!");
      }
      this.currentIteration=(IterationPlanNode)node;
      this.currentIteration.acceptForStepFunction(this);
      this.currentIteration=null;
      return;
    }
    final AbstractJobVertex targetVertex=this.vertices.get(node);
    if (targetVertex == null) {
      final TaskInChain chainedTask;
      if ((chainedTask=this.chainedTasks.get(node)) != null) {
        final Iterator<Channel> inConns=node.getInputs();
        if (!inConns.hasNext()) {
          throw new CompilerException("Bug: Found chained task with no input.");
        }
        final Channel inConn=inConns.next();
        if (inConns.hasNext()) {
          throw new CompilerException("Bug: Found a chained task with more than one input!");
        }
        if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {
          throw new CompilerException("Bug: Found a chained task with an input local strategy.");
        }
        if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {
          throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.");
        }
        AbstractJobVertex container=chainedTask.getContainingVertex();
        if (container == null) {
          final PlanNode sourceNode=inConn.getSource();
          container=this.vertices.get(sourceNode);
          if (container == null) {
            container=this.chainedTasks.get(sourceNode).getContainingVertex();
            if (container == null)             throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.");
          }
 else {
            new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD);
          }
          chainedTask.setContainingVertex(container);
        }
        chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(),0);
        this.chainedTasksInSequence.add(chainedTask);
        return;
      }
 else       if (node instanceof BulkPartialSolutionPlanNode) {
        return;
      }
 else {
        throw new CompilerException("Bug: Unrecognized merged task vertex.");
      }
    }
    final TaskConfig targetVertexConfig=new TaskConfig(targetVertex.getConfiguration());
    final Iterator<Channel> inConns;
    if (node instanceof BulkPartialSolutionPlanNode) {
      inConns=((BulkPartialSolutionPlanNode)node).getContainingIterationNode().getInputs();
      targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0);
    }
 else {
      inConns=node.getInputs();
    }
    if (!inConns.hasNext()) {
      throw new CompilerException("Bug: Found a non-source task with no input.");
    }
    for (int inputIndex=0; inConns.hasNext(); inputIndex++) {
      final Channel input=inConns.next();
      final PlanNode inputPlanNode=input.getSource();
      final Iterator<Channel> allInChannels;
      if (inputPlanNode instanceof UnionPlanNode) {
        allInChannels=((UnionPlanNode)inputPlanNode).getListOfInputs().iterator();
      }
 else       if (inputPlanNode instanceof BulkPartialSolutionPlanNode) {
        if (this.vertices.get(inputPlanNode) == null) {
          final BulkPartialSolutionPlanNode pspn=(BulkPartialSolutionPlanNode)inputPlanNode;
          final BulkIterationPlanNode iterationNode=pspn.getContainingIterationNode();
          if (iterationNode.getInput().getSource() instanceof UnionPlanNode) {
            allInChannels=((UnionPlanNode)iterationNode.getInput().getSource()).getInputs();
          }
 else {
            allInChannels=Collections.singletonList(iterationNode.getInput()).iterator();
          }
          targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(inputIndex);
        }
 else {
          allInChannels=Collections.singletonList(input).iterator();
        }
      }
 else {
        allInChannels=Collections.singletonList(input).iterator();
      }
      TypeSerializerFactory<?> typeSerFact=null;
      int numChannelsTotal=0;
      int numChannelsDynamicPath=0;
      int numDynamicSenderTasksTotal=0;
      while (allInChannels.hasNext()) {
        final Channel inConn=allInChannels.next();
        if (typeSerFact == null) {
          typeSerFact=inConn.getSerializer();
        }
 else         if (!typeSerFact.equals(inConn.getSerializer())) {
          throw new CompilerException("Conflicting types in union operator.");
        }
        final PlanNode sourceNode=inConn.getSource();
        AbstractJobVertex sourceVertex=this.vertices.get(sourceNode);
        TaskConfig sourceVertexConfig;
        if (sourceVertex == null) {
          final TaskInChain chainedTask;
          final IterationDescriptor iteration;
          if ((chainedTask=this.chainedTasks.get(sourceNode)) != null) {
            if (chainedTask.getContainingVertex() == null)             throw new IllegalStateException("Bug: Chained task has not been assigned its containing vertex when connecting.");
            sourceVertex=chainedTask.getContainingVertex();
            sourceVertexConfig=chainedTask.getTaskConfig();
          }
 else           if ((iteration=this.iterations.get(sourceNode)) != null) {
            sourceVertex=iteration.getHeadTask();
            sourceVertexConfig=iteration.getHeadFinalResultConfig();
          }
 else {
            throw new CompilerException("Bug: Could not resolve source node for a channel.");
          }
        }
 else {
          sourceVertexConfig=new TaskConfig(sourceVertex.getConfiguration());
        }
        DistributionPattern pattern=connectJobVertices(inConn,inputIndex,sourceVertex,sourceVertexConfig,targetVertex,targetVertexConfig);
        numChannelsTotal++;
        if (inConn.isOnDynamicPath()) {
          numChannelsDynamicPath++;
          numDynamicSenderTasksTotal+=getNumberOfSendersPerReceiver(pattern,sourceVertex.getNumberOfSubtasks(),targetVertex.getNumberOfSubtasks());
        }
      }
      if (numChannelsDynamicPath > 0 && numChannelsTotal != numChannelsDynamicPath) {
        throw new CompilerException("Error: It is currently not supported to union between dynamic and static path in an iteration.");
      }
      if (numDynamicSenderTasksTotal > 0) {
        targetVertexConfig.setGateIterativeWithNumberOfEventsUntilInterrupt(inputIndex,numDynamicSenderTasksTotal);
      }
      addLocalInfoFromChannelToConfig(input,targetVertexConfig,inputIndex);
    }
  }
 catch (  Exception e) {
    throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
  }
}
