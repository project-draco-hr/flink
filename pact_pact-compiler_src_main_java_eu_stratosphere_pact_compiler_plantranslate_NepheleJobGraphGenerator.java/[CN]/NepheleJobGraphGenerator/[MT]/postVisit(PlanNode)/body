{
  try {
    if (node instanceof SourcePlanNode || node instanceof NAryUnionPlanNode) {
      return;
    }
    if (node instanceof IterationPlanNode) {
      if (this.currentIteration != null) {
        throw new CompilerException("Nested Iterations are not possible at the moment!");
      }
      this.currentIteration=(IterationPlanNode)node;
      this.currentIteration.acceptForStepFunction(this);
      this.currentIteration=null;
      if (node instanceof WorksetIterationPlanNode) {
        WorksetIterationPlanNode wsNode=(WorksetIterationPlanNode)node;
        AbstractJobVertex headVertex=this.iterations.get(wsNode).getHeadTask();
        TaskConfig headConfig=new TaskConfig(headVertex.getConfiguration());
        int inputIndex=headConfig.getDriverStrategy().getNumInputs();
        headConfig.setIterationHeadSolutionSetInputIndex(inputIndex);
        translateChannel(wsNode.getInitialSolutionSetInput(),inputIndex,headVertex,headConfig);
      }
      return;
    }
 else     if (node instanceof SolutionSetPlanNode) {
      if (node.getOutgoingChannels().size() != 1) {
        throw new CompilerException("Currently, only one join with the solution set is allowed.");
      }
      Channel c=node.getOutgoingChannels().get(0);
      DualInputPlanNode target=(DualInputPlanNode)c.getTarget();
      AbstractJobVertex accessingVertex=this.vertices.get(target);
      TaskConfig conf=new TaskConfig(accessingVertex.getConfiguration());
      int inputNum=c == target.getInput1() ? 0 : c == target.getInput2() ? 1 : -1;
      if (inputNum == -1) {
        throw new CompilerException();
      }
      if (conf.getDriver().equals(MatchDriver.class)) {
        conf.setDriver(inputNum == 0 ? SolutionSetFirstJoinDriver.class : SolutionSetSecondJoinDriver.class);
      }
 else       if (conf.getDriver().equals(CoGroupDriver.class)) {
        conf.setDriver(inputNum == 0 ? SolutionSetFirstCoGroupDriver.class : SolutionSetSecondCoGroupDriver.class);
      }
 else {
        throw new CompilerException("Found join with solution set using incompatible operator (only Match/CoGroup are valid.");
      }
      conf.setSolutionSetSerializer(((SolutionSetPlanNode)node).getContainingIterationNode().getSolutionSetSerializer());
      IterationDescriptor iter=this.iterations.get(((SolutionSetPlanNode)node).getContainingIterationNode());
      TaskConfig headConf=iter.getHeadConfig();
      TypeSerializerFactory<?> otherSerializer;
      TypeComparatorFactory<?> otherComparator;
      if (inputNum == 0) {
        otherSerializer=target.getInput2().getSerializer();
        otherComparator=target.getComparator2();
      }
 else {
        otherSerializer=target.getInput1().getSerializer();
        otherComparator=target.getComparator1();
      }
      headConf.setSolutionSetProberSerializer(otherSerializer);
      headConf.setSolutionSetProberComparator(otherComparator);
      headConf.setSolutionSetPairComparator(target.getPairComparator());
      return;
    }
    final AbstractJobVertex targetVertex=this.vertices.get(node);
    if (targetVertex == null) {
      final TaskInChain chainedTask;
      if ((chainedTask=this.chainedTasks.get(node)) != null) {
        final Iterator<Channel> inConns=node.getInputs();
        if (!inConns.hasNext()) {
          throw new CompilerException("Bug: Found chained task with no input.");
        }
        final Channel inConn=inConns.next();
        if (inConns.hasNext()) {
          throw new CompilerException("Bug: Found a chained task with more than one input!");
        }
        if (inConn.getLocalStrategy() != null && inConn.getLocalStrategy() != LocalStrategy.NONE) {
          throw new CompilerException("Bug: Found a chained task with an input local strategy.");
        }
        if (inConn.getShipStrategy() != null && inConn.getShipStrategy() != ShipStrategyType.FORWARD) {
          throw new CompilerException("Bug: Found a chained task with an input ship strategy other than FORWARD.");
        }
        AbstractJobVertex container=chainedTask.getContainingVertex();
        if (container == null) {
          final PlanNode sourceNode=inConn.getSource();
          container=this.vertices.get(sourceNode);
          if (container == null) {
            container=this.chainedTasks.get(sourceNode).getContainingVertex();
            if (container == null)             throw new IllegalStateException("Bug: Chained task predecessor has not been assigned its containing vertex.");
          }
 else {
            new TaskConfig(container.getConfiguration()).addOutputShipStrategy(ShipStrategyType.FORWARD);
          }
          chainedTask.setContainingVertex(container);
        }
        chainedTask.getTaskConfig().setInputSerializer(inConn.getSerializer(),0);
        this.chainedTasksInSequence.add(chainedTask);
        return;
      }
 else       if (node instanceof BulkPartialSolutionPlanNode || node instanceof WorksetPlanNode) {
        return;
      }
 else {
        throw new CompilerException("Bug: Unrecognized merged task vertex.");
      }
    }
    final TaskConfig targetVertexConfig=new TaskConfig(targetVertex.getConfiguration());
    final Iterator<Channel> inConns;
    if (node instanceof BulkPartialSolutionPlanNode) {
      inConns=((BulkPartialSolutionPlanNode)node).getContainingIterationNode().getInputs();
      targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0);
    }
 else     if (node instanceof WorksetPlanNode) {
      WorksetPlanNode wspn=(WorksetPlanNode)node;
      inConns=Collections.singleton(wspn.getContainingIterationNode().getInput2()).iterator();
      targetVertexConfig.setIterationHeadPartialSolutionOrWorksetInputIndex(0);
      targetVertexConfig.setIterationHeadSolutionSetInputIndex(1);
    }
 else {
      inConns=node.getInputs();
    }
    if (!inConns.hasNext()) {
      throw new CompilerException("Bug: Found a non-source task with no input.");
    }
    int inputIndex=0;
    while (inConns.hasNext()) {
      Channel input=inConns.next();
      inputIndex+=translateChannel(input,inputIndex,targetVertex,targetVertexConfig);
    }
  }
 catch (  Exception e) {
    throw new CompilerException("An error occurred while translating the optimized plan to a nephele JobGraph: " + e.getMessage(),e);
  }
}
