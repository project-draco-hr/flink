{
  final String taskName=node.getPactContract().getName();
  final DriverStrategy ds=node.getDriverStrategy();
  boolean chaining=false;
{
    Channel inConn=node.getInput();
    PlanNode pred=inConn.getSource();
    chaining=ds.getPushChainDriverClass() != null && !(pred instanceof UnionPlanNode) && !(pred instanceof BulkPartialSolutionPlanNode) && inConn.getShipStrategy() == ShipStrategyType.FORWARD && inConn.getLocalStrategy() == LocalStrategy.NONE && pred.getOutgoingChannels().size() == 1 && node.getDegreeOfParallelism() == pred.getDegreeOfParallelism() && node.getSubtasksPerInstance() == pred.getSubtasksPerInstance();
  }
  final JobTaskVertex vertex;
  final TaskConfig config;
  if (chaining) {
    vertex=null;
    config=new TaskConfig(new Configuration());
    this.chainedTasks.put(node,new TaskInChain(ds.getPushChainDriverClass(),config,taskName));
  }
 else {
    vertex=new JobTaskVertex(taskName,this.jobGraph);
    vertex.setTaskClass(this.currentIteration == null ? RegularPactTask.class : IterationIntermediatePactTask.class);
    config=new TaskConfig(vertex.getConfiguration());
    config.setDriver(ds.getDriverClass());
  }
  config.setStubWrapper(node.getPactContract().getUserCodeWrapper());
  config.setStubParameters(node.getPactContract().getParameters());
  config.setDriverStrategy(ds);
  if (node.getComparator() != null) {
    config.setDriverComparator(node.getComparator(),0);
  }
  assignDriverResources(node,config);
  return vertex;
}
