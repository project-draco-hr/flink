{
  final BulkIterationPlanNode bulkNode=(BulkIterationPlanNode)descr.getIterationNode();
  final JobTaskVertex headVertex=descr.getHeadTask();
  final TaskConfig headConfig=new TaskConfig(headVertex.getConfiguration());
  final TaskConfig headFinalOutputConfig=descr.getHeadFinalResultConfig();
  final int numStepFunctionOuts=headConfig.getNumOutputs();
  final int numFinalOuts=headFinalOutputConfig.getNumOutputs();
  headConfig.setIterationHeadFinalOutputConfig(headFinalOutputConfig);
  headConfig.setIterationHeadIndexOfSyncOutput(numStepFunctionOuts + numFinalOuts);
  final long memForBackChannel=bulkNode.getMemoryPerSubTask();
  if (memForBackChannel <= 0) {
    throw new CompilerException("Bug: No memory has been assigned to the iteration back channel.");
  }
  headConfig.setBackChannelMemory(memForBackChannel);
  final JobOutputVertex sync=new JobOutputVertex("Bulk-Iteration Sync (" + bulkNode.getPactContract().getName() + ")",this.jobGraph);
  sync.setOutputClass(IterationSynchronizationSinkTask.class);
  sync.setNumberOfSubtasks(1);
  this.auxVertices.add(sync);
  final TaskConfig syncConfig=new TaskConfig(sync.getConfiguration());
  syncConfig.setGateIterativeWithNumberOfEventsUntilInterrupt(0,headVertex.getNumberOfSubtasks());
  final int maxNumIterations=bulkNode.getIterationNode().getIterationContract().getMaximumNumberOfIterations();
  if (maxNumIterations < 1) {
    throw new CompilerException("Cannot create bulk iteration with unspecified maximum number of iterations");
  }
  syncConfig.setNumberOfIterations(maxNumIterations);
  try {
    headVertex.connectTo(sync,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION,DistributionPattern.POINTWISE);
  }
 catch (  JobGraphDefinitionException e) {
    throw new CompilerException("Bug: Cannot connect head vertex to sync task.");
  }
  final PlanNode rootOfStepFunction=bulkNode.getRootOfStepFunction();
  final TaskConfig tailConfig;
  JobTaskVertex rootOfStepFunctionVertex=(JobTaskVertex)this.vertices.get(rootOfStepFunction);
  if (rootOfStepFunctionVertex == null) {
    final TaskInChain taskInChain=this.chainedTasks.get(rootOfStepFunction);
    if (taskInChain == null) {
      throw new CompilerException("Bug: Tail of step function not found as vertex or chaine task.");
    }
    rootOfStepFunctionVertex=(JobTaskVertex)taskInChain.getContainingVertex();
    tailConfig=taskInChain.getTaskConfig();
  }
 else {
    tailConfig=new TaskConfig(rootOfStepFunctionVertex.getConfiguration());
  }
  rootOfStepFunctionVertex.setTaskClass(IterationTailPactTask.class);
  tailConfig.setOutputSerializer(bulkNode.getSerializerForIterationChannel());
  JobOutputVertex fakeTail=new JobOutputVertex("Fake Tail",this.jobGraph);
  fakeTail.setOutputClass(FakeOutputTask.class);
  fakeTail.setNumberOfSubtasks(headVertex.getNumberOfSubtasks());
  fakeTail.setNumberOfSubtasksPerInstance(headVertex.getNumberOfSubtasksPerInstance());
  this.auxVertices.add(fakeTail);
  try {
    rootOfStepFunctionVertex.connectTo(fakeTail,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION,DistributionPattern.POINTWISE);
  }
 catch (  JobGraphDefinitionException e) {
    throw new CompilerException("Bug: Cannot connect iteration tail vertex fake tail task");
  }
  tailConfig.addOutputShipStrategy(ShipStrategyType.FORWARD);
  AggregatorRegistry aggs=bulkNode.getIterationNode().getIterationContract().getAggregators();
  Collection<AggregatorWithName<?>> allAggregators=aggs.getAllRegisteredAggregators();
  headConfig.addIterationAggregators(allAggregators);
  syncConfig.addIterationAggregators(allAggregators);
  String convAggName=aggs.getConvergenceCriterionAggregatorName();
  Class<? extends ConvergenceCriterion<?>> convCriterion=aggs.getConvergenceCriterion();
  if (convCriterion != null || convAggName != null) {
    if (convCriterion == null) {
      throw new CompilerException("Error: Convergence criterion aggregator set, but criterion is null.");
    }
    if (convAggName == null) {
      throw new CompilerException("Error: Aggregator convergence criterion set, but aggregator is null.");
    }
    syncConfig.setConvergenceCriterion(convAggName,convCriterion);
  }
}
