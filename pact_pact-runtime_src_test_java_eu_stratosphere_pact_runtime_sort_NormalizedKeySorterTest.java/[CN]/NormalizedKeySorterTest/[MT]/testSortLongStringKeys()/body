{
  final int numSegments=MEMORY_SIZE / MEMORY_PAGE_SIZE;
  final List<MemorySegment> memory=this.memoryManager.allocatePages(new DummyInvokable(),numSegments);
  @SuppressWarnings("unchecked") PactRecordComparator accessors=new PactRecordComparator(new int[]{1},new Class[]{Value.class});
  NormalizedKeySorter<PactRecord> sorter=new NormalizedKeySorter<PactRecord>(PactRecordSerializer.get(),accessors,memory);
  TestData.Generator generator=new TestData.Generator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.FIX_LENGTH);
  PactRecord record=new PactRecord();
  do {
    generator.next(record);
  }
 while (sorter.write(record));
  QuickSort qs=new QuickSort();
  qs.sort(sorter);
  MutableObjectIterator<PactRecord> iter=sorter.getIterator();
  PactRecord readTarget=new PactRecord();
  Value current=new Value();
  Value last=new Value();
  iter.next(readTarget);
  readTarget.getFieldInto(1,last);
  while (iter.next(readTarget)) {
    readTarget.getFieldInto(1,current);
    final int cmp=last.compareTo(current);
    if (cmp > 0)     Assert.fail("Next value is not larger or equal to previous value.");
    Value tmp=current;
    current=last;
    last=tmp;
  }
  this.memoryManager.release(sorter.dispose());
}
