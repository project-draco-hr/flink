{
  StringValue str=this.theString;
  if (this.getDelimiter() != null && this.getDelimiter().length == 1 && this.getDelimiter()[0] == NEW_LINE && offset + numBytes >= 1 && bytes[offset + numBytes - 1] == CARRIAGE_RETURN) {
    numBytes-=1;
  }
  if (this.ascii) {
    str.setValueAscii(bytes,offset,numBytes);
  }
 else {
    ByteBuffer byteWrapper=this.byteWrapper;
    if (bytes != byteWrapper.array()) {
      byteWrapper=ByteBuffer.wrap(bytes,0,bytes.length);
      this.byteWrapper=byteWrapper;
    }
    byteWrapper.limit(offset + numBytes);
    byteWrapper.position(offset);
    try {
      CharBuffer result=this.decoder.decode(byteWrapper);
      str.setValue(result);
    }
 catch (    CharacterCodingException e) {
      byte[] copy=new byte[numBytes];
      System.arraycopy(bytes,offset,copy,0,numBytes);
      LOG.warn("Line could not be encoded: " + Arrays.toString(copy),e);
      return null;
    }
  }
  reuse.clear();
  reuse.setField(this.pos,str);
  return reuse;
}
