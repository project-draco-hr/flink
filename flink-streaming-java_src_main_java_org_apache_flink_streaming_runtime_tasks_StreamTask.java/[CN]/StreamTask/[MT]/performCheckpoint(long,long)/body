{
  LOG.debug("Starting checkpoint {} on task {}",checkpointId,getName());
synchronized (lock) {
    if (isRunning) {
      operatorChain.broadcastCheckpointBarrier(checkpointId,timestamp);
      final StreamOperator<?>[] allOperators=operatorChain.getAllOperators();
      final List<StreamStateHandle> nonPartitionedStates=Arrays.asList(new StreamStateHandle[allOperators.length]);
      for (int i=0; i < allOperators.length; i++) {
        StreamOperator<?> operator=allOperators[i];
        if (operator != null) {
          CheckpointStreamFactory streamFactory=stateBackend.createStreamFactory(getEnvironment().getJobID(),createOperatorIdentifier(operator,configuration.getVertexID()));
          CheckpointStreamFactory.CheckpointStateOutputStream outStream=streamFactory.createCheckpointStateOutputStream(checkpointId,timestamp);
          operator.snapshotState(outStream,checkpointId,timestamp);
          nonPartitionedStates.set(i,outStream.closeAndGetHandle());
        }
      }
      RunnableFuture<KeyGroupsStateHandle> keyGroupsStateHandleFuture=null;
      if (keyedStateBackend != null) {
        CheckpointStreamFactory streamFactory=stateBackend.createStreamFactory(getEnvironment().getJobID(),createOperatorIdentifier(headOperator,configuration.getVertexID()));
        keyGroupsStateHandleFuture=keyedStateBackend.snapshot(checkpointId,timestamp,streamFactory);
      }
      ChainedStateHandle<StreamStateHandle> chainedStateHandles=new ChainedStateHandle<>(nonPartitionedStates);
      LOG.debug("Finished synchronous checkpoints for checkpoint {} on task {}",checkpointId,getName());
      AsyncCheckpointRunnable asyncCheckpointRunnable=new AsyncCheckpointRunnable("checkpoint-" + checkpointId + "-"+ timestamp,this,cancelables,chainedStateHandles,keyGroupsStateHandleFuture,checkpointId);
synchronized (cancelables) {
        cancelables.add(asyncCheckpointRunnable);
      }
      asyncOperationsThreadPool.submit(asyncCheckpointRunnable);
      return true;
    }
 else {
      return false;
    }
  }
}
