{
  LOG.debug("Starting checkpoint {} on task {}",checkpointId,getName());
synchronized (lock) {
    if (isRunning) {
      operatorChain.broadcastCheckpointBarrier(checkpointId,timestamp);
      final StreamOperator<?>[] allOperators=operatorChain.getAllOperators();
      final List<StreamStateHandle> nonPartitionedStates=Arrays.asList(new StreamStateHandle[allOperators.length]);
      for (int i=0; i < allOperators.length; i++) {
        StreamOperator<?> operator=allOperators[i];
        if (operator != null) {
          AbstractStateBackend.CheckpointStateOutputStream outStream=((AbstractStreamOperator)operator).getStateBackend().createCheckpointStateOutputStream(checkpointId,timestamp);
          operator.snapshotState(outStream,checkpointId,timestamp);
          nonPartitionedStates.set(i,outStream.closeAndGetHandle());
        }
      }
      if (!isRunning) {
        throw new CancelTaskException();
      }
      ChainedStateHandle<StreamStateHandle> states=new ChainedStateHandle<>(nonPartitionedStates);
      List<KeyGroupsStateHandle> keyedStates=Collections.<KeyGroupsStateHandle>emptyList();
      if (states.isEmpty() && keyedStates.isEmpty()) {
        getEnvironment().acknowledgeCheckpoint(checkpointId);
      }
 else {
        this.lastCheckpointSize=states.getStateSize();
        getEnvironment().acknowledgeCheckpoint(checkpointId,states,keyedStates);
      }
      return true;
    }
 else {
      return false;
    }
  }
}
