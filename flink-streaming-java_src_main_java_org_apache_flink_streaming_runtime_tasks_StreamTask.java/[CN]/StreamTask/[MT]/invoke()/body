{
  LOG.debug("Initializing {}",getName());
  boolean initializationCompleted=false;
  try {
    AccumulatorRegistry accumulatorRegistry=getEnvironment().getAccumulatorRegistry();
    userClassLoader=getUserCodeClassLoader();
    configuration=new StreamConfig(getTaskConfiguration());
    accumulatorMap=accumulatorRegistry.getUserMap();
    headOperator=configuration.getStreamOperator(userClassLoader);
    operatorChain=new OperatorChain<>(this,headOperator,accumulatorRegistry.getReadWriteReporter());
    if (headOperator != null) {
      headOperator.setup(this,configuration,operatorChain.getChainEntryPoint());
    }
    timerService=Executors.newSingleThreadScheduledExecutor(new DispatcherThreadFactory(TRIGGER_THREAD_GROUP,"Time Trigger for " + getName()));
    asyncCheckpointThreads=new HashSet<>();
    init();
    initializationCompleted=true;
  }
  finally {
    if (!initializationCompleted) {
      if (timerService != null) {
        timerService.shutdownNow();
      }
      if (operatorChain != null) {
        operatorChain.releaseOutputs();
      }
    }
  }
  LOG.debug("Invoking {}",getName());
  boolean disposed=false;
  try {
    stateBackend=createStateBackend();
    stateBackend.initializeForJob(getEnvironment());
    restoreStateLazy();
synchronized (lock) {
      openAllOperators();
    }
    isRunning=true;
    run();
    isRunning=false;
    if (LOG.isDebugEnabled()) {
      LOG.debug("Finished task {}",getName());
    }
synchronized (lock) {
      closeAllOperators();
    }
    operatorChain.flushOutputs();
    tryDisposeAllOperators();
    disposed=true;
  }
  finally {
    isRunning=false;
    timerService.shutdownNow();
    for (    Thread checkpointThread : asyncCheckpointThreads) {
      checkpointThread.interrupt();
    }
    asyncCheckpointThreads.clear();
    if (operatorChain != null) {
      operatorChain.releaseOutputs();
    }
    try {
      cleanup();
    }
 catch (    Throwable t) {
      LOG.error("Error during cleanup of stream task.");
    }
    if (!disposed) {
      disposeAllOperators();
    }
    try {
      if (stateBackend != null) {
        stateBackend.close();
      }
    }
 catch (    Throwable t) {
      LOG.error("Error while closing the state backend",t);
    }
  }
}
