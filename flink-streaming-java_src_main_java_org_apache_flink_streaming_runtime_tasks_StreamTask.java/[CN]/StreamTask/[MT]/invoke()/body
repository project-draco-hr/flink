{
  boolean disposed=false;
  try {
    LOG.debug("Initializing {}",getName());
    userClassLoader=getUserCodeClassLoader();
    configuration=new StreamConfig(getTaskConfiguration());
    accumulatorMap=getEnvironment().getAccumulatorRegistry().getUserMap();
    if (timerService == null) {
      ScheduledThreadPoolExecutor executor=new ScheduledThreadPoolExecutor(1,new DispatcherThreadFactory(TRIGGER_THREAD_GROUP,"Time Trigger for " + getName()));
      executor.setRemoveOnCancelPolicy(true);
      timerService=DefaultTimeServiceProvider.create(executor);
    }
    headOperator=configuration.getStreamOperator(userClassLoader);
    operatorChain=new OperatorChain<>(this,headOperator,getEnvironment().getAccumulatorRegistry().getReadWriteReporter());
    if (headOperator != null) {
      headOperator.setup(this,configuration,operatorChain.getChainEntryPoint());
    }
    getEnvironment().getMetricGroup().gauge("lastCheckpointSize",new Gauge<Long>(){
      @Override public Long getValue(){
        return StreamTask.this.lastCheckpointSize;
      }
    }
);
    init();
    if (canceled) {
      throw new CancelTaskException();
    }
    LOG.debug("Invoking {}",getName());
    restoreState();
    lazyRestoreChainedOperatorState=null;
    lazyRestoreKeyGroupStates=null;
synchronized (lock) {
      openAllOperators();
    }
    if (canceled) {
      throw new CancelTaskException();
    }
    isRunning=true;
    run();
    LOG.debug("Finished task {}",getName());
synchronized (lock) {
      isRunning=false;
      closeAllOperators();
    }
    LOG.debug("Closed operators for task {}",getName());
    operatorChain.flushOutputs();
    tryDisposeAllOperators();
    disposed=true;
  }
  finally {
    isRunning=false;
    if (timerService != null) {
      try {
        timerService.shutdownService();
      }
 catch (      Throwable t) {
        LOG.error("Could not shut down timer service",t);
      }
    }
    try {
      closeAllClosables();
    }
 catch (    Throwable t) {
      LOG.error("Could not shut down async checkpoint threads",t);
    }
    if (operatorChain != null) {
      operatorChain.releaseOutputs();
    }
    try {
      cleanup();
    }
 catch (    Throwable t) {
      LOG.error("Error during cleanup of stream task",t);
    }
    if (!disposed) {
      disposeAllOperators();
    }
  }
}
