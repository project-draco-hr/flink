{
  LOG.debug("Starting checkpoint {} on task {}",checkpointId,getName());
synchronized (lock) {
    if (isRunning) {
      operatorChain.broadcastCheckpointBarrier(checkpointId,timestamp);
      final StreamOperator<?>[] allOperators=operatorChain.getAllOperators();
      final StreamTaskState[] states=new StreamTaskState[allOperators.length];
      boolean hasAsyncStates=false;
      for (int i=0; i < states.length; i++) {
        StreamOperator<?> operator=allOperators[i];
        if (operator != null) {
          StreamTaskState state=operator.snapshotOperatorState(checkpointId,timestamp);
          if (state.getOperatorState() instanceof AsynchronousStateHandle) {
            hasAsyncStates=true;
          }
          if (state.getFunctionState() instanceof AsynchronousStateHandle) {
            hasAsyncStates=true;
          }
          states[i]=state.isEmpty() ? null : state;
        }
      }
      if (!isRunning) {
        throw new CancelTaskException();
      }
      StreamTaskStateList allStates=new StreamTaskStateList(states);
      if (allStates.isEmpty()) {
        getEnvironment().acknowledgeCheckpoint(checkpointId);
      }
 else       if (!hasAsyncStates) {
        getEnvironment().acknowledgeCheckpoint(checkpointId,allStates);
      }
 else {
        String threadName="Materialize checkpoint state " + checkpointId + " - "+ getName();
        Thread checkpointThread=new Thread(threadName){
          @Override public void run(){
            try {
              for (              StreamTaskState state : states) {
                if (state != null) {
                  if (state.getFunctionState() instanceof AsynchronousStateHandle) {
                    AsynchronousStateHandle<Serializable> asyncState=(AsynchronousStateHandle<Serializable>)state.getFunctionState();
                    state.setFunctionState(asyncState.materialize());
                  }
                  if (state.getOperatorState() instanceof AsynchronousStateHandle) {
                    AsynchronousStateHandle<?> asyncState=(AsynchronousStateHandle<?>)state.getOperatorState();
                    state.setOperatorState(asyncState.materialize());
                  }
                }
              }
              StreamTaskStateList allStates=new StreamTaskStateList(states);
              getEnvironment().acknowledgeCheckpoint(checkpointId,allStates);
            }
 catch (            Exception e) {
              if (isRunning()) {
                LOG.error("Caught exception while materializing asynchronous checkpoints.",e);
              }
              if (asyncException == null) {
                asyncException=new AsynchronousException(e);
              }
            }
            asyncCheckpointThreads.remove(this);
            LOG.debug("Finished asynchronous checkpoints for checkpoint {} on task {}",checkpointId,getName());
          }
        }
;
        asyncCheckpointThreads.add(checkpointThread);
        checkpointThread.setDaemon(true);
        checkpointThread.start();
      }
      return true;
    }
 else {
      return false;
    }
  }
}
