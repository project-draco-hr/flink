{
  final int INPUT_1_SIZE=200;
  final int INPUT_2_SIZE=100;
  final int INPUT_1_DUPLICATES=10;
  final int INPUT_2_DUPLICATES=4000;
  final int DUPLICATE_KEY=13;
  try {
    final TestData.Generator generator1=new Generator(SEED1,500,4096,KeyMode.SORTED,ValueMode.RANDOM_LENGTH);
    final TestData.Generator generator2=new Generator(SEED2,500,2048,KeyMode.SORTED,ValueMode.RANDOM_LENGTH);
    final TestData.GeneratorIterator gen1Iter=new TestData.GeneratorIterator(generator1,INPUT_1_SIZE);
    final TestData.GeneratorIterator gen2Iter=new TestData.GeneratorIterator(generator2,INPUT_2_SIZE);
    final TestData.ConstantValueIterator const1Iter=new TestData.ConstantValueIterator(DUPLICATE_KEY,"LEFT String for Duplicate Keys",INPUT_1_DUPLICATES);
    final TestData.ConstantValueIterator const2Iter=new TestData.ConstantValueIterator(DUPLICATE_KEY,"RIGHT String for Duplicate Keys",INPUT_2_DUPLICATES);
    final List<MutableObjectIterator<Record>> inList1=new ArrayList<MutableObjectIterator<Record>>();
    inList1.add(gen1Iter);
    inList1.add(const1Iter);
    final List<MutableObjectIterator<Record>> inList2=new ArrayList<MutableObjectIterator<Record>>();
    inList2.add(gen2Iter);
    inList2.add(const2Iter);
    MutableObjectIterator<Record> input1=new MergeIterator<Record>(inList1,serializer1,comparator1.duplicate());
    MutableObjectIterator<Record> input2=new MergeIterator<Record>(inList2,serializer2,comparator2.duplicate());
    final Map<TestData.Key,Collection<Match>> expectedMatchesMap=matchValues(collectData(input1),collectData(input2));
    generator1.reset();
    generator2.reset();
    const1Iter.reset();
    const2Iter.reset();
    gen1Iter.reset();
    gen2Iter.reset();
    inList1.clear();
    inList1.add(gen1Iter);
    inList1.add(const1Iter);
    inList2.clear();
    inList2.add(gen2Iter);
    inList2.add(const2Iter);
    input1=new MergeIterator<Record>(inList1,serializer1,comparator1.duplicate());
    input2=new MergeIterator<Record>(inList2,serializer2,comparator2.duplicate());
    final JoinFunction matcher=new MatchRemovingMatcher(expectedMatchesMap);
    final Collector<Record> collector=new DiscardingOutputCollector<Record>();
    NonReusingMergeMatchIterator<Record,Record,Record> iterator=new NonReusingMergeMatchIterator<Record,Record,Record>(input1,input2,this.serializer1,this.comparator1,this.serializer2,this.comparator2,this.pairComparator,this.memoryManager,this.ioManager,PAGES_FOR_BNLJN,this.parentTask);
    iterator.open();
    while (iterator.callWithNextKey(matcher,collector))     ;
    iterator.close();
    for (    Entry<TestData.Key,Collection<Match>> entry : expectedMatchesMap.entrySet()) {
      if (!entry.getValue().isEmpty()) {
        Assert.fail("Collection for key " + entry.getKey() + " is not empty");
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail("An exception occurred during the test: " + e.getMessage());
  }
}
