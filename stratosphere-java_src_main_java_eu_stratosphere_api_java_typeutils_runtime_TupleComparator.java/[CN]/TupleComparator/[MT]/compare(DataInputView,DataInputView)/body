{
  boolean[] fieldUsedAsKey=new boolean[this.comparators.length + this.serializer.length];
  for (  int keyPosition : keyPositions) {
    fieldUsedAsKey[keyPosition]=true;
  }
  int nextKeyPositionIndex=0;
  int totalLength=this.comparators.length + this.serializer.length;
  int[] cmpCache=new int[totalLength];
  boolean[] cmpWasCached=new boolean[totalLength];
  int comparatorIndex=0;
  int serializerIndex=0;
  int fieldIndex=0;
  try {
    for (; fieldIndex < totalLength; fieldIndex++) {
      if (fieldUsedAsKey[fieldIndex]) {
        int cmp=this.comparators[comparatorIndex].compare(firstSource,secondSource);
        comparatorIndex++;
        if (fieldIndex == keyPositions[nextKeyPositionIndex]) {
          if (cmp != 0) {
            return cmp;
          }
          nextKeyPositionIndex++;
          if (nextKeyPositionIndex == this.comparators.length) {
            return 0;
          }
          while (cmpWasCached[keyPositions[nextKeyPositionIndex]]) {
            if (cmpCache[keyPositions[nextKeyPositionIndex]] != 0) {
              return cmpCache[keyPositions[nextKeyPositionIndex]];
            }
            nextKeyPositionIndex++;
            if (nextKeyPositionIndex == this.comparators.length) {
              return 0;
            }
          }
        }
 else {
          cmpCache[fieldIndex]=cmp;
          cmpWasCached[fieldIndex]=true;
        }
        if (nextKeyPositionIndex == keyPositions.length) {
          return 0;
        }
      }
 else {
        this.serializer[serializerIndex].deserialize(this.serializer[serializerIndex].createInstance(),firstSource);
        this.serializer[serializerIndex].deserialize(this.serializer[serializerIndex].createInstance(),secondSource);
        serializerIndex++;
      }
    }
    return 0;
  }
 catch (  NullPointerException npex) {
    throw new NullKeyFieldException(fieldIndex);
  }
catch (  IndexOutOfBoundsException iobex) {
    throw new KeyFieldOutOfBoundsException(fieldIndex);
  }
}
