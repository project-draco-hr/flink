{
  StreamNode vertex=streamGraph.getStreamNode(vertexID);
  config.setVertexID(vertexID);
  config.setBufferTimeout(vertex.getBufferTimeout());
  config.setTypeSerializerIn1(vertex.getTypeSerializerIn1());
  config.setTypeSerializerIn2(vertex.getTypeSerializerIn2());
  config.setTypeSerializerOut1(vertex.getTypeSerializerOut());
  config.setStreamOperator(vertex.getOperator());
  config.setOutputSelectorWrapper(vertex.getOutputSelectorWrapper());
  config.setNumberOfOutputs(nonChainableOutputs.size());
  config.setNonChainedOutputs(nonChainableOutputs);
  config.setChainedOutputs(chainableOutputs);
  config.setStateMonitoring(streamGraph.isCheckpointingEnabled());
  config.setStateHandleProvider(streamGraph.getStateHandleProvider());
  config.setStatePartitioner((KeySelector<?,Serializable>)vertex.getStatePartitioner());
  Class<? extends AbstractInvokable> vertexClass=vertex.getJobVertexClass();
  if (vertexClass.equals(StreamIterationHead.class) || vertexClass.equals(StreamIterationTail.class)) {
    config.setIterationId(streamGraph.getBrokerID(vertexID));
    config.setIterationWaitTime(streamGraph.getLoopTimeout(vertexID));
  }
  List<StreamEdge> allOutputs=new ArrayList<StreamEdge>(chainableOutputs);
  allOutputs.addAll(nonChainableOutputs);
  for (  StreamEdge output : allOutputs) {
    config.setSelectedNames(output.getTargetId(),streamGraph.getStreamEdge(vertexID,output.getTargetId()).getSelectedNames());
  }
  vertexConfigs.put(vertexID,config);
}
