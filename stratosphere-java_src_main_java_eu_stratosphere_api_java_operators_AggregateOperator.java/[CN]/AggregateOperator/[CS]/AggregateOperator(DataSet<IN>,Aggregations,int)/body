{
  super((input != null && input.getClass() == AggregateOperator.class) ? ((AggregateOperator<IN>)input).getInput() : input,input.getType());
  if (input == null || function == null)   throw new NullPointerException();
  if (field < 0 || field >= input.getType().getArity())   throw new IllegalArgumentException("Field position is out of range.");
  if (input.getClass() != AggregateOperator.class) {
    this.aggregationFunctions=new Aggregations[]{function};
    this.fields=new int[]{field};
    this.groupingFields=new int[0];
  }
 else {
    AggregateOperator<IN> pred=(AggregateOperator<IN>)input;
    int num=pred.aggregationFunctions.length;
    this.aggregationFunctions=new Aggregations[num + 1];
    this.fields=new int[num + 1];
    System.arraycopy(pred.aggregationFunctions,0,this.aggregationFunctions,0,num);
    System.arraycopy(pred.fields,0,this.fields,0,num);
    this.aggregationFunctions[num]=function;
    this.fields[num]=field;
    this.groupingFields=pred.groupingFields;
  }
}
