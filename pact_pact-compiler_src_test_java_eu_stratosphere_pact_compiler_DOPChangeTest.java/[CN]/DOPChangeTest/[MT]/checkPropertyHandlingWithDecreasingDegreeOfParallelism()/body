{
  final int degOfPar=DEFAULT_PARALLELISM;
  FileDataSource source=new FileDataSource(DummyInputFormat.class,IN_FILE,"Source");
  source.setDegreeOfParallelism(degOfPar * 2);
  MapContract map1=MapContract.builder(IdentityMap.class).name("Map1").build();
  map1.setDegreeOfParallelism(degOfPar * 2);
  map1.setInput(source);
  ReduceContract reduce1=ReduceContract.builder(IdentityReduce.class,PactInteger.class,0).name("Reduce 1").build();
  reduce1.setDegreeOfParallelism(degOfPar * 2);
  reduce1.setInput(map1);
  MapContract map2=MapContract.builder(IdentityMap.class).name("Map2").build();
  map2.setDegreeOfParallelism(degOfPar);
  map2.setInput(reduce1);
  ReduceContract reduce2=ReduceContract.builder(IdentityReduce.class,PactInteger.class,0).name("Reduce 2").build();
  reduce2.setDegreeOfParallelism(degOfPar);
  reduce2.setInput(map2);
  FileDataSink sink=new FileDataSink(DummyOutputFormat.class,OUT_FILE,"Sink");
  sink.setDegreeOfParallelism(degOfPar);
  sink.setInput(reduce2);
  Plan plan=new Plan(sink,"Test Increasing Degree Of Parallelism");
  OptimizedPlan oPlan=compileNoStats(plan);
  SinkPlanNode sinkNode=oPlan.getDataSinks().iterator().next();
  SingleInputPlanNode red2Node=(SingleInputPlanNode)sinkNode.getPredecessor();
  Assert.assertEquals("The Reduce 2 Node has an invalid local strategy.",LocalStrategy.SORT,red2Node.getInput().getLocalStrategy());
}
