{
  ExecutionGraph executionGraph=null;
  boolean success=false;
  try {
    if (job == null) {
      return new JobSubmissionResult(AbstractJobResult.ReturnCode.ERROR,"Submitted job is null!");
    }
    if (LOG.isInfoEnabled()) {
      LOG.info(String.format("Received job %s (%s)",job.getJobID(),job.getName()));
    }
    executionGraph=this.currentJobs.get(job.getJobID());
    if (executionGraph == null) {
      if (LOG.isInfoEnabled()) {
        LOG.info("Creating new execution graph for job " + job.getJobID() + " ("+ job.getName()+ ')');
      }
      executionGraph=new ExecutionGraph(job.getJobID(),job.getName(),job.getJobConfiguration(),this.executorService);
      ExecutionGraph previous=this.currentJobs.putIfAbsent(job.getJobID(),executionGraph);
      if (previous != null) {
        throw new JobException("Concurrent submission of a job with the same jobId: " + job.getJobID());
      }
    }
 else {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("Found existing execution graph for id %s, attaching this job.",job.getJobID()));
      }
    }
    final ClassLoader userCodeLoader=LibraryCacheManager.getClassLoader(job.getJobID());
    if (userCodeLoader == null) {
      throw new JobException("The user code class loader could not be initialized.");
    }
    String[] jarFilesForJob=LibraryCacheManager.getRequiredJarFiles(job.getJobID());
    for (    String fileId : jarFilesForJob) {
      executionGraph.addUserCodeJarFile(fileId);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(String.format("Running master initialization of job %s (%s)",job.getJobID(),job.getName()));
    }
    try {
      for (      AbstractJobVertex vertex : job.getVertices()) {
        String executableClass=vertex.getInvokableClassName();
        if (executableClass == null || executableClass.length() == 0) {
          throw new JobException(String.format("The vertex %s (%s) has no invokable class.",vertex.getID(),vertex.getName()));
        }
        vertex.initializeOnMaster(userCodeLoader);
      }
    }
 catch (    FileNotFoundException e) {
      String message="File-not-Found: " + e.getMessage();
      LOG.error(message);
      executionGraph.fail(e);
      return new JobSubmissionResult(AbstractJobResult.ReturnCode.ERROR,e.getMessage());
    }
    List<AbstractJobVertex> topoSorted=job.getVerticesSortedTopologicallyFromSources();
    if (LOG.isDebugEnabled()) {
      LOG.debug(String.format("Adding %d vertices from job graph %s (%s)",topoSorted.size(),job.getJobID(),job.getName()));
    }
    executionGraph.attachJobGraph(topoSorted);
    if (LOG.isDebugEnabled()) {
      LOG.debug(String.format("Successfully created execution graph from job graph %s (%s)",job.getJobID(),job.getName()));
    }
    executionGraph.setQueuedSchedulingAllowed(job.getAllowQueuedScheduling());
    if (this.eventCollector != null) {
      this.eventCollector.registerJob(executionGraph,false,System.currentTimeMillis());
    }
    executionGraph.registerJobStatusListener(this);
    if (LOG.isInfoEnabled()) {
      LOG.info("Scheduling job " + job.getName());
    }
    executionGraph.scheduleForExecution(this.scheduler);
    success=true;
    return new JobSubmissionResult(AbstractJobResult.ReturnCode.SUCCESS,null);
  }
 catch (  Throwable t) {
    LOG.error("Job submission failed.",t);
    executionGraph.fail(t);
    return new JobSubmissionResult(AbstractJobResult.ReturnCode.ERROR,StringUtils.stringifyException(t));
  }
 finally {
    if (!success) {
      if (executionGraph != null) {
        if (executionGraph.getState() != JobStatus.FAILING && executionGraph.getState() != JobStatus.FAILED) {
          executionGraph.fail(new Exception("Could not set up and start execution graph on JobManager"));
        }
        try {
          executionGraph.waitForJobEnd(10000);
        }
 catch (        InterruptedException e) {
          LOG.error("Interrupted while waiting for job to finish canceling.");
        }
      }
      this.currentJobs.remove(job.getJobID());
      try {
        LibraryCacheManager.unregister(job.getJobID());
      }
 catch (      IllegalStateException e) {
      }
catch (      Throwable t) {
        LOG.error("Error while de-registering job at library cache manager.",t);
      }
    }
  }
}
