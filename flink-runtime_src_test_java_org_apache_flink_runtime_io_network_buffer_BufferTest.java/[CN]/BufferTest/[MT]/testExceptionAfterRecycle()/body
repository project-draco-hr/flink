{
  final MemorySegment segment=new MemorySegment(new byte[1024]);
  final BufferRecycler recycler=Mockito.mock(BufferRecycler.class);
  final Buffer buffer=new Buffer(segment,recycler);
  buffer.recycle();
  Mockito.verify(recycler,Mockito.times(1)).recycle(Matchers.any(MemorySegment.class));
  final Buffer spyBuffer=Mockito.spy(buffer);
  for (  final Method method : buffer.getClass().getDeclaredMethods()) {
    if (Modifier.isPublic(method.getModifiers()) && !method.getName().equals("toString") && !method.getName().equals("isRecycled")&& !method.getName().equals("isBuffer")) {
      final Method spyMethod=spyBuffer.getClass().getDeclaredMethod(method.getName(),method.getParameterTypes());
      final Class<?>[] paramTypes=spyMethod.getParameterTypes();
      final Object[] params=new Object[paramTypes.length];
      for (int i=0; i < params.length; i++) {
        params[i]=Matchers.any(paramTypes[i]);
      }
      try {
        spyMethod.invoke(spyBuffer,params);
        Assert.fail("Didn't throw expected exception for method: " + method.getName());
      }
 catch (      InvocationTargetException e) {
        if (e.getTargetException() instanceof IllegalStateException) {
        }
 else {
          throw e.getTargetException();
        }
      }
    }
  }
}
