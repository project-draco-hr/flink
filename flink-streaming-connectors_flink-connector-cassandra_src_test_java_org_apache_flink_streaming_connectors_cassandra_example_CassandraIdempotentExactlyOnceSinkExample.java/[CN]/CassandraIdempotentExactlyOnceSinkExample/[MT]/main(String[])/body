{
class MySource implements SourceFunction<Tuple2<String,Integer>>, Checkpointed<Integer> {
    private int counter=0;
    private boolean stop=false;
    @Override public void run(    SourceContext<Tuple2<String,Integer>> ctx) throws Exception {
      while (!stop) {
        Thread.sleep(50);
        ctx.collect(new Tuple2<>("" + UUID.randomUUID(),1));
        counter++;
        if (counter == 100) {
          stop=true;
        }
      }
    }
    @Override public void cancel(){
      stop=true;
    }
    @Override public Integer snapshotState(    long checkpointId,    long checkpointTimestamp) throws Exception {
      return counter;
    }
    @Override public void restoreState(    Integer state) throws Exception {
      this.counter=state;
    }
  }
  StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setParallelism(1);
  env.enableCheckpointing(1000);
  env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1,1000));
  env.setStateBackend(new FsStateBackend("file:///" + System.getProperty("java.io.tmpdir") + "/flink/backend"));
  CassandraSink<Tuple2<String,Integer>> sink=CassandraSink.addSink(env.addSource(new MySource())).setQuery("INSERT INTO example.values (id, counter) values (?, ?);").setConsistencyLevel(CassandraSink.ConsistencyLevel.EXACTLY_ONCE).setClusterBuilder(new ClusterBuilder(){
    @Override public Cluster buildCluster(    Cluster.Builder builder){
      return builder.addContactPoint("127.0.0.1").build();
    }
  }
).build();
  sink.name("Cassandra Sink").disableChaining().setParallelism(1).uid("hello");
  env.execute();
}
