{
  OutputCollector innerOutput=new OutputCollector();
  RecordWriter<Value>[] innerWriters=getIterationRecordWriters();
  for (  RecordWriter<Value> writer : innerWriters) {
    innerOutput.addWriter(writer);
  }
  OutputCollector taskOutput=new OutputCollector();
  taskOutput.addWriter(output.getWriters().get(0));
  OutputGate<? extends Record>[] iterStateGates=getIterationOutputGates();
  LOG.info("Update memory: " + updateBufferSize + ", numSegments: "+ (int)(updateBufferSize / MEMORY_SEGMENT_SIZE));
  List<MemorySegment> updateMemory=getEnvironment().getMemoryManager().allocatePages(this,(int)(updateBufferSize / MEMORY_SEGMENT_SIZE));
  SerializedUpdateBuffer buffer=new SerializedUpdateBuffer(updateMemory,MEMORY_SEGMENT_SIZE,getEnvironment().getIOManager());
  BackTrafficQueueStore.getInstance().addStructures(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup());
  BackTrafficQueueStore.getInstance().publishUpdateBuffer(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup(),buffer);
  publishState(ChannelState.OPEN,iterStateGates);
  if (LOG.isInfoEnabled()) {
    LOG.info(constructLogString("Starting Iteration: -1",getEnvironment().getTaskName(),this));
  }
  MutableObjectIterator<Value> input=inputs[0];
  CountingIterator statsIter=new CountingIterator(input);
  CountingOutputCollector statsOutputCollector=new CountingOutputCollector(innerOutput);
  processInput(statsIter,statsOutputCollector);
  sendCounter("iter.received.messages",statsIter.getCount());
  sendCounter("iter.send.messages",statsOutputCollector.getCount());
  publishState(ChannelState.CLOSED,iterStateGates);
  int iterationCounter=0;
  SerializedUpdateBuffer updatesBuffer;
  while (true) {
    try {
      updatesBuffer=(SerializedUpdateBuffer)BackTrafficQueueStore.getInstance().receiveIterationEnd(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup());
    }
 catch (    InterruptedException ex) {
      throw new RuntimeException("Internal Error");
    }
    try {
      channelStateListener.waitForUpdate();
      terminationStateListener.waitForUpdate();
    }
 catch (    InterruptedException ex) {
      throw new RuntimeException("Internal Error");
    }
    if (channelStateListener.isUpdated() && terminationStateListener.isUpdated()) {
      if (terminationStateListener.getState() == ChannelState.TERMINATED) {
        break;
      }
 else {
        if (LOG.isInfoEnabled()) {
          LOG.info(constructLogString("Starting Iteration: " + iterationCounter,getEnvironment().getTaskName(),this));
        }
        statsIter=new CountingIterator(new DeserializingIterator(updatesBuffer.switchBuffers()));
        BackTrafficQueueStore.getInstance().publishUpdateBuffer(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup(),buffer);
        publishState(ChannelState.OPEN,iterStateGates);
        statsOutputCollector=new CountingOutputCollector(innerOutput);
        processUpdates(statsIter,statsOutputCollector);
        sendCounter("iter.received.messages",statsIter.getCount());
        sendCounter("iter.send.messages",statsOutputCollector.getCount());
        publishState(ChannelState.CLOSED,iterStateGates);
        updatesBuffer=null;
        iterationCounter++;
      }
    }
 else {
      throw new RuntimeException("isUpdated() returned false even thoug waitForUpate() exited");
    }
  }
  finish(new DeserializingIterator(updatesBuffer.switchBuffers()),taskOutput);
  if (updatesBuffer != null) {
  }
  getEnvironment().getMemoryManager().release(updateMemory);
  finished=true;
}
