{
  OutputCollectorV2 innerOutput=new OutputCollectorV2();
  RecordWriter<Value>[] innerWriters=getIterationRecordWriters();
  for (  RecordWriter<Value> writer : innerWriters) {
    innerOutput.addWriter(writer);
  }
  OutputCollectorV2 taskOutput=new OutputCollectorV2();
  taskOutput.addWriter(output.getWriters().get(0));
  OutputGate<? extends Record>[] iterStateGates=getIterationOutputGates();
  LOG.info("Update memory: " + updateBufferSize + ", numSegments: "+ (int)(updateBufferSize / MEMORY_SEGMENT_SIZE));
  List<MemorySegment> updateMemory=memoryManager.allocateStrict(this,(int)(updateBufferSize / MEMORY_SEGMENT_SIZE),MEMORY_SEGMENT_SIZE);
  SerializedUpdateBuffer buffer=new SerializedUpdateBuffer(updateMemory,MEMORY_SEGMENT_SIZE,ioManager);
  BackTrafficQueueStore.getInstance().addStructures(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup());
  BackTrafficQueueStore.getInstance().publishUpdateBuffer(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup(),buffer);
  AbstractIterativeTask.publishState(ChannelState.OPEN,iterStateGates);
  if (LOG.isInfoEnabled()) {
    LOG.info(constructLogString("Starting Iteration: -1",getEnvironment().getTaskName(),this));
  }
  MutableObjectIterator<Value> input=inputs[0];
  CountingIterator statsIter=new CountingIterator(input);
  CountingOutput statsOutput=new CountingOutput(innerOutput);
  processInput(statsIter,statsOutput);
  sendCounter("iter.received.messages",statsIter.getCount());
  sendCounter("iter.send.messages",statsOutput.getCount());
  AbstractIterativeTask.publishState(ChannelState.CLOSED,iterStateGates);
  int iterationCounter=0;
  SerializedUpdateBuffer updatesBuffer=null;
  while (true) {
    try {
      updatesBuffer=(SerializedUpdateBuffer)BackTrafficQueueStore.getInstance().receiveIterationEnd(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup());
    }
 catch (    InterruptedException ex) {
      throw new RuntimeException("Internal Error");
    }
    try {
      channelStateListener.waitForUpdate();
      terminationStateListener.waitForUpdate();
    }
 catch (    InterruptedException ex) {
      throw new RuntimeException("Internal Error");
    }
    if (channelStateListener.isUpdated() && terminationStateListener.isUpdated()) {
      if (terminationStateListener.getState() == ChannelState.TERMINATED) {
        break;
      }
 else {
        if (LOG.isInfoEnabled()) {
          LOG.info(constructLogString("Starting Iteration: " + iterationCounter,getEnvironment().getTaskName(),this));
        }
        statsIter=new CountingIterator(new DeserializingIterator(updatesBuffer.switchBuffers()));
        BackTrafficQueueStore.getInstance().publishUpdateBuffer(getEnvironment().getJobID(),getEnvironment().getIndexInSubtaskGroup(),buffer);
        AbstractIterativeTask.publishState(ChannelState.OPEN,iterStateGates);
        statsOutput=new CountingOutput(innerOutput);
        processUpdates(statsIter,statsOutput);
        sendCounter("iter.received.messages",statsIter.getCount());
        sendCounter("iter.send.messages",statsOutput.getCount());
        AbstractIterativeTask.publishState(ChannelState.CLOSED,iterStateGates);
        updatesBuffer=null;
        iterationCounter++;
      }
    }
 else {
      throw new RuntimeException("isUpdated() returned false even thoug waitForUpate() exited");
    }
  }
  finish(new DeserializingIterator(updatesBuffer.switchBuffers()),taskOutput);
  if (updatesBuffer != null) {
  }
  memoryManager.release(updateMemory);
  finished=true;
}
