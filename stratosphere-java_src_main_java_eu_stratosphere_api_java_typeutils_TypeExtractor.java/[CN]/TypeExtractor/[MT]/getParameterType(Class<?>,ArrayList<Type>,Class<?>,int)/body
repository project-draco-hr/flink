{
  Type t=clazz.getGenericSuperclass();
  if (!(t instanceof Class<?> && baseClass.isAssignableFrom((Class<?>)t)) && !(t instanceof ParameterizedType && baseClass.isAssignableFrom((Class<?>)((ParameterizedType)t).getRawType()))) {
    throw new IllegalArgumentException("A generic function base class must be a super class.");
  }
  if (typeHierarchy != null) {
    typeHierarchy.add(t);
  }
  Type curT=t;
  while (!(curT instanceof ParameterizedType && ((Class<?>)((ParameterizedType)curT).getRawType()).equals(baseClass)) && !(curT instanceof Class<?> && ((Class<?>)curT).equals(baseClass))) {
    if (typeHierarchy != null) {
      typeHierarchy.add(curT);
    }
    if (curT instanceof ParameterizedType) {
      curT=((Class<?>)((ParameterizedType)curT).getRawType()).getGenericSuperclass();
    }
 else {
      curT=((Class<?>)curT).getGenericSuperclass();
    }
  }
  if (curT instanceof Class<?>) {
    throw new InvalidTypesException("Function needs to be parameterized by using generics.");
  }
  if (typeHierarchy != null) {
    typeHierarchy.add(curT);
  }
  ParameterizedType baseClassChild=(ParameterizedType)curT;
  return baseClassChild.getActualTypeArguments()[pos];
}
