{
  Type curT=t;
  if ((curT instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>)curT)) || (curT instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>)((ParameterizedType)curT).getRawType()))) {
    while (!(curT instanceof ParameterizedType) && !((Class)curT).equals(Tuple.class)) {
      curT=((Class<?>)curT).getGenericSuperclass();
    }
    if (curT instanceof ParameterizedType) {
      ParameterizedType pt=(ParameterizedType)curT;
      Type raw=pt.getRawType();
      if (raw instanceof Class) {
        Type[] subtypes=pt.getActualTypeArguments();
        TypeInformation<?>[] tupleSubTypes=new TypeInformation<?>[subtypes.length];
        for (int i=0; i < subtypes.length; i++) {
          tupleSubTypes[i]=createTypeInfo(subtypes[i]);
        }
        if (t instanceof Class<?>) {
          return new TupleTypeInfo(((Class<? extends Tuple>)t),tupleSubTypes);
        }
 else         if (t instanceof ParameterizedType) {
          return new TupleTypeInfo(((Class<? extends Tuple>)((ParameterizedType)t).getRawType()),tupleSubTypes);
        }
      }
    }
  }
 else   if (t instanceof Class) {
    return TypeInformation.getForClass((Class<X>)t);
  }
  return null;
}
