{
  if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>)t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>)((ParameterizedType)t).getRawType()))) {
    Type curT=t;
    if (curT instanceof Class<?> && ((Class<?>)curT).equals(Tuple.class)) {
      throw new InvalidTypesException("Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.");
    }
    while (!(curT instanceof ParameterizedType && ((Class<?>)((ParameterizedType)curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>)curT).getSuperclass().equals(Tuple.class))) {
      typeHierarchy.add(curT);
      if (curT instanceof ParameterizedType) {
        curT=((Class<?>)((ParameterizedType)curT).getRawType()).getGenericSuperclass();
      }
 else {
        curT=((Class<?>)curT).getGenericSuperclass();
      }
    }
    if (curT instanceof Class<?>) {
      throw new InvalidTypesException("Tuple needs to be parameterized by using generics.");
    }
    ParameterizedType tupleChild=(ParameterizedType)curT;
    Type[] subtypes=new Type[tupleChild.getActualTypeArguments().length];
    for (int i=0; i < subtypes.length; i++) {
      if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
        Type varContent=materializeTypeVariable(typeHierarchy,(TypeVariable<?>)tupleChild.getActualTypeArguments()[i]);
        if (varContent == null) {
          subtypes[i]=tupleChild.getActualTypeArguments()[i];
        }
 else {
          subtypes[i]=varContent;
        }
      }
 else {
        subtypes[i]=tupleChild.getActualTypeArguments()[i];
      }
    }
    TypeInformation<?>[] tupleSubTypes=new TypeInformation<?>[subtypes.length];
    for (int i=0; i < subtypes.length; i++) {
      if (subtypes[i] instanceof TypeVariable<?>) {
        ParameterizedType immediateBaseChild=(ParameterizedType)typeHierarchy.get(typeHierarchy.size() - 1);
        tupleSubTypes[i]=createTypeInfoWithImmediateBaseChildInput(immediateBaseChild,(TypeVariable<?>)subtypes[i],in1Type,in2Type);
        if (tupleSubTypes[i] == null) {
          throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>)subtypes[i]).getName() + "' in '"+ ((TypeVariable<?>)subtypes[i]).getGenericDeclaration()+ "' could not be determined. This is most likely a type erasure problem. "+ "The type extraction currently supports types with generic variables only in cases where "+ "all variables in the return type can be deduced from the input type(s).");
        }
      }
 else {
        tupleSubTypes[i]=createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy),subtypes[i],in1Type,in2Type);
      }
    }
    if (t instanceof Class<?>) {
      return new TupleTypeInfo(((Class<? extends Tuple>)t),tupleSubTypes);
    }
 else     if (t instanceof ParameterizedType) {
      return new TupleTypeInfo(((Class<? extends Tuple>)((ParameterizedType)t).getRawType()),tupleSubTypes);
    }
  }
 else   if (t instanceof TypeVariable) {
    Type typeVar=materializeTypeVariable(typeHierarchy,(TypeVariable<?>)t);
    if (typeVar != null) {
      return createTypeInfoWithTypeHierarchy(typeHierarchy,typeVar,in1Type,in2Type);
    }
 else {
      ParameterizedType immediateBaseChild=(ParameterizedType)typeHierarchy.get(typeHierarchy.size() - 1);
      TypeInformation<OUT> typeInfo=(TypeInformation<OUT>)createTypeInfoWithImmediateBaseChildInput(immediateBaseChild,(TypeVariable<?>)t,in1Type,in2Type);
      if (typeInfo != null) {
        return typeInfo;
      }
 else {
        throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>)t).getName() + "' in '"+ ((TypeVariable<?>)t).getGenericDeclaration()+ "' could not be determined. This is most likely a type erasure problem. "+ "The type extraction currently supports types with generic variables only in cases where "+ "all variables in the return type can be deduced from the input type(s).");
      }
    }
  }
 else   if (t instanceof GenericArrayType) {
    GenericArrayType genericArray=(GenericArrayType)t;
    TypeInformation<?> componentInfo=createTypeInfoWithTypeHierarchy(typeHierarchy,genericArray.getGenericComponentType(),in1Type,in2Type);
    return ObjectArrayTypeInfo.getInfoFor(t,componentInfo);
  }
 else   if (t instanceof ParameterizedType) {
    return getForClass((Class<OUT>)((ParameterizedType)t).getRawType());
  }
 else   if (t instanceof Class) {
    return getForClass((Class<OUT>)t);
  }
  throw new InvalidTypesException("Type Information could not be created.");
}
