{
  Validate.notNull(clazz);
  if (Modifier.isInterface(clazz.getModifiers()) || (Modifier.isAbstract(clazz.getModifiers()) && !clazz.isArray())) {
    throw new InvalidTypesException("Interfaces and abstract classes are not valid types.");
  }
  if (clazz.isArray()) {
    if (BasicTypeInfo.getInfoFor(clazz.getComponentType()) != null) {
      return BasicArrayTypeInfo.getInfoFor(clazz);
    }
 else {
      return ObjectArrayTypeInfo.getInfoFor(clazz);
    }
  }
  TypeInformation<X> basicTypeInfo=BasicTypeInfo.getInfoFor(clazz);
  if (basicTypeInfo != null) {
    return basicTypeInfo;
  }
  if (Value.class.isAssignableFrom(clazz)) {
    Class<? extends Value> valueClass=clazz.asSubclass(Value.class);
    return (TypeInformation<X>)ValueTypeInfo.getValueTypeInfo(valueClass);
  }
  if (Tuple.class.isAssignableFrom(clazz)) {
    throw new InvalidTypesException("Type information extraction for tuples cannot be done based on the class.");
  }
  return new GenericTypeInfo<X>(clazz);
}
