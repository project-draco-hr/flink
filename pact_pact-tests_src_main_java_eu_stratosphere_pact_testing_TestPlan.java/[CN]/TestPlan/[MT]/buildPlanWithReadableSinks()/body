{
  final Collection<DataSinkContract<?,?>> existingSinks=this.getDataSinks();
  final Collection<DataSinkContract<?,?>> wrappedSinks=new ArrayList<DataSinkContract<?,?>>();
  for (  final DataSinkContract<?,?> dataSinkContract : existingSinks)   if (dataSinkContract.getStubClass() != SequentialOutputFormat.class) {
    final DataSinkContract<Key,Value> safeSink=createDefaultSink(dataSinkContract.getName());
    safeSink.setInput(dataSinkContract.getInput());
    wrappedSinks.add(this.createSplittingSink(dataSinkContract,safeSink));
    this.expectedOutputs.put(safeSink,this.getExpectedOutput(dataSinkContract));
    this.actualOutputs.put(safeSink,this.getActualOutput(dataSinkContract));
    this.getActualOutput(dataSinkContract).fromFile(SequentialInputFormat.class,safeSink.getFilePath());
  }
 else {
    wrappedSinks.add(dataSinkContract);
    this.getActualOutput(dataSinkContract).fromFile(SequentialInputFormat.class,dataSinkContract.getFilePath());
  }
  return new Plan(wrappedSinks);
}
