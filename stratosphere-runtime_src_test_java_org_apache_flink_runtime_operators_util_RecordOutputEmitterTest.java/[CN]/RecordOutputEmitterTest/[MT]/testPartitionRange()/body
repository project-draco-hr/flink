{
  final Random rnd=new Random(SEED);
  final int DISTR_MIN=0;
  final int DISTR_MAX=1000000;
  final int DISTR_RANGE=DISTR_MAX - DISTR_MIN + 1;
  final int NUM_BUCKETS=137;
  final double BUCKET_WIDTH=DISTR_RANGE / ((double)NUM_BUCKETS);
  final int NUM_ELEMENTS=10000000;
  final DataDistribution distri=new UniformIntegerDistribution(DISTR_MIN,DISTR_MAX);
  @SuppressWarnings("unchecked") final RecordComparator intComp=new RecordComparator(new int[]{0},new Class[]{IntValue.class});
  final ChannelSelector<Record> oe=new RecordOutputEmitter(ShipStrategyType.PARTITION_RANGE,intComp,distri);
  final IntValue integer=new IntValue();
  final Record rec=new Record();
  for (int i=0; i < NUM_ELEMENTS; i++) {
    final int nextValue=rnd.nextInt(DISTR_RANGE) + DISTR_MIN;
    integer.setValue(nextValue);
    rec.setField(0,integer);
    final int[] channels=oe.selectChannels(rec,NUM_BUCKETS);
    if (channels.length != 1) {
      Assert.fail("Resulting channels array has more than one channel.");
    }
    final int bucket=channels[0];
    final int shouldBeBucket=(int)((nextValue - DISTR_MIN) / BUCKET_WIDTH);
    if (shouldBeBucket != bucket) {
      final int lowerBoundaryForSelectedBucket=DISTR_MIN + (int)((bucket) * BUCKET_WIDTH);
      final int upperBoundaryForSelectedBucket=DISTR_MIN + (int)((bucket + 1) * BUCKET_WIDTH);
      if (nextValue <= lowerBoundaryForSelectedBucket || nextValue > upperBoundaryForSelectedBucket) {
        Assert.fail("Wrong bucket selected");
      }
    }
  }
}
