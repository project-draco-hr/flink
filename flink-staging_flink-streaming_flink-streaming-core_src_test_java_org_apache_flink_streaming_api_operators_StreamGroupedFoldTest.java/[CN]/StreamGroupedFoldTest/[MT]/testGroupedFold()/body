{
  StreamGroupedFold<Integer,String> operator=new StreamGroupedFold<>(new MyFolder(),new KeySelector<Integer,String>(){
    private static final long serialVersionUID=1L;
    @Override public String getKey(    Integer value) throws Exception {
      return value.toString();
    }
  }
,"100",inType);
  operator.setOutputType(outType,new ExecutionConfig());
  OneInputStreamOperatorTestHarness<Integer,String> testHarness=new OneInputStreamOperatorTestHarness<>(operator);
  long initialTime=0L;
  ConcurrentLinkedQueue<Object> expectedOutput=new ConcurrentLinkedQueue<>();
  testHarness.open();
  testHarness.processElement(new StreamRecord<>(1,initialTime + 1));
  testHarness.processElement(new StreamRecord<>(1,initialTime + 2));
  testHarness.processWatermark(new Watermark(initialTime + 2));
  testHarness.processElement(new StreamRecord<>(2,initialTime + 3));
  testHarness.processElement(new StreamRecord<>(2,initialTime + 4));
  testHarness.processElement(new StreamRecord<>(3,initialTime + 5));
  expectedOutput.add(new StreamRecord<>("1001",initialTime + 1));
  expectedOutput.add(new StreamRecord<>("10011",initialTime + 2));
  expectedOutput.add(new Watermark(initialTime + 2));
  expectedOutput.add(new StreamRecord<>("1002",initialTime + 3));
  expectedOutput.add(new StreamRecord<>("10022",initialTime + 4));
  expectedOutput.add(new StreamRecord<>("1003",initialTime + 5));
  TestHarnessUtil.assertOutputEquals("Output was not correct.",expectedOutput,testHarness.getOutput());
}
