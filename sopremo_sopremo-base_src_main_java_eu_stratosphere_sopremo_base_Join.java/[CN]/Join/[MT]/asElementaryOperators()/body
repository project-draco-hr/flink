{
  final int numInputs=this.getInputs().size();
  final SopremoModule module=new SopremoModule(this.toString(),numInputs,1);
  List<TwoSourceJoin> joins;
  if (this.joinCondition instanceof AndExpression)   joins=this.getInitialJoinOrder((AndExpression)this.joinCondition,module);
 else   joins=Arrays.asList(this.getTwoSourceJoinForExpression(this.joinCondition,module));
  final List<Operator<?>> inputs=new ArrayList<Operator<?>>();
  for (int index=0; index < numInputs; index++) {
    final EvaluationExpression[] elements=new EvaluationExpression[numInputs];
    Arrays.fill(elements,EvaluationExpression.NULL);
    elements[index]=EvaluationExpression.VALUE;
    inputs.add(new Projection().withValueTransformation(new ArrayCreation(elements)).withInputs(module.getInput(index)));
  }
  for (  final TwoSourceJoin twoSourceJoin : joins) {
    List<JsonStream> operatorInputs=twoSourceJoin.getInputs();
    final List<JsonStream> actualInputs=new ArrayList<JsonStream>(operatorInputs.size());
    List<Source> moduleInput=Arrays.asList(module.getInputs());
    for (int index=0; index < operatorInputs.size(); index++) {
      final int inputIndex=moduleInput.indexOf(operatorInputs.get(index).getSource().getOperator());
      actualInputs.add(inputs.get(inputIndex).getSource());
    }
    for (int index=0; index < operatorInputs.size(); index++) {
      final int inputIndex=moduleInput.indexOf(operatorInputs.get(index).getSource().getOperator());
      inputs.set(inputIndex,twoSourceJoin);
    }
    twoSourceJoin.setInputs(actualInputs);
  }
  module.getOutput(0).setInput(0,new Projection().withKeyTransformation(EvaluationExpression.NULL).withValueTransformation(this.resultProjection).withInputs(joins.get(joins.size() - 1)));
  return module;
}
