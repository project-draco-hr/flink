{
  final int numInputs=this.getInputs().size();
  final SopremoModule module=new SopremoModule(this.toString(),numInputs,1);
  List<TwoSourceJoin> joins;
  if (this.condition instanceof AndExpression)   joins=this.getInitialJoinOrder((AndExpression)this.condition,module);
 else   joins=Arrays.asList(this.getTwoSourceJoinForExpression(this.condition,module));
  final List<Operator> inputs=new ArrayList<Operator>();
  for (int index=0; index < numInputs; index++) {
    final EvaluationExpression[] elements=new EvaluationExpression[numInputs];
    Arrays.fill(elements,EvaluationExpression.NULL);
    elements[index]=EvaluationExpression.VALUE;
    inputs.add(new Projection().withValueTransformation(new ArrayCreation(elements)).withInputs(module.getInput(index)));
  }
  for (  final TwoSourceJoin twoSourceJoin : joins) {
    final List<Output> operatorInputs=twoSourceJoin.getInputs();
    final Output[] actualInputs=new Output[2];
    List<Source> moduleInput=Arrays.asList(module.getInputs());
    for (int index=0; index < operatorInputs.size(); index++) {
      final int inputIndex=moduleInput.indexOf(operatorInputs.get(index).getOperator());
      actualInputs[index]=inputs.get(inputIndex).getSource();
    }
    for (int index=0; index < operatorInputs.size(); index++) {
      final int inputIndex=moduleInput.indexOf(operatorInputs.get(index).getOperator());
      inputs.set(inputIndex,twoSourceJoin);
    }
    twoSourceJoin.setInputs(actualInputs);
  }
  module.getOutput(0).setInput(0,new Projection().withKeyTransformation(EvaluationExpression.NULL).withValueTransformation(this.resultProjection).withInputs(joins.get(joins.size() - 1)));
  return module;
}
