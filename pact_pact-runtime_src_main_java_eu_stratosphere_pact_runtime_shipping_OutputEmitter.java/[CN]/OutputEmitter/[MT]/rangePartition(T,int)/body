{
  if (channels == null || channels.length != 1) {
    channels=new int[1];
  }
  if (this.partitionBoundaries == null) {
    this.partitionBoundaries=(TypeComparator<T>[])Array.newInstance(this.comparator.getClass(),numberOfChannels - 1);
    for (int i=0; i < numberOfChannels - 1; i++) {
      this.partitionBoundaries[i]=this.comparator.duplicate();
      this.partitionBoundaries[i].setReference(this.distribution.getBucketBoundary(i,numberOfChannels));
    }
  }
  if (numberOfChannels == this.partitionBoundaries.length + 1) {
    final TypeComparator<T>[] boundaries=this.partitionBoundaries;
    this.comparator.setReference(record);
    int low=0;
    int high=this.partitionBoundaries.length - 1;
    while (low <= high) {
      final int mid=(low + high) >>> 1;
      final int result=this.comparator.compareToReference(boundaries[mid]);
      if (result < 0) {
        low=mid + 1;
      }
 else       if (result > 0) {
        high=mid - 1;
      }
 else {
        this.channels[0]=mid;
        return this.channels;
      }
    }
    this.channels[0]=low;
    return this.channels;
  }
 else {
    throw new IllegalStateException("The number of channels to partition among is inconsistent with the partitioners state.");
  }
}
