{
  Operator<?> inputOp1=operator.getFirstInput();
  Operator<?> inputOp2=operator.getSecondInput();
  if (inputOp1 == null) {
    throw new InvalidProgramException("The binary operation " + operator.getName() + " has no first input.");
  }
  if (inputOp2 == null) {
    throw new InvalidProgramException("The binary operation " + operator.getName() + " has no second input.");
  }
  @SuppressWarnings("unchecked") List<IN1> inputData1=(List<IN1>)execute(inputOp1,superStep);
  @SuppressWarnings("unchecked") List<IN2> inputData2=(List<IN2>)execute(inputOp2,superStep);
  @SuppressWarnings("unchecked") DualInputOperator<IN1,IN2,OUT,?> typedOp=(DualInputOperator<IN1,IN2,OUT,?>)operator;
  RuntimeUDFContext ctx;
  if (RichFunction.class.isAssignableFrom(typedOp.getUserCodeWrapper().getUserCodeClass())) {
    ctx=superStep == 0 ? new RuntimeUDFContext(operator.getName(),1,0,classLoader) : new IterationRuntimeUDFContext(operator.getName(),1,0,superStep,classLoader);
    for (    Map.Entry<String,Operator<?>> bcInputs : operator.getBroadcastInputs().entrySet()) {
      List<?> bcData=execute(bcInputs.getValue());
      ctx.setBroadcastVariable(bcInputs.getKey(),bcData);
    }
  }
 else {
    ctx=null;
  }
  List<OUT> result=typedOp.executeOnCollections(inputData1,inputData2,ctx,mutableObjectSafeMode);
  if (ctx != null) {
    AccumulatorHelper.mergeInto(this.accumulators,ctx.getAllAccumulators());
  }
  return result;
}
