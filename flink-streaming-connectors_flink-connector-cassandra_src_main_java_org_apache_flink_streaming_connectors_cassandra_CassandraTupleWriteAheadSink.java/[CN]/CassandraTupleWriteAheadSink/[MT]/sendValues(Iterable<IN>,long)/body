{
  final IntValue updatesCount=new IntValue(0);
  final AtomicInteger updatesConfirmed=new AtomicInteger(0);
  final AtomicReference<Throwable> exception=new AtomicReference<>();
  FutureCallback<ResultSet> callback=new FutureCallback<ResultSet>(){
    @Override public void onSuccess(    ResultSet resultSet){
      updatesConfirmed.incrementAndGet();
      if (updatesCount.getValue() > 0) {
        if (updatesCount.getValue() == updatesConfirmed.get()) {
synchronized (updatesConfirmed) {
            updatesConfirmed.notifyAll();
          }
        }
      }
    }
    @Override public void onFailure(    Throwable throwable){
      if (exception.compareAndSet(null,throwable)) {
        LOG.error("Error while sending value.",throwable);
synchronized (updatesConfirmed) {
          updatesConfirmed.notifyAll();
        }
      }
    }
  }
;
  int updatesSent=0;
  for (  IN value : values) {
    for (int x=0; x < value.getArity(); x++) {
      fields[x]=value.getField(x);
    }
    BoundStatement s=preparedStatement.bind(fields);
    s.setDefaultTimestamp(timestamp);
    ResultSetFuture result=session.executeAsync(s);
    updatesSent++;
    if (result != null) {
      Futures.addCallback(result,callback);
    }
  }
  updatesCount.setValue(updatesSent);
synchronized (updatesConfirmed) {
    while (updatesSent != updatesConfirmed.get()) {
      if (exception.get() != null) {
        LOG.warn("Sending a value failed.",exception.get());
        break;
      }
      updatesConfirmed.wait();
    }
  }
  boolean success=updatesSent == updatesConfirmed.get();
  return success;
}
