{
  AbstractInvokable memOwner=new DummyInvokable();
  int writtenPairs=0, readPairs=0;
  MemorySegment unsortedMemory=memoryManager.allocate(memOwner,MEMORY_SIZE >> 1);
  final BufferSortableGuaranteed unsortedBuffer=newSortBuffer(unsortedMemory);
{
    TestData.Generator generator=new TestData.Generator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
    PactRecord rec=new PactRecord();
    while (unsortedBuffer.write(generator.next(rec))) {
      writtenPairs++;
    }
    LOG.debug("Written " + writtenPairs + " pairs.");
  }
  MemorySegment sortedMemory=memoryManager.allocate(memOwner,MEMORY_SIZE >> 1);
  final Buffer.Output sortedBuffer=new Buffer.Output(sortedMemory);
{
    new QuickSort().sort(unsortedBuffer);
    Writer writer=new Writer(){
      @Override public Collection<MemorySegment> close(){
        return Collections.emptyList();
      }
      @Override public boolean write(      IOReadableWritable readable){
        return sortedBuffer.write(readable);
      }
    }
;
    unsortedBuffer.writeToChannel(writer);
  }
  unsortedMemory=unsortedBuffer.unbind();
  int sortedPos=sortedBuffer.getPosition();
  sortedMemory=sortedBuffer.dispose();
{
    Comparator<TestData.Key> keyComparator=new TestData.KeyComparator();
    Buffer.Input buffer=new Buffer.Input(sortedMemory);
    buffer.reset(sortedPos);
    PactRecord rec1=new PactRecord();
    PactRecord rec2=new PactRecord();
    Key k1=new Key();
    Key k2=new Key();
    buffer.read(rec1);
    rec1.getFieldInto(0,k1);
    readPairs++;
    while (buffer.read(rec2)) {
      rec2.getFieldInto(0,k2);
      readPairs++;
      Assert.assertTrue(keyComparator.compare(k1,k2) <= 0);
      PactRecord tmp=rec1;
      rec1=rec2;
      k1.setKey(k2.getKey());
      rec2=tmp;
    }
  }
  Assert.assertEquals(writtenPairs,readPairs);
  memoryManager.release(unsortedMemory);
  memoryManager.release(sortedMemory);
}
