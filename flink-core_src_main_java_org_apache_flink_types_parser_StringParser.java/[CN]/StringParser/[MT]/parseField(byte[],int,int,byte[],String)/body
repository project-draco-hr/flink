{
  int i=startPos;
  byte current;
  boolean delimiterFound=false;
  final int delimLimit=limit - delimiter.length + 1;
  while (i < limit && ((current=bytes[i]) == WHITESPACE_SPACE || current == WHITESPACE_TAB)) {
    i++;
  }
  ParserStates parserState=ParserStates.NONE;
  int endOfCellPosition=i - 1;
  while (parserState != ParserStates.STOP && endOfCellPosition < limit) {
    endOfCellPosition++;
    if (endOfCellPosition == limit) {
      break;
    }
    if (endOfCellPosition < delimLimit && delimiterNext(bytes,endOfCellPosition,delimiter)) {
      if (parserState != ParserStates.IN_QUOTE) {
        parserState=ParserStates.STOP;
        delimiterFound=true;
      }
      endOfCellPosition+=delimiter.length - 1;
    }
 else     if (bytes[endOfCellPosition] == QUOTE_CHARACTER) {
      if (parserState == ParserStates.IN_QUOTE) {
        parserState=ParserStates.NONE;
      }
 else {
        parserState=ParserStates.IN_QUOTE;
      }
    }
  }
  int delimCorrection=delimiterFound ? delimiter.length : 1;
  if (parserState == ParserStates.IN_QUOTE) {
    setErrorState(ParseErrorState.UNTERMINATED_QUOTED_STRING);
    return -1;
  }
  if (i < limit && bytes[i] == QUOTE_CHARACTER) {
    current=bytes[endOfCellPosition - delimCorrection];
    if (!(current == WHITESPACE_SPACE || current == WHITESPACE_TAB || current == QUOTE_CHARACTER)) {
      setErrorState(ParseErrorState.UNQUOTED_CHARS_AFTER_QUOTED_STRING);
      return -1;
    }
    int skipAtEnd=0;
    while (bytes[endOfCellPosition - delimCorrection - skipAtEnd] == WHITESPACE_SPACE || bytes[endOfCellPosition - delimCorrection - skipAtEnd] == WHITESPACE_TAB) {
      skipAtEnd++;
    }
    boolean notEscaped=true;
    int endOfContent=i + 1;
    for (int counter=endOfContent; counter < endOfCellPosition - delimCorrection - skipAtEnd; counter++) {
      notEscaped=bytes[counter] != QUOTE_CHARACTER || !notEscaped;
      if (notEscaped) {
        bytes[endOfContent++]=bytes[counter];
      }
    }
    this.result=new String(bytes,i + 1,endOfContent - i - 1);
    return (endOfCellPosition == limit ? limit : endOfCellPosition + 1);
  }
 else {
    this.result=new String(bytes,i,endOfCellPosition - i - (delimCorrection - 1));
    return (endOfCellPosition == limit ? limit : endOfCellPosition + 1);
  }
}
