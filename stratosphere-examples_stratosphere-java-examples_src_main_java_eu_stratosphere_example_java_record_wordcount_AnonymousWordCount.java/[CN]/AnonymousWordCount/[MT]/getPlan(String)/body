{
  int defaultParallelism=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String inputPath=(args.length > 1 ? args[1] : "");
  String outputPath=(args.length > 2 ? args[2] : "");
  FileDataSource source=new FileDataSource(new TextInputFormat(),inputPath);
  MapOperator mapper=MapOperator.builder(new MapFunction(){
    public void map(    Record record,    Collector<Record> collector) throws Exception {
      String line=record.getField(0,StringValue.class).getValue();
      line=line.replaceAll("\\W+"," ").toLowerCase();
      StringTokenizer tokenizer=new StringTokenizer(line);
      while (tokenizer.hasMoreTokens()) {
        String word=tokenizer.nextToken();
        collector.collect(new Record(new StringValue(word),new IntValue(1)));
      }
    }
  }
).input(source).build();
  ReduceOperator reducer=ReduceOperator.builder(new ReduceFunction(){
    public void reduce(    Iterator<Record> records,    Collector<Record> collector){
      Record element=null;
      int sum=0;
      while (records.hasNext()) {
        element=records.next();
        int cnt=element.getField(1,IntValue.class).getValue();
        sum+=cnt;
      }
      element.setField(1,new IntValue(sum));
      collector.collect(element);
    }
  }
).keyField(StringValue.class,0).input(mapper).build();
  FileDataSink out=new FileDataSink(new CsvOutputFormat(),outputPath,reducer,"Word Counts");
  CsvOutputFormat.configureRecordFormat(out).recordDelimiter('\n').fieldDelimiter(' ').field(StringValue.class,0).field(IntValue.class,1);
  Plan plan=new Plan(out,"WordCount Example",defaultParallelism);
  return plan;
}
