def find_chain(obj, predicate, edge_func, max_depth=20, extra_ignore=()):
    queue = [obj]
    depth = {id(obj): 0, }
    parent = {id(obj): None, }
    ignore = set(extra_ignore)
    ignore.add(id(extra_ignore))
    ignore.add(id(queue))
    ignore.add(id(depth))
    ignore.add(id(parent))
    ignore.add(id(ignore))
    ignore.add(id(sys._getframe()))
    ignore.add(id(sys._getframe(1)))
    gc.collect()
    while queue:
        target = queue.pop(0)
        if predicate(target):
            chain = [target]
            while (parent[id(target)] is not None):
                target = parent[id(target)]
                chain.append(target)
            return chain
        tdepth = depth[id(target)]
        if (tdepth < max_depth):
            referrers = edge_func(target)
            ignore.add(id(referrers))
            for source in referrers:
                if (id(source) in ignore):
                    continue
                if (id(source) not in depth):
                    depth[id(source)] = (tdepth + 1)
                    parent[id(source)] = target
                    queue.append(source)
    return [obj]
